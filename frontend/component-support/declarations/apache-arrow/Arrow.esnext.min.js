!(function(t, e) {
  "object" == typeof exports && "object" == typeof module
    ? (module.exports = e())
    : "function" == typeof define && define.amd
    ? define("Arrow", [], e)
    : "object" == typeof exports
    ? (exports.Arrow = e())
    : (t.Arrow = e())
})(window, function() {
  return (function(t) {
    var e = {}
    function r(n) {
      if (e[n]) return e[n].exports
      var i = (e[n] = { i: n, l: !1, exports: {} })
      return t[n].call(i.exports, i, i.exports, r), (i.l = !0), i.exports
    }
    return (
      (r.m = t),
      (r.c = e),
      (r.d = function(t, e, n) {
        r.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n })
      }),
      (r.r = function(t) {
        "undefined" != typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
          Object.defineProperty(t, "__esModule", { value: !0 })
      }),
      (r.t = function(t, e) {
        if ((1 & e && (t = r(t)), 8 & e)) return t
        if (4 & e && "object" == typeof t && t && t.__esModule) return t
        var n = Object.create(null)
        if (
          (r.r(n),
          Object.defineProperty(n, "default", { enumerable: !0, value: t }),
          2 & e && "string" != typeof t)
        )
          for (var i in t)
            r.d(
              n,
              i,
              function(e) {
                return t[e]
              }.bind(null, i)
            )
        return n
      }),
      (r.n = function(t) {
        var e =
          t && t.__esModule
            ? function() {
                return t.default
              }
            : function() {
                return t
              }
        return r.d(e, "a", e), e
      }),
      (r.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
      }),
      (r.p = ""),
      r((r.s = 12))
    )
  })([
    function(t, e, r) {
      "use strict"
      r.r(e),
        r.d(e, "memcpy", function() {
          return u
        }),
        r.d(e, "joinUint8Arrays", function() {
          return c
        }),
        r.d(e, "toArrayBufferView", function() {
          return l
        }),
        r.d(e, "toInt8Array", function() {
          return h
        }),
        r.d(e, "toInt16Array", function() {
          return d
        }),
        r.d(e, "toInt32Array", function() {
          return f
        }),
        r.d(e, "toBigInt64Array", function() {
          return p
        }),
        r.d(e, "toUint8Array", function() {
          return y
        }),
        r.d(e, "toUint16Array", function() {
          return b
        }),
        r.d(e, "toUint32Array", function() {
          return g
        }),
        r.d(e, "toBigUint64Array", function() {
          return _
        }),
        r.d(e, "toFloat32Array", function() {
          return m
        }),
        r.d(e, "toFloat64Array", function() {
          return w
        }),
        r.d(e, "toUint8ClampedArray", function() {
          return v
        }),
        r.d(e, "toArrayBufferViewIterator", function() {
          return A
        }),
        r.d(e, "toInt8ArrayIterator", function() {
          return B
        }),
        r.d(e, "toInt16ArrayIterator", function() {
          return S
        }),
        r.d(e, "toInt32ArrayIterator", function() {
          return T
        }),
        r.d(e, "toUint8ArrayIterator", function() {
          return O
        }),
        r.d(e, "toUint16ArrayIterator", function() {
          return D
        }),
        r.d(e, "toUint32ArrayIterator", function() {
          return U
        }),
        r.d(e, "toFloat32ArrayIterator", function() {
          return L
        }),
        r.d(e, "toFloat64ArrayIterator", function() {
          return F
        }),
        r.d(e, "toUint8ClampedArrayIterator", function() {
          return x
        }),
        r.d(e, "toArrayBufferViewAsyncIterator", function() {
          return M
        }),
        r.d(e, "toInt8ArrayAsyncIterator", function() {
          return E
        }),
        r.d(e, "toInt16ArrayAsyncIterator", function() {
          return N
        }),
        r.d(e, "toInt32ArrayAsyncIterator", function() {
          return V
        }),
        r.d(e, "toUint8ArrayAsyncIterator", function() {
          return C
        }),
        r.d(e, "toUint16ArrayAsyncIterator", function() {
          return R
        }),
        r.d(e, "toUint32ArrayAsyncIterator", function() {
          return j
        }),
        r.d(e, "toFloat32ArrayAsyncIterator", function() {
          return k
        }),
        r.d(e, "toFloat64ArrayAsyncIterator", function() {
          return z
        }),
        r.d(e, "toUint8ClampedArrayAsyncIterator", function() {
          return P
        }),
        r.d(e, "rebaseValueOffsets", function() {
          return Y
        }),
        r.d(e, "compareArrayLike", function() {
          return $
        })
      var n = r(4),
        i = r(5),
        s = r(1),
        o = n.a.ByteBuffer
      const a =
        "undefined" != typeof SharedArrayBuffer
          ? SharedArrayBuffer
          : ArrayBuffer
      function u(t, e, r = 0, n = e.byteLength) {
        const i = t.byteLength,
          s = new Uint8Array(t.buffer, t.byteOffset, i),
          o = new Uint8Array(e.buffer, e.byteOffset, Math.min(n, i))
        return s.set(o, r), t
      }
      function c(t, e) {
        let r,
          n,
          i,
          s = (function(t) {
            let e,
              r,
              n,
              i,
              s = t[0] ? [t[0]] : []
            for (let o, a, u = 0, c = 0, l = t.length; ++u < l; )
              (o = s[c]),
                (a = t[u]),
                !o ||
                !a ||
                o.buffer !== a.buffer ||
                a.byteOffset < o.byteOffset
                  ? a && (s[++c] = a)
                  : (({ byteOffset: e, byteLength: n } = o),
                    ({ byteOffset: r, byteLength: i } = a),
                    e + n < r || r + i < e
                      ? a && (s[++c] = a)
                      : (s[c] = new Uint8Array(o.buffer, e, r - e + i)))
            return s
          })(t),
          o = s.reduce((t, e) => t + e.byteLength, 0),
          a = 0,
          c = -1,
          l = Math.min(e || 1 / 0, o)
        for (let h = s.length; ++c < h; ) {
          if (
            l <=
            a + (n = (r = s[c]).subarray(0, Math.min(r.length, l - a))).length
          ) {
            n.length < r.length
              ? (s[c] = r.subarray(n.length))
              : n.length === r.length && c++,
              i ? u(i, n, a) : (i = n)
            break
          }
          u(i || (i = new Uint8Array(l)), n, a), (a += n.length)
        }
        return [i || new Uint8Array(0), s.slice(c), o - (i ? i.byteLength : 0)]
      }
      function l(t, e) {
        let r = Object(s.j)(e) ? e.value : e
        return r instanceof t
          ? t === Uint8Array
            ? new t(r.buffer, r.byteOffset, r.byteLength)
            : r
          : r
          ? ("string" == typeof r && (r = Object(i.b)(r)),
            r instanceof ArrayBuffer
              ? new t(r)
              : r instanceof a
              ? new t(r)
              : r instanceof o
              ? l(t, r.bytes())
              : ArrayBuffer.isView(r)
              ? r.byteLength <= 0
                ? new t(0)
                : new t(
                    r.buffer,
                    r.byteOffset,
                    r.byteLength / t.BYTES_PER_ELEMENT
                  )
              : t.from(r))
          : new t(0)
      }
      const h = t => l(Int8Array, t),
        d = t => l(Int16Array, t),
        f = t => l(Int32Array, t),
        p = t => l(s.b, t),
        y = t => l(Uint8Array, t),
        b = t => l(Uint16Array, t),
        g = t => l(Uint32Array, t),
        _ = t => l(s.d, t),
        m = t => l(Float32Array, t),
        w = t => l(Float64Array, t),
        v = t => l(Uint8ClampedArray, t),
        I = t => (t.next(), t)
      function* A(t, e) {
        const r = function*(t) {
            yield t
          },
          n =
            "string" == typeof e
              ? r(e)
              : ArrayBuffer.isView(e)
              ? r(e)
              : e instanceof ArrayBuffer
              ? r(e)
              : e instanceof a
              ? r(e)
              : Object(s.i)(e)
              ? e
              : r(e)
        yield* I(
          (function*(e) {
            let r = null
            do {
              r = e.next(yield l(t, r))
            } while (!r.done)
          })(n[Symbol.iterator]())
        )
      }
      const B = t => A(Int8Array, t),
        S = t => A(Int16Array, t),
        T = t => A(Int32Array, t),
        O = t => A(Uint8Array, t),
        D = t => A(Uint16Array, t),
        U = t => A(Uint32Array, t),
        L = t => A(Float32Array, t),
        F = t => A(Float64Array, t),
        x = t => A(Uint8ClampedArray, t)
      async function* M(t, e) {
        if (Object(s.l)(e)) return yield* M(t, await e)
        const r = async function*(t) {
            yield await t
          },
          n =
            "string" == typeof e
              ? r(e)
              : ArrayBuffer.isView(e)
              ? r(e)
              : e instanceof ArrayBuffer
              ? r(e)
              : e instanceof a
              ? r(e)
              : Object(s.i)(e)
              ? (async function*(t) {
                  yield* I(
                    (function*(t) {
                      let e = null
                      do {
                        e = t.next(yield e && e.value)
                      } while (!e.done)
                    })(t[Symbol.iterator]())
                  )
                })(e)
              : Object(s.f)(e)
              ? e
              : r(e)
        yield* I(
          (async function*(e) {
            let r = null
            do {
              r = await e.next(yield l(t, r))
            } while (!r.done)
          })(n[Symbol.asyncIterator]())
        )
      }
      const E = t => M(Int8Array, t),
        N = t => M(Int16Array, t),
        V = t => M(Int32Array, t),
        C = t => M(Uint8Array, t),
        R = t => M(Uint16Array, t),
        j = t => M(Uint32Array, t),
        k = t => M(Float32Array, t),
        z = t => M(Float64Array, t),
        P = t => M(Uint8ClampedArray, t)
      function Y(t, e, r) {
        if (0 !== t) {
          r = r.slice(0, e + 1)
          for (let n = -1; ++n <= e; ) r[n] += t
        }
        return r
      }
      function $(t, e) {
        let r = 0,
          n = t.length
        if (n !== e.length) return !1
        if (n > 0)
          do {
            if (t[r] !== e[r]) return !1
          } while (++r < n)
        return !0
      }
    },
    function(t, e, r) {
      "use strict"
      r.d(e, "a", function() {
        return i
      }),
        r.d(e, "c", function() {
          return s
        }),
        r.d(e, "b", function() {
          return o
        }),
        r.d(e, "d", function() {
          return u
        }),
        r.d(e, "k", function() {
          return f
        }),
        r.d(e, "l", function() {
          return p
        }),
        r.d(e, "i", function() {
          return y
        }),
        r.d(e, "f", function() {
          return b
        }),
        r.d(e, "e", function() {
          return g
        }),
        r.d(e, "j", function() {
          return _
        }),
        r.d(e, "h", function() {
          return m
        }),
        r.d(e, "g", function() {
          return w
        }),
        r.d(e, "o", function() {
          return v
        }),
        r.d(e, "m", function() {
          return I
        }),
        r.d(e, "p", function() {
          return A
        }),
        r.d(e, "n", function() {
          return B
        })
      var n = r(2)
      const [i, s] = (() => {
          const t = () => {
            throw Error("BigInt is not available in this environment")
          }
          function e() {
            throw t()
          }
          return (
            (e.asIntN = () => {
              throw t()
            }),
            (e.asUintN = () => {
              throw t()
            }),
            "undefined" != typeof BigInt ? [BigInt, !0] : [e, !1]
          )
        })(),
        [o, a] = (() => {
          const t = () => {
            throw Error("BigInt64Array is not available in this environment")
          }
          return "undefined" != typeof BigInt64Array
            ? [BigInt64Array, !0]
            : [
                class {
                  static get BYTES_PER_ELEMENT() {
                    return 8
                  }
                  static of() {
                    throw t()
                  }
                  static from() {
                    throw t()
                  }
                  constructor() {
                    throw t()
                  }
                },
                !1,
              ]
        })(),
        [u, c] = (() => {
          const t = () => {
            throw Error("BigUint64Array is not available in this environment")
          }
          return "undefined" != typeof BigUint64Array
            ? [BigUint64Array, !0]
            : [
                class {
                  static get BYTES_PER_ELEMENT() {
                    return 8
                  }
                  static of() {
                    throw t()
                  }
                  static from() {
                    throw t()
                  }
                  constructor() {
                    throw t()
                  }
                },
                !1,
              ]
        })(),
        l = t => "number" == typeof t,
        h = t => "boolean" == typeof t,
        d = t => "function" == typeof t,
        f = t => null != t && Object(t) === t,
        p = t => f(t) && d(t.then),
        y = t => f(t) && d(t[Symbol.iterator]),
        b = t => f(t) && d(t[Symbol.asyncIterator]),
        g = t => f(t) && f(t.schema),
        _ = t => f(t) && "done" in t && "value" in t,
        m = t => f(t) && d(t.stat) && l(t.fd),
        w = t => f(t) && I(t.body),
        v = t => f(t) && d(t.abort) && d(t.getWriter) && !(t instanceof n.d),
        I = t => f(t) && d(t.cancel) && d(t.getReader) && !(t instanceof n.d),
        A = t =>
          f(t) &&
          d(t.end) &&
          d(t.write) &&
          h(t.writable) &&
          !(t instanceof n.d),
        B = t =>
          f(t) &&
          d(t.read) &&
          d(t.pipe) &&
          h(t.readable) &&
          !(t instanceof n.d)
    },
    function(t, e, r) {
      "use strict"
      r.d(e, "c", function() {
        return i
      }),
        r.d(e, "a", function() {
          return s
        }),
        r.d(e, "d", function() {
          return o
        }),
        r.d(e, "b", function() {
          return a
        })
      var n = r(3)
      const i = Object.freeze({ done: !0, value: void 0 })
      class s {
        constructor(t) {
          this._json = t
        }
        get schema() {
          return this._json.schema
        }
        get batches() {
          return this._json.batches || []
        }
        get dictionaries() {
          return this._json.dictionaries || []
        }
      }
      class o {
        tee() {
          return this._getDOMStream().tee()
        }
        pipe(t, e) {
          return this._getNodeStream().pipe(
            t,
            e
          )
        }
        pipeTo(t, e) {
          return this._getDOMStream().pipeTo(t, e)
        }
        pipeThrough(t, e) {
          return this._getDOMStream().pipeThrough(t, e)
        }
        _getDOMStream() {
          return this._DOMStream || (this._DOMStream = this.toDOMStream())
        }
        _getNodeStream() {
          return this._nodeStream || (this._nodeStream = this.toNodeStream())
        }
      }
      class a extends o {
        constructor() {
          super(),
            (this._values = []),
            (this.resolvers = []),
            (this._closedPromise = new Promise(
              t => (this._closedPromiseResolve = t)
            ))
        }
        get closed() {
          return this._closedPromise
        }
        async cancel(t) {
          await this.return(t)
        }
        write(t) {
          this._ensureOpen() &&
            (this.resolvers.length <= 0
              ? this._values.push(t)
              : this.resolvers.shift().resolve({ done: !1, value: t }))
        }
        abort(t) {
          this._closedPromiseResolve &&
            (this.resolvers.length <= 0
              ? (this._error = { error: t })
              : this.resolvers.shift().reject({ done: !0, value: t }))
        }
        close() {
          if (this._closedPromiseResolve) {
            const { resolvers: t } = this
            for (; t.length > 0; ) t.shift().resolve(i)
            this._closedPromiseResolve(), (this._closedPromiseResolve = void 0)
          }
        }
        [Symbol.asyncIterator]() {
          return this
        }
        toDOMStream(t) {
          return n.a.toDOMStream(
            this._closedPromiseResolve || this._error ? this : this._values,
            t
          )
        }
        toNodeStream(t) {
          return n.a.toNodeStream(
            this._closedPromiseResolve || this._error ? this : this._values,
            t
          )
        }
        async throw(t) {
          return await this.abort(t), i
        }
        async return(t) {
          return await this.close(), i
        }
        async read(t) {
          return (await this.next(t, "read")).value
        }
        async peek(t) {
          return (await this.next(t, "peek")).value
        }
        next(...t) {
          return this._values.length > 0
            ? Promise.resolve({ done: !1, value: this._values.shift() })
            : this._error
            ? Promise.reject({ done: !0, value: this._error.error })
            : this._closedPromiseResolve
            ? new Promise((t, e) => {
                this.resolvers.push({ resolve: t, reject: e })
              })
            : Promise.resolve(i)
        }
        _ensureOpen() {
          if (this._closedPromiseResolve) return !0
          throw Error(`${this} is closed`)
        }
      }
    },
    function(t, e, r) {
      "use strict"
      var n = r(0)
      e.a = {
        fromIterable: t =>
          i(
            (function*(t) {
              let e,
                r,
                i,
                s,
                o = !1,
                a = [],
                u = 0
              function c() {
                return "peek" === i
                  ? Object(n.joinUint8Arrays)(a, s)[0]
                  : (([r, a, u] = Object(n.joinUint8Arrays)(a, s)), r)
              }
              ;({ cmd: i, size: s } = yield null)
              let l = Object(n.toUint8ArrayIterator)(t)[Symbol.iterator]()
              try {
                do {
                  if (
                    (({ done: e, value: r } = isNaN(s - u)
                      ? l.next(void 0)
                      : l.next(s - u)),
                    !e && r.byteLength > 0 && (a.push(r), (u += r.byteLength)),
                    e || s <= u)
                  )
                    do {
                      ;({ cmd: i, size: s } = yield c())
                    } while (s < u)
                } while (!e)
              } catch (h) {
                ;(o = !0) && "function" == typeof l.throw && l.throw(h)
              } finally {
                !1 === o && "function" == typeof l.return && l.return()
              }
            })(t)
          ),
        fromAsyncIterable: t =>
          i(
            (async function*(t) {
              let e,
                r,
                i,
                s,
                o = !1,
                a = [],
                u = 0
              function c() {
                return "peek" === i
                  ? Object(n.joinUint8Arrays)(a, s)[0]
                  : (([r, a, u] = Object(n.joinUint8Arrays)(a, s)), r)
              }
              ;({ cmd: i, size: s } = yield null)
              let l = Object(n.toUint8ArrayAsyncIterator)(t)[
                Symbol.asyncIterator
              ]()
              try {
                do {
                  if (
                    (({ done: e, value: r } = isNaN(s - u)
                      ? await l.next(void 0)
                      : await l.next(s - u)),
                    !e && r.byteLength > 0 && (a.push(r), (u += r.byteLength)),
                    e || s <= u)
                  )
                    do {
                      ;({ cmd: i, size: s } = yield c())
                    } while (s < u)
                } while (!e)
              } catch (h) {
                ;(o = !0) && "function" == typeof l.throw && (await l.throw(h))
              } finally {
                !1 === o && "function" == typeof l.return && (await l.return())
              }
            })(t)
          ),
        fromDOMStream: t =>
          i(
            (async function*(t) {
              let e,
                r,
                i,
                o = !1,
                a = !1,
                u = [],
                c = 0
              function l() {
                return "peek" === r
                  ? Object(n.joinUint8Arrays)(u, i)[0]
                  : (([e, u, c] = Object(n.joinUint8Arrays)(u, i)), e)
              }
              ;({ cmd: r, size: i } = yield null)
              let h = new s(t)
              try {
                do {
                  if (
                    (({ done: o, value: e } = isNaN(i - c)
                      ? await h.read(void 0)
                      : await h.read(i - c)),
                    !o &&
                      e.byteLength > 0 &&
                      (u.push(Object(n.toUint8Array)(e)), (c += e.byteLength)),
                    o || i <= c)
                  )
                    do {
                      ;({ cmd: r, size: i } = yield l())
                    } while (i < c)
                } while (!o)
              } catch (d) {
                ;(a = !0) && (await h.cancel(d))
              } finally {
                !1 === a ? await h.cancel() : t.locked && h.releaseLock()
              }
            })(t)
          ),
        fromNodeStream: t =>
          i(
            (async function*(t) {
              let e,
                r,
                i,
                s = [],
                a = "error",
                u = !1,
                c = null,
                l = 0,
                h = []
              function d() {
                return "peek" === e
                  ? Object(n.joinUint8Arrays)(h, r)[0]
                  : (([i, h, l] = Object(n.joinUint8Arrays)(h, r)), i)
              }
              if ((({ cmd: e, size: r } = yield null), t.isTTY))
                return yield new Uint8Array(0)
              try {
                ;(s[0] = o(t, "end")), (s[1] = o(t, "error"))
                do {
                  if (
                    ((s[2] = o(t, "readable")),
                    ([a, c] = await Promise.race(s.map(t => t[2]))),
                    "error" === a)
                  )
                    break
                  if (
                    ((u = "end" === a) ||
                      (isFinite(r - l)
                        ? (i = Object(n.toUint8Array)(t.read(r - l)))
                            .byteLength <
                            r - l &&
                          (i = Object(n.toUint8Array)(t.read(void 0)))
                        : (i = Object(n.toUint8Array)(t.read(void 0))),
                      i.byteLength > 0 && (h.push(i), (l += i.byteLength))),
                    u || r <= l)
                  )
                    do {
                      ;({ cmd: e, size: r } = yield d())
                    } while (r < l)
                } while (!u)
              } finally {
                await (function(e, r) {
                  return (
                    (i = h = null),
                    new Promise(async (n, i) => {
                      for (const [r, o] of e) t.off(r, o)
                      try {
                        const e = t.destroy
                        e && e.call(t, r), (r = void 0)
                      } catch (s) {
                        r = s || r
                      } finally {
                        null != r ? i(r) : n()
                      }
                    })
                  )
                })(s, "error" === a ? c : null)
              }
            })(t)
          ),
        toDOMStream(t, e) {
          throw Error('"toDOMStream" not available in this environment')
        },
        toNodeStream(t, e) {
          throw Error('"toNodeStream" not available in this environment')
        },
      }
      const i = t => (t.next(), t)
      class s {
        constructor(t) {
          ;(this.source = t),
            (this.byobReader = null),
            (this.defaultReader = null)
          try {
            this.supportsBYOB = !!(this.reader = this.getBYOBReader())
          } catch (e) {
            this.supportsBYOB = !(this.reader = this.getDefaultReader())
          }
        }
        get closed() {
          return this.reader
            ? this.reader.closed.catch(() => {})
            : Promise.resolve()
        }
        releaseLock() {
          this.reader && this.reader.releaseLock(),
            (this.reader = this.byobReader = this.defaultReader = null)
        }
        async cancel(t) {
          const { reader: e, source: r } = this
          e && (await e.cancel(t).catch(() => {})),
            r && r.locked && this.releaseLock()
        }
        async read(t) {
          if (0 === t)
            return { done: null == this.reader, value: new Uint8Array(0) }
          const e =
            this.supportsBYOB && "number" == typeof t
              ? await this.readFromBYOBReader(t)
              : await this.getDefaultReader().read()
          return !e.done && (e.value = Object(n.toUint8Array)(e)), e
        }
        getDefaultReader() {
          return (
            this.byobReader && this.releaseLock(),
            this.defaultReader ||
              ((this.defaultReader = this.source.getReader()),
              this.defaultReader.closed.catch(() => {})),
            (this.reader = this.defaultReader)
          )
        }
        getBYOBReader() {
          return (
            this.defaultReader && this.releaseLock(),
            this.byobReader ||
              ((this.byobReader = this.source.getReader({ mode: "byob" })),
              this.byobReader.closed.catch(() => {})),
            (this.reader = this.byobReader)
          )
        }
        async readFromBYOBReader(t) {
          return await (async function t(e, r, n, i) {
            if (n >= i) return { done: !1, value: new Uint8Array(r, 0, i) }
            const { done: s, value: o } = await e.read(
              new Uint8Array(r, n, i - n)
            )
            if ((n += o.byteLength) < i && !s)
              return await t(e, o.buffer, n, i)
            return { done: s, value: new Uint8Array(o.buffer, 0, n) }
          })(this.getBYOBReader(), new ArrayBuffer(t), 0, t)
        }
      }
      const o = (t, e) => {
        let r,
          n = t => r([e, t])
        return [e, n, new Promise(i => (r = i) && t.once(e, n))]
      }
    },
    function(t, e, r) {
      "use strict"
      r.d(e, "a", function() {
        return n
      })
      var n = {}
      n.Offset,
        n.Table,
        (n.SIZEOF_SHORT = 2),
        (n.SIZEOF_INT = 4),
        (n.FILE_IDENTIFIER_LENGTH = 4),
        (n.Encoding = { UTF8_BYTES: 1, UTF16_STRING: 2 }),
        (n.int32 = new Int32Array(2)),
        (n.float32 = new Float32Array(n.int32.buffer)),
        (n.float64 = new Float64Array(n.int32.buffer)),
        (n.isLittleEndian =
          1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0]),
        (n.Long = function(t, e) {
          ;(this.low = 0 | t), (this.high = 0 | e)
        }),
        (n.Long.create = function(t, e) {
          return 0 == t && 0 == e ? n.Long.ZERO : new n.Long(t, e)
        }),
        (n.Long.prototype.toFloat64 = function() {
          return (this.low >>> 0) + 4294967296 * this.high
        }),
        (n.Long.prototype.equals = function(t) {
          return this.low == t.low && this.high == t.high
        }),
        (n.Long.ZERO = new n.Long(0, 0)),
        (n.Builder = function(t) {
          if (t) e = t
          else var e = 1024
          ;(this.bb = n.ByteBuffer.allocate(e)),
            (this.space = e),
            (this.minalign = 1),
            (this.vtable = null),
            (this.vtable_in_use = 0),
            (this.isNested = !1),
            (this.object_start = 0),
            (this.vtables = []),
            (this.vector_num_elems = 0),
            (this.force_defaults = !1)
        }),
        (n.Builder.prototype.clear = function() {
          this.bb.clear(),
            (this.space = this.bb.capacity()),
            (this.minalign = 1),
            (this.vtable = null),
            (this.vtable_in_use = 0),
            (this.isNested = !1),
            (this.object_start = 0),
            (this.vtables = []),
            (this.vector_num_elems = 0),
            (this.force_defaults = !1)
        }),
        (n.Builder.prototype.forceDefaults = function(t) {
          this.force_defaults = t
        }),
        (n.Builder.prototype.dataBuffer = function() {
          return this.bb
        }),
        (n.Builder.prototype.asUint8Array = function() {
          return this.bb
            .bytes()
            .subarray(this.bb.position(), this.bb.position() + this.offset())
        }),
        (n.Builder.prototype.prep = function(t, e) {
          t > this.minalign && (this.minalign = t)
          for (
            var r = (1 + ~(this.bb.capacity() - this.space + e)) & (t - 1);
            this.space < r + t + e;

          ) {
            var i = this.bb.capacity()
            ;(this.bb = n.Builder.growByteBuffer(this.bb)),
              (this.space += this.bb.capacity() - i)
          }
          this.pad(r)
        }),
        (n.Builder.prototype.pad = function(t) {
          for (var e = 0; e < t; e++) this.bb.writeInt8(--this.space, 0)
        }),
        (n.Builder.prototype.writeInt8 = function(t) {
          this.bb.writeInt8((this.space -= 1), t)
        }),
        (n.Builder.prototype.writeInt16 = function(t) {
          this.bb.writeInt16((this.space -= 2), t)
        }),
        (n.Builder.prototype.writeInt32 = function(t) {
          this.bb.writeInt32((this.space -= 4), t)
        }),
        (n.Builder.prototype.writeInt64 = function(t) {
          this.bb.writeInt64((this.space -= 8), t)
        }),
        (n.Builder.prototype.writeFloat32 = function(t) {
          this.bb.writeFloat32((this.space -= 4), t)
        }),
        (n.Builder.prototype.writeFloat64 = function(t) {
          this.bb.writeFloat64((this.space -= 8), t)
        }),
        (n.Builder.prototype.addInt8 = function(t) {
          this.prep(1, 0), this.writeInt8(t)
        }),
        (n.Builder.prototype.addInt16 = function(t) {
          this.prep(2, 0), this.writeInt16(t)
        }),
        (n.Builder.prototype.addInt32 = function(t) {
          this.prep(4, 0), this.writeInt32(t)
        }),
        (n.Builder.prototype.addInt64 = function(t) {
          this.prep(8, 0), this.writeInt64(t)
        }),
        (n.Builder.prototype.addFloat32 = function(t) {
          this.prep(4, 0), this.writeFloat32(t)
        }),
        (n.Builder.prototype.addFloat64 = function(t) {
          this.prep(8, 0), this.writeFloat64(t)
        }),
        (n.Builder.prototype.addFieldInt8 = function(t, e, r) {
          ;(this.force_defaults || e != r) && (this.addInt8(e), this.slot(t))
        }),
        (n.Builder.prototype.addFieldInt16 = function(t, e, r) {
          ;(this.force_defaults || e != r) && (this.addInt16(e), this.slot(t))
        }),
        (n.Builder.prototype.addFieldInt32 = function(t, e, r) {
          ;(this.force_defaults || e != r) && (this.addInt32(e), this.slot(t))
        }),
        (n.Builder.prototype.addFieldInt64 = function(t, e, r) {
          ;(!this.force_defaults && e.equals(r)) ||
            (this.addInt64(e), this.slot(t))
        }),
        (n.Builder.prototype.addFieldFloat32 = function(t, e, r) {
          ;(this.force_defaults || e != r) &&
            (this.addFloat32(e), this.slot(t))
        }),
        (n.Builder.prototype.addFieldFloat64 = function(t, e, r) {
          ;(this.force_defaults || e != r) &&
            (this.addFloat64(e), this.slot(t))
        }),
        (n.Builder.prototype.addFieldOffset = function(t, e, r) {
          ;(this.force_defaults || e != r) && (this.addOffset(e), this.slot(t))
        }),
        (n.Builder.prototype.addFieldStruct = function(t, e, r) {
          e != r && (this.nested(e), this.slot(t))
        }),
        (n.Builder.prototype.nested = function(t) {
          if (t != this.offset())
            throw Error("FlatBuffers: struct must be serialized inline.")
        }),
        (n.Builder.prototype.notNested = function() {
          if (this.isNested)
            throw Error(
              "FlatBuffers: object serialization must not be nested."
            )
        }),
        (n.Builder.prototype.slot = function(t) {
          this.vtable[t] = this.offset()
        }),
        (n.Builder.prototype.offset = function() {
          return this.bb.capacity() - this.space
        }),
        (n.Builder.growByteBuffer = function(t) {
          var e = t.capacity()
          if (3221225472 & e)
            throw Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.")
          var r = e << 1,
            i = n.ByteBuffer.allocate(r)
          return i.setPosition(r - e), i.bytes().set(t.bytes(), r - e), i
        }),
        (n.Builder.prototype.addOffset = function(t) {
          this.prep(n.SIZEOF_INT, 0),
            this.writeInt32(this.offset() - t + n.SIZEOF_INT)
        }),
        (n.Builder.prototype.startObject = function(t) {
          this.notNested(),
            null == this.vtable && (this.vtable = []),
            (this.vtable_in_use = t)
          for (var e = 0; e < t; e++) this.vtable[e] = 0
          ;(this.isNested = !0), (this.object_start = this.offset())
        }),
        (n.Builder.prototype.endObject = function() {
          if (null == this.vtable || !this.isNested)
            throw Error("FlatBuffers: endObject called without startObject")
          this.addInt32(0)
          for (
            var t = this.offset(), e = this.vtable_in_use - 1;
            e >= 0 && 0 == this.vtable[e];
            e--
          );
          for (var r = e + 1; e >= 0; e--)
            this.addInt16(0 != this.vtable[e] ? t - this.vtable[e] : 0)
          this.addInt16(t - this.object_start)
          var i = (r + 2) * n.SIZEOF_SHORT
          this.addInt16(i)
          var s = 0,
            o = this.space
          t: for (e = 0; e < this.vtables.length; e++) {
            var a = this.bb.capacity() - this.vtables[e]
            if (i == this.bb.readInt16(a)) {
              for (var u = n.SIZEOF_SHORT; u < i; u += n.SIZEOF_SHORT)
                if (this.bb.readInt16(o + u) != this.bb.readInt16(a + u))
                  continue t
              s = this.vtables[e]
              break
            }
          }
          return (
            s
              ? ((this.space = this.bb.capacity() - t),
                this.bb.writeInt32(this.space, s - t))
              : (this.vtables.push(this.offset()),
                this.bb.writeInt32(this.bb.capacity() - t, this.offset() - t)),
            (this.isNested = !1),
            t
          )
        }),
        (n.Builder.prototype.finish = function(t, e) {
          if (e) {
            var r = e
            if (
              (this.prep(
                this.minalign,
                n.SIZEOF_INT + n.FILE_IDENTIFIER_LENGTH
              ),
              r.length != n.FILE_IDENTIFIER_LENGTH)
            )
              throw Error(
                "FlatBuffers: file identifier must be length " +
                  n.FILE_IDENTIFIER_LENGTH
              )
            for (var i = n.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--)
              this.writeInt8(r.charCodeAt(i))
          }
          this.prep(this.minalign, n.SIZEOF_INT),
            this.addOffset(t),
            this.bb.setPosition(this.space)
        }),
        (n.Builder.prototype.requiredField = function(t, e) {
          var r = this.bb.capacity() - t,
            n = r - this.bb.readInt32(r)
          if (!(0 != this.bb.readInt16(n + e)))
            throw Error("FlatBuffers: field " + e + " must be set")
        }),
        (n.Builder.prototype.startVector = function(t, e, r) {
          this.notNested(),
            (this.vector_num_elems = e),
            this.prep(n.SIZEOF_INT, t * e),
            this.prep(r, t * e)
        }),
        (n.Builder.prototype.endVector = function() {
          return this.writeInt32(this.vector_num_elems), this.offset()
        }),
        (n.Builder.prototype.createString = function(t) {
          if (t instanceof Uint8Array) var e = t
          else {
            e = []
            for (var r = 0; r < t.length; ) {
              var n,
                i = t.charCodeAt(r++)
              if (i < 55296 || i >= 56320) n = i
              else n = (i << 10) + t.charCodeAt(r++) + -56613888
              n < 128
                ? e.push(n)
                : (n < 2048
                    ? e.push(((n >> 6) & 31) | 192)
                    : (n < 65536
                        ? e.push(((n >> 12) & 15) | 224)
                        : e.push(
                            ((n >> 18) & 7) | 240,
                            ((n >> 12) & 63) | 128
                          ),
                      e.push(((n >> 6) & 63) | 128)),
                  e.push((63 & n) | 128))
            }
          }
          this.addInt8(0),
            this.startVector(1, e.length, 1),
            this.bb.setPosition((this.space -= e.length))
          r = 0
          for (var s = this.space, o = this.bb.bytes(); r < e.length; r++)
            o[s++] = e[r]
          return this.endVector()
        }),
        (n.Builder.prototype.createLong = function(t, e) {
          return n.Long.create(t, e)
        }),
        (n.ByteBuffer = function(t) {
          ;(this.bytes_ = t), (this.position_ = 0)
        }),
        (n.ByteBuffer.allocate = function(t) {
          return new n.ByteBuffer(new Uint8Array(t))
        }),
        (n.ByteBuffer.prototype.clear = function() {
          this.position_ = 0
        }),
        (n.ByteBuffer.prototype.bytes = function() {
          return this.bytes_
        }),
        (n.ByteBuffer.prototype.position = function() {
          return this.position_
        }),
        (n.ByteBuffer.prototype.setPosition = function(t) {
          this.position_ = t
        }),
        (n.ByteBuffer.prototype.capacity = function() {
          return this.bytes_.length
        }),
        (n.ByteBuffer.prototype.readInt8 = function(t) {
          return (this.readUint8(t) << 24) >> 24
        }),
        (n.ByteBuffer.prototype.readUint8 = function(t) {
          return this.bytes_[t]
        }),
        (n.ByteBuffer.prototype.readInt16 = function(t) {
          return (this.readUint16(t) << 16) >> 16
        }),
        (n.ByteBuffer.prototype.readUint16 = function(t) {
          return this.bytes_[t] | (this.bytes_[t + 1] << 8)
        }),
        (n.ByteBuffer.prototype.readInt32 = function(t) {
          return (
            this.bytes_[t] |
            (this.bytes_[t + 1] << 8) |
            (this.bytes_[t + 2] << 16) |
            (this.bytes_[t + 3] << 24)
          )
        }),
        (n.ByteBuffer.prototype.readUint32 = function(t) {
          return this.readInt32(t) >>> 0
        }),
        (n.ByteBuffer.prototype.readInt64 = function(t) {
          return new n.Long(this.readInt32(t), this.readInt32(t + 4))
        }),
        (n.ByteBuffer.prototype.readUint64 = function(t) {
          return new n.Long(this.readUint32(t), this.readUint32(t + 4))
        }),
        (n.ByteBuffer.prototype.readFloat32 = function(t) {
          return (n.int32[0] = this.readInt32(t)), n.float32[0]
        }),
        (n.ByteBuffer.prototype.readFloat64 = function(t) {
          return (
            (n.int32[n.isLittleEndian ? 0 : 1] = this.readInt32(t)),
            (n.int32[n.isLittleEndian ? 1 : 0] = this.readInt32(t + 4)),
            n.float64[0]
          )
        }),
        (n.ByteBuffer.prototype.writeInt8 = function(t, e) {
          this.bytes_[t] = e
        }),
        (n.ByteBuffer.prototype.writeUint8 = function(t, e) {
          this.bytes_[t] = e
        }),
        (n.ByteBuffer.prototype.writeInt16 = function(t, e) {
          ;(this.bytes_[t] = e), (this.bytes_[t + 1] = e >> 8)
        }),
        (n.ByteBuffer.prototype.writeUint16 = function(t, e) {
          ;(this.bytes_[t] = e), (this.bytes_[t + 1] = e >> 8)
        }),
        (n.ByteBuffer.prototype.writeInt32 = function(t, e) {
          ;(this.bytes_[t] = e),
            (this.bytes_[t + 1] = e >> 8),
            (this.bytes_[t + 2] = e >> 16),
            (this.bytes_[t + 3] = e >> 24)
        }),
        (n.ByteBuffer.prototype.writeUint32 = function(t, e) {
          ;(this.bytes_[t] = e),
            (this.bytes_[t + 1] = e >> 8),
            (this.bytes_[t + 2] = e >> 16),
            (this.bytes_[t + 3] = e >> 24)
        }),
        (n.ByteBuffer.prototype.writeInt64 = function(t, e) {
          this.writeInt32(t, e.low), this.writeInt32(t + 4, e.high)
        }),
        (n.ByteBuffer.prototype.writeUint64 = function(t, e) {
          this.writeUint32(t, e.low), this.writeUint32(t + 4, e.high)
        }),
        (n.ByteBuffer.prototype.writeFloat32 = function(t, e) {
          ;(n.float32[0] = e), this.writeInt32(t, n.int32[0])
        }),
        (n.ByteBuffer.prototype.writeFloat64 = function(t, e) {
          ;(n.float64[0] = e),
            this.writeInt32(t, n.int32[n.isLittleEndian ? 0 : 1]),
            this.writeInt32(t + 4, n.int32[n.isLittleEndian ? 1 : 0])
        }),
        (n.ByteBuffer.prototype.getBufferIdentifier = function() {
          if (
            this.bytes_.length <
            this.position_ + n.SIZEOF_INT + n.FILE_IDENTIFIER_LENGTH
          )
            throw Error(
              "FlatBuffers: ByteBuffer is too short to contain an identifier."
            )
          for (var t = "", e = 0; e < n.FILE_IDENTIFIER_LENGTH; e++)
            t += String.fromCharCode(
              this.readInt8(this.position_ + n.SIZEOF_INT + e)
            )
          return t
        }),
        (n.ByteBuffer.prototype.__offset = function(t, e) {
          var r = t - this.readInt32(t)
          return e < this.readInt16(r) ? this.readInt16(r + e) : 0
        }),
        (n.ByteBuffer.prototype.__union = function(t, e) {
          return (t.bb_pos = e + this.readInt32(e)), (t.bb = this), t
        }),
        (n.ByteBuffer.prototype.__string = function(t, e) {
          t += this.readInt32(t)
          var r = this.readInt32(t),
            i = "",
            s = 0
          if (((t += n.SIZEOF_INT), e === n.Encoding.UTF8_BYTES))
            return this.bytes_.subarray(t, t + r)
          for (; s < r; ) {
            var o,
              a = this.readUint8(t + s++)
            if (a < 192) o = a
            else {
              var u = this.readUint8(t + s++)
              if (a < 224) o = ((31 & a) << 6) | (63 & u)
              else {
                var c = this.readUint8(t + s++)
                if (a < 240) o = ((15 & a) << 12) | ((63 & u) << 6) | (63 & c)
                else
                  o =
                    ((7 & a) << 18) |
                    ((63 & u) << 12) |
                    ((63 & c) << 6) |
                    (63 & this.readUint8(t + s++))
              }
            }
            i +=
              o < 65536
                ? String.fromCharCode(o)
                : String.fromCharCode(
                    55296 + ((o -= 65536) >> 10),
                    56320 + (1023 & o)
                  )
          }
          return i
        }),
        (n.ByteBuffer.prototype.__indirect = function(t) {
          return t + this.readInt32(t)
        }),
        (n.ByteBuffer.prototype.__vector = function(t) {
          return t + this.readInt32(t) + n.SIZEOF_INT
        }),
        (n.ByteBuffer.prototype.__vector_len = function(t) {
          return this.readInt32(t + this.readInt32(t))
        }),
        (n.ByteBuffer.prototype.__has_identifier = function(t) {
          if (t.length != n.FILE_IDENTIFIER_LENGTH)
            throw Error(
              "FlatBuffers: file identifier must be length " +
                n.FILE_IDENTIFIER_LENGTH
            )
          for (var e = 0; e < n.FILE_IDENTIFIER_LENGTH; e++)
            if (
              t.charCodeAt(e) !=
              this.readInt8(this.position_ + n.SIZEOF_INT + e)
            )
              return !1
          return !0
        }),
        (n.ByteBuffer.prototype.createLong = function(t, e) {
          return n.Long.create(t, e)
        })
    },
    function(t, e, r) {
      "use strict"
      !(function(t) {
        r.d(e, "a", function() {
          return a
        }),
          r.d(e, "b", function() {
            return u
          })
        var n = r(0),
          i = r(6)
        const s = "function" == typeof t ? t : null,
          o =
            "function" == typeof TextDecoder &&
            "function" == typeof TextEncoder,
          a = (t => {
            if (o || !s) {
              const e = new t("utf-8")
              return t => e.decode(t)
            }
            return t => {
              const { buffer: e, byteOffset: r, length: i } = Object(
                n.toUint8Array
              )(t)
              return s.from(e, r, i).toString()
            }
          })("undefined" != typeof TextDecoder ? TextDecoder : i.a),
          u = (t => {
            if (o || !s) {
              const e = new t()
              return t => e.encode(t)
            }
            return (t = "") => Object(n.toUint8Array)(s.from(t, "utf8"))
          })("undefined" != typeof TextEncoder ? TextEncoder : i.b)
      })(r(7).Buffer)
    },
    function(t, e, r) {
      "use strict"
      function n(t, e, r) {
        return e <= t && t <= r
      }
      function i(t) {
        if (void 0 === t) return {}
        if (t === Object(t)) return t
        throw TypeError("Could not convert argument to dictionary")
      }
      r.d(e, "b", function() {
        return h
      }),
        r.d(e, "a", function() {
          return l
        })
      var s = -1
      function o(t) {
        this.tokens = [].slice.call(t)
      }
      o.prototype = {
        endOfStream: function() {
          return !this.tokens.length
        },
        read: function() {
          return this.tokens.length ? this.tokens.shift() : s
        },
        prepend: function(t) {
          if (Array.isArray(t))
            for (var e = t; e.length; ) this.tokens.unshift(e.pop())
          else this.tokens.unshift(t)
        },
        push: function(t) {
          if (Array.isArray(t))
            for (var e = t; e.length; ) this.tokens.push(e.shift())
          else this.tokens.push(t)
        },
      }
      var a = -1
      function u(t, e) {
        if (t) throw TypeError("Decoder error")
        return e || 65533
      }
      var c = "utf-8"
      function l(t, e) {
        if (!(this instanceof l)) return new l(t, e)
        if ((t = void 0 !== t ? (t + "").toLowerCase() : c) !== c)
          throw Error("Encoding not supported. Only utf-8 is supported")
        ;(e = i(e)),
          (this._streaming = !1),
          (this._BOMseen = !1),
          (this._decoder = null),
          (this._fatal = !!e.fatal),
          (this._ignoreBOM = !!e.ignoreBOM),
          Object.defineProperty(this, "encoding", { value: "utf-8" }),
          Object.defineProperty(this, "fatal", { value: this._fatal }),
          Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM })
      }
      function h(t, e) {
        if (!(this instanceof h)) return new h(t, e)
        if ((t = void 0 !== t ? (t + "").toLowerCase() : c) !== c)
          throw Error("Encoding not supported. Only utf-8 is supported")
        ;(e = i(e)),
          (this._streaming = !1),
          (this._encoder = null),
          (this._options = { fatal: !!e.fatal }),
          Object.defineProperty(this, "encoding", { value: "utf-8" })
      }
      function d(t) {
        var e = t.fatal,
          r = 0,
          i = 0,
          o = 0,
          c = 128,
          l = 191
        this.handler = function(t, h) {
          if (h === s && 0 !== o) return (o = 0), u(e)
          if (h === s) return a
          if (0 === o) {
            if (n(h, 0, 127)) return h
            if (n(h, 194, 223)) (o = 1), (r = h - 192)
            else if (n(h, 224, 239))
              224 === h && (c = 160),
                237 === h && (l = 159),
                (o = 2),
                (r = h - 224)
            else {
              if (!n(h, 240, 244)) return u(e)
              240 === h && (c = 144),
                244 === h && (l = 143),
                (o = 3),
                (r = h - 240)
            }
            return (r <<= 6 * o), null
          }
          if (!n(h, c, l))
            return (r = o = i = 0), (c = 128), (l = 191), t.prepend(h), u(e)
          if (
            ((c = 128),
            (l = 191),
            (r += (h - 128) << (6 * (o - (i += 1)))),
            i !== o)
          )
            return null
          var d = r
          return (r = o = i = 0), d
        }
      }
      function f(t) {
        t.fatal
        this.handler = function(t, e) {
          if (e === s) return a
          if (n(e, 0, 127)) return e
          var r, i
          n(e, 128, 2047)
            ? ((r = 1), (i = 192))
            : n(e, 2048, 65535)
            ? ((r = 2), (i = 224))
            : n(e, 65536, 1114111) && ((r = 3), (i = 240))
          for (var o = [(e >> (6 * r)) + i]; r > 0; ) {
            var u = e >> (6 * (r - 1))
            o.push(128 | (63 & u)), (r -= 1)
          }
          return o
        }
      }
      ;(l.prototype = {
        decode: function(t, e) {
          var r
          ;(r =
            "object" == typeof t && t instanceof ArrayBuffer
              ? new Uint8Array(t)
              : "object" == typeof t &&
                "buffer" in t &&
                t.buffer instanceof ArrayBuffer
              ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
              : new Uint8Array(0)),
            (e = i(e)),
            this._streaming ||
              ((this._decoder = new d({ fatal: this._fatal })),
              (this._BOMseen = !1)),
            (this._streaming = !!e.stream)
          for (
            var n, s = new o(r), u = [];
            !s.endOfStream() && (n = this._decoder.handler(s, s.read())) !== a;

          )
            null !== n && (Array.isArray(n) ? u.push.apply(u, n) : u.push(n))
          if (!this._streaming) {
            do {
              if ((n = this._decoder.handler(s, s.read())) === a) break
              null !== n && (Array.isArray(n) ? u.push.apply(u, n) : u.push(n))
            } while (!s.endOfStream())
            this._decoder = null
          }
          return (
            u.length &&
              (-1 === ["utf-8"].indexOf(this.encoding) ||
                this._ignoreBOM ||
                this._BOMseen ||
                (65279 === u[0]
                  ? ((this._BOMseen = !0), u.shift())
                  : (this._BOMseen = !0))),
            (function(t) {
              for (var e = "", r = 0; r < t.length; ++r) {
                var n = t[r]
                e +=
                  n <= 65535
                    ? String.fromCharCode(n)
                    : String.fromCharCode(
                        55296 + ((n -= 65536) >> 10),
                        56320 + (1023 & n)
                      )
              }
              return e
            })(u)
          )
        },
      }),
        (h.prototype = {
          encode: function(t, e) {
            ;(t = t ? t + "" : ""),
              (e = i(e)),
              this._streaming || (this._encoder = new f(this._options)),
              (this._streaming = !!e.stream)
            for (
              var r,
                n = [],
                s = new o(
                  (function(t) {
                    for (
                      var e = t + "", r = e.length, n = 0, i = [];
                      n < r;

                    ) {
                      var s = e.charCodeAt(n)
                      if (s < 55296 || s > 57343) i.push(s)
                      else if (56320 <= s && s <= 57343) i.push(65533)
                      else if (55296 <= s && s <= 56319)
                        if (n === r - 1) i.push(65533)
                        else {
                          var o = t.charCodeAt(n + 1)
                          if (56320 <= o && o <= 57343) {
                            var a = 1023 & s,
                              u = 1023 & o
                            i.push(65536 + (a << 10) + u), (n += 1)
                          } else i.push(65533)
                        }
                      n += 1
                    }
                    return i
                  })(t)
                );
              !s.endOfStream() &&
              (r = this._encoder.handler(s, s.read())) !== a;

            )
              Array.isArray(r) ? n.push.apply(n, r) : n.push(r)
            if (!this._streaming) {
              for (; (r = this._encoder.handler(s, s.read())) !== a; )
                Array.isArray(r) ? n.push.apply(n, r) : n.push(r)
              this._encoder = null
            }
            return new Uint8Array(n)
          },
        })
    },
    function(t, e, r) {
      "use strict"
      !(function(t) {
        var n = r(9),
          i = r(10),
          s = r(11)
        function o() {
          return u.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
        }
        function a(t, e) {
          if (o() < e) throw new RangeError("Invalid typed array length")
          return (
            u.TYPED_ARRAY_SUPPORT
              ? ((t = new Uint8Array(e)).__proto__ = u.prototype)
              : (null === t && (t = new u(e)), (t.length = e)),
            t
          )
        }
        function u(t, e, r) {
          if (!(u.TYPED_ARRAY_SUPPORT || this instanceof u))
            return new u(t, e, r)
          if ("number" == typeof t) {
            if ("string" == typeof e)
              throw Error(
                "If encoding is specified then the first argument must be a string"
              )
            return h(this, t)
          }
          return c(this, t, e, r)
        }
        function c(t, e, r, n) {
          if ("number" == typeof e)
            throw new TypeError('"value" argument must not be a number')
          return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer
            ? (function(t, e, r, n) {
                if ((e.byteLength, r < 0 || e.byteLength < r))
                  throw new RangeError("'offset' is out of bounds")
                if (e.byteLength < r + (n || 0))
                  throw new RangeError("'length' is out of bounds")
                e =
                  void 0 === r && void 0 === n
                    ? new Uint8Array(e)
                    : void 0 === n
                    ? new Uint8Array(e, r)
                    : new Uint8Array(e, r, n)
                u.TYPED_ARRAY_SUPPORT
                  ? ((t = e).__proto__ = u.prototype)
                  : (t = d(t, e))
                return t
              })(t, e, r, n)
            : "string" == typeof e
            ? (function(t, e, r) {
                ;("string" == typeof r && "" !== r) || (r = "utf8")
                if (!u.isEncoding(r))
                  throw new TypeError(
                    '"encoding" must be a valid string encoding'
                  )
                var n = 0 | p(e, r),
                  i = (t = a(t, n)).write(e, r)
                i !== n && (t = t.slice(0, i))
                return t
              })(t, e, r)
            : (function(t, e) {
                if (u.isBuffer(e)) {
                  var r = 0 | f(e.length)
                  return 0 === (t = a(t, r)).length
                    ? t
                    : (e.copy(t, 0, 0, r), t)
                }
                if (e) {
                  if (
                    ("undefined" != typeof ArrayBuffer &&
                      e.buffer instanceof ArrayBuffer) ||
                    "length" in e
                  )
                    return "number" != typeof e.length || (n = e.length) != n
                      ? a(t, 0)
                      : d(t, e)
                  if ("Buffer" === e.type && s(e.data)) return d(t, e.data)
                }
                var n
                throw new TypeError(
                  "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
                )
              })(t, e)
        }
        function l(t) {
          if ("number" != typeof t)
            throw new TypeError('"size" argument must be a number')
          if (t < 0)
            throw new RangeError('"size" argument must not be negative')
        }
        function h(t, e) {
          if ((l(e), (t = a(t, e < 0 ? 0 : 0 | f(e))), !u.TYPED_ARRAY_SUPPORT))
            for (var r = 0; r < e; ++r) t[r] = 0
          return t
        }
        function d(t, e) {
          var r = e.length < 0 ? 0 : 0 | f(e.length)
          t = a(t, r)
          for (var n = 0; n < r; n += 1) t[n] = 255 & e[n]
          return t
        }
        function f(t) {
          if (t >= o())
            throw new RangeError(
              "Attempt to allocate Buffer larger than maximum size: 0x" +
                o().toString(16) +
                " bytes"
            )
          return 0 | t
        }
        function p(t, e) {
          if (u.isBuffer(t)) return t.length
          if (
            "undefined" != typeof ArrayBuffer &&
            "function" == typeof ArrayBuffer.isView &&
            (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
          )
            return t.byteLength
          "string" != typeof t && (t = "" + t)
          var r = t.length
          if (0 === r) return 0
          for (var n = !1; ; )
            switch (e) {
              case "ascii":
              case "latin1":
              case "binary":
                return r
              case "utf8":
              case "utf-8":
              case void 0:
                return k(t).length
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * r
              case "hex":
                return r >>> 1
              case "base64":
                return z(t).length
              default:
                if (n) return k(t).length
                ;(e = ("" + e).toLowerCase()), (n = !0)
            }
        }
        function y(t, e, r) {
          var n = t[e]
          ;(t[e] = t[r]), (t[r] = n)
        }
        function b(t, e, r, n, i) {
          if (0 === t.length) return -1
          if (
            ("string" == typeof r
              ? ((n = r), (r = 0))
              : r > 2147483647
              ? (r = 2147483647)
              : r < -2147483648 && (r = -2147483648),
            isNaN((r = +r)) && (r = i ? 0 : t.length - 1),
            r < 0 && (r = t.length + r),
            r >= t.length)
          ) {
            if (i) return -1
            r = t.length - 1
          } else if (r < 0) {
            if (!i) return -1
            r = 0
          }
          if (("string" == typeof e && (e = u.from(e, n)), u.isBuffer(e)))
            return 0 === e.length ? -1 : g(t, e, r, n, i)
          if ("number" == typeof e)
            return (
              (e &= 255),
              u.TYPED_ARRAY_SUPPORT &&
              "function" == typeof Uint8Array.prototype.indexOf
                ? i
                  ? Uint8Array.prototype.indexOf.call(t, e, r)
                  : Uint8Array.prototype.lastIndexOf.call(t, e, r)
                : g(t, [e], r, n, i)
            )
          throw new TypeError("val must be string, number or Buffer")
        }
        function g(t, e, r, n, i) {
          var s,
            o = 1,
            a = t.length,
            u = e.length
          if (
            void 0 !== n &&
            ("ucs2" === (n = (n + "").toLowerCase()) ||
              "ucs-2" === n ||
              "utf16le" === n ||
              "utf-16le" === n)
          ) {
            if (t.length < 2 || e.length < 2) return -1
            ;(o = 2), (a /= 2), (u /= 2), (r /= 2)
          }
          function c(t, e) {
            return 1 === o ? t[e] : t.readUInt16BE(e * o)
          }
          if (i) {
            var l = -1
            for (s = r; s < a; s++)
              if (c(t, s) === c(e, -1 === l ? 0 : s - l)) {
                if ((-1 === l && (l = s), s - l + 1 === u)) return l * o
              } else -1 !== l && (s -= s - l), (l = -1)
          } else
            for (r + u > a && (r = a - u), s = r; s >= 0; s--) {
              for (var h = !0, d = 0; d < u; d++)
                if (c(t, s + d) !== c(e, d)) {
                  h = !1
                  break
                }
              if (h) return s
            }
          return -1
        }
        function _(t, e, r, n) {
          r = +r || 0
          var i = t.length - r
          n ? (n = +n) > i && (n = i) : (n = i)
          var s = e.length
          if (s % 2 != 0) throw new TypeError("Invalid hex string")
          n > s / 2 && (n = s / 2)
          for (var o = 0; o < n; ++o) {
            var a = parseInt(e.substr(2 * o, 2), 16)
            if (isNaN(a)) return o
            t[r + o] = a
          }
          return o
        }
        function m(t, e, r, n) {
          return P(k(e, t.length - r), t, r, n)
        }
        function w(t, e, r, n) {
          return P(
            (function(t) {
              for (var e = [], r = 0; r < t.length; ++r)
                e.push(255 & t.charCodeAt(r))
              return e
            })(e),
            t,
            r,
            n
          )
        }
        function v(t, e, r, n) {
          return w(t, e, r, n)
        }
        function I(t, e, r, n) {
          return P(z(e), t, r, n)
        }
        function A(t, e, r, n) {
          return P(
            (function(t, e) {
              for (
                var r, n, i, s = [], o = 0;
                o < t.length && !((e -= 2) < 0);
                ++o
              )
                (r = t.charCodeAt(o)),
                  (n = r >> 8),
                  (i = r % 256),
                  s.push(i),
                  s.push(n)
              return s
            })(e, t.length - r),
            t,
            r,
            n
          )
        }
        function B(t, e, r) {
          return 0 === e && r === t.length
            ? n.fromByteArray(t)
            : n.fromByteArray(t.slice(e, r))
        }
        function S(t, e, r) {
          r = Math.min(t.length, r)
          for (var n = [], i = e; i < r; ) {
            var s,
              o,
              a,
              u,
              c = t[i],
              l = null,
              h = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1
            if (i + h <= r)
              switch (h) {
                case 1:
                  c < 128 && (l = c)
                  break
                case 2:
                  128 == (192 & (s = t[i + 1])) &&
                    (u = ((31 & c) << 6) | (63 & s)) > 127 &&
                    (l = u)
                  break
                case 3:
                  ;(s = t[i + 1]),
                    (o = t[i + 2]),
                    128 == (192 & s) &&
                      128 == (192 & o) &&
                      (u = ((15 & c) << 12) | ((63 & s) << 6) | (63 & o)) >
                        2047 &&
                      (u < 55296 || u > 57343) &&
                      (l = u)
                  break
                case 4:
                  ;(s = t[i + 1]),
                    (o = t[i + 2]),
                    (a = t[i + 3]),
                    128 == (192 & s) &&
                      128 == (192 & o) &&
                      128 == (192 & a) &&
                      (u =
                        ((15 & c) << 18) |
                        ((63 & s) << 12) |
                        ((63 & o) << 6) |
                        (63 & a)) > 65535 &&
                      u < 1114112 &&
                      (l = u)
              }
            null === l
              ? ((l = 65533), (h = 1))
              : l > 65535 &&
                ((l -= 65536),
                n.push(((l >>> 10) & 1023) | 55296),
                (l = 56320 | (1023 & l))),
              n.push(l),
              (i += h)
          }
          return (function(t) {
            var e = t.length
            if (e <= T) return String.fromCharCode.apply(String, t)
            var r = "",
              n = 0
            for (; n < e; )
              r += String.fromCharCode.apply(String, t.slice(n, (n += T)))
            return r
          })(n)
        }
        ;(e.Buffer = u),
          (e.SlowBuffer = function(t) {
            ;+t != t && (t = 0)
            return u.alloc(+t)
          }),
          (e.INSPECT_MAX_BYTES = 50),
          (u.TYPED_ARRAY_SUPPORT =
            void 0 !== t.TYPED_ARRAY_SUPPORT
              ? t.TYPED_ARRAY_SUPPORT
              : (function() {
                  try {
                    var t = new Uint8Array(1)
                    return (
                      (t.__proto__ = {
                        __proto__: Uint8Array.prototype,
                        foo: function() {
                          return 42
                        },
                      }),
                      42 === t.foo() &&
                        "function" == typeof t.subarray &&
                        0 === t.subarray(1, 1).byteLength
                    )
                  } catch (e) {
                    return !1
                  }
                })()),
          (e.kMaxLength = o()),
          (u.poolSize = 8192),
          (u._augment = function(t) {
            return (t.__proto__ = u.prototype), t
          }),
          (u.from = function(t, e, r) {
            return c(null, t, e, r)
          }),
          u.TYPED_ARRAY_SUPPORT &&
            ((u.prototype.__proto__ = Uint8Array.prototype),
            (u.__proto__ = Uint8Array),
            "undefined" != typeof Symbol &&
              Symbol.species &&
              u[Symbol.species] === u &&
              Object.defineProperty(u, Symbol.species, {
                value: null,
                configurable: !0,
              })),
          (u.alloc = function(t, e, r) {
            return (function(t, e, r, n) {
              return (
                l(e),
                e <= 0
                  ? a(t, e)
                  : void 0 !== r
                  ? "string" == typeof n
                    ? a(t, e).fill(r, n)
                    : a(t, e).fill(r)
                  : a(t, e)
              )
            })(null, t, e, r)
          }),
          (u.allocUnsafe = function(t) {
            return h(null, t)
          }),
          (u.allocUnsafeSlow = function(t) {
            return h(null, t)
          }),
          (u.isBuffer = function(t) {
            return !(null == t || !t._isBuffer)
          }),
          (u.compare = function(t, e) {
            if (!u.isBuffer(t) || !u.isBuffer(e))
              throw new TypeError("Arguments must be Buffers")
            if (t === e) return 0
            for (
              var r = t.length, n = e.length, i = 0, s = Math.min(r, n);
              i < s;
              ++i
            )
              if (t[i] !== e[i]) {
                ;(r = t[i]), (n = e[i])
                break
              }
            return r < n ? -1 : n < r ? 1 : 0
          }),
          (u.isEncoding = function(t) {
            switch ((t + "").toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0
              default:
                return !1
            }
          }),
          (u.concat = function(t, e) {
            if (!s(t))
              throw new TypeError(
                '"list" argument must be an Array of Buffers'
              )
            if (0 === t.length) return u.alloc(0)
            var r
            if (void 0 === e)
              for (e = 0, r = 0; r < t.length; ++r) e += t[r].length
            var n = u.allocUnsafe(e),
              i = 0
            for (r = 0; r < t.length; ++r) {
              var o = t[r]
              if (!u.isBuffer(o))
                throw new TypeError(
                  '"list" argument must be an Array of Buffers'
                )
              o.copy(n, i), (i += o.length)
            }
            return n
          }),
          (u.byteLength = p),
          (u.prototype._isBuffer = !0),
          (u.prototype.swap16 = function() {
            var t = this.length
            if (t % 2 != 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits")
            for (var e = 0; e < t; e += 2) y(this, e, e + 1)
            return this
          }),
          (u.prototype.swap32 = function() {
            var t = this.length
            if (t % 4 != 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits")
            for (var e = 0; e < t; e += 4)
              y(this, e, e + 3), y(this, e + 1, e + 2)
            return this
          }),
          (u.prototype.swap64 = function() {
            var t = this.length
            if (t % 8 != 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits")
            for (var e = 0; e < t; e += 8)
              y(this, e, e + 7),
                y(this, e + 1, e + 6),
                y(this, e + 2, e + 5),
                y(this, e + 3, e + 4)
            return this
          }),
          (u.prototype.toString = function() {
            var t = 0 | this.length
            return 0 === t
              ? ""
              : 0 === arguments.length
              ? S(this, 0, t)
              : function(t, e, r) {
                  var n = !1
                  if (((void 0 === e || e < 0) && (e = 0), e > this.length))
                    return ""
                  if (
                    ((void 0 === r || r > this.length) && (r = this.length),
                    r <= 0)
                  )
                    return ""
                  if ((r >>>= 0) <= (e >>>= 0)) return ""
                  for (t || (t = "utf8"); ; )
                    switch (t) {
                      case "hex":
                        return U(this, e, r)
                      case "utf8":
                      case "utf-8":
                        return S(this, e, r)
                      case "ascii":
                        return O(this, e, r)
                      case "latin1":
                      case "binary":
                        return D(this, e, r)
                      case "base64":
                        return B(this, e, r)
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return L(this, e, r)
                      default:
                        if (n) throw new TypeError("Unknown encoding: " + t)
                        ;(t = (t + "").toLowerCase()), (n = !0)
                    }
                }.apply(this, arguments)
          }),
          (u.prototype.equals = function(t) {
            if (!u.isBuffer(t))
              throw new TypeError("Argument must be a Buffer")
            return this === t || 0 === u.compare(this, t)
          }),
          (u.prototype.inspect = function() {
            var t = "",
              r = e.INSPECT_MAX_BYTES
            return (
              this.length > 0 &&
                ((t = this.toString("hex", 0, r)
                  .match(/.{2}/g)
                  .join(" ")),
                this.length > r && (t += " ... ")),
              "<Buffer " + t + ">"
            )
          }),
          (u.prototype.compare = function(t, e, r, n, i) {
            if (!u.isBuffer(t))
              throw new TypeError("Argument must be a Buffer")
            if (
              (void 0 === e && (e = 0),
              void 0 === r && (r = t ? t.length : 0),
              void 0 === n && (n = 0),
              void 0 === i && (i = this.length),
              e < 0 || r > t.length || n < 0 || i > this.length)
            )
              throw new RangeError("out of range index")
            if (n >= i && e >= r) return 0
            if (n >= i) return -1
            if (e >= r) return 1
            if (this === t) return 0
            for (
              var s = (i >>>= 0) - (n >>>= 0),
                o = (r >>>= 0) - (e >>>= 0),
                a = Math.min(s, o),
                c = this.slice(n, i),
                l = t.slice(e, r),
                h = 0;
              h < a;
              ++h
            )
              if (c[h] !== l[h]) {
                ;(s = c[h]), (o = l[h])
                break
              }
            return s < o ? -1 : o < s ? 1 : 0
          }),
          (u.prototype.includes = function(t, e, r) {
            return -1 !== this.indexOf(t, e, r)
          }),
          (u.prototype.indexOf = function(t, e, r) {
            return b(this, t, e, r, !0)
          }),
          (u.prototype.lastIndexOf = function(t, e, r) {
            return b(this, t, e, r, !1)
          }),
          (u.prototype.write = function(t, e, r, n) {
            if (void 0 === e) (n = "utf8"), (r = this.length), (e = 0)
            else if (void 0 === r && "string" == typeof e)
              (n = e), (r = this.length), (e = 0)
            else {
              if (!isFinite(e))
                throw Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                )
              ;(e |= 0),
                isFinite(r)
                  ? ((r |= 0), void 0 === n && (n = "utf8"))
                  : ((n = r), (r = void 0))
            }
            var i = this.length - e
            if (
              ((void 0 === r || r > i) && (r = i),
              (t.length > 0 && (r < 0 || e < 0)) || e > this.length)
            )
              throw new RangeError("Attempt to write outside buffer bounds")
            n || (n = "utf8")
            for (var s = !1; ; )
              switch (n) {
                case "hex":
                  return _(this, t, e, r)
                case "utf8":
                case "utf-8":
                  return m(this, t, e, r)
                case "ascii":
                  return w(this, t, e, r)
                case "latin1":
                case "binary":
                  return v(this, t, e, r)
                case "base64":
                  return I(this, t, e, r)
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return A(this, t, e, r)
                default:
                  if (s) throw new TypeError("Unknown encoding: " + n)
                  ;(n = ("" + n).toLowerCase()), (s = !0)
              }
          }),
          (u.prototype.toJSON = function() {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0),
            }
          })
        var T = 4096
        function O(t, e, r) {
          var n = ""
          r = Math.min(t.length, r)
          for (var i = e; i < r; ++i) n += String.fromCharCode(127 & t[i])
          return n
        }
        function D(t, e, r) {
          var n = ""
          r = Math.min(t.length, r)
          for (var i = e; i < r; ++i) n += String.fromCharCode(t[i])
          return n
        }
        function U(t, e, r) {
          var n = t.length
          ;(!e || e < 0) && (e = 0), (!r || r < 0 || r > n) && (r = n)
          for (var i = "", s = e; s < r; ++s) i += j(t[s])
          return i
        }
        function L(t, e, r) {
          for (var n = t.slice(e, r), i = "", s = 0; s < n.length; s += 2)
            i += String.fromCharCode(n[s] + 256 * n[s + 1])
          return i
        }
        function F(t, e, r) {
          if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint")
          if (t + e > r)
            throw new RangeError("Trying to access beyond buffer length")
        }
        function x(t, e, r, n, i, s) {
          if (!u.isBuffer(t))
            throw new TypeError('"buffer" argument must be a Buffer instance')
          if (e > i || e < s)
            throw new RangeError('"value" argument is out of bounds')
          if (r + n > t.length) throw new RangeError("Index out of range")
        }
        function M(t, e, r, n) {
          e < 0 && (e = 65535 + e + 1)
          for (var i = 0, s = Math.min(t.length - r, 2); i < s; ++i)
            t[r + i] =
              (e & (255 << (8 * (n ? i : 1 - i)))) >>> (8 * (n ? i : 1 - i))
        }
        function E(t, e, r, n) {
          e < 0 && (e = 4294967295 + e + 1)
          for (var i = 0, s = Math.min(t.length - r, 4); i < s; ++i)
            t[r + i] = (e >>> (8 * (n ? i : 3 - i))) & 255
        }
        function N(t, e, r, n, i, s) {
          if (r + n > t.length) throw new RangeError("Index out of range")
          if (r < 0) throw new RangeError("Index out of range")
        }
        function V(t, e, r, n, s) {
          return s || N(t, 0, r, 4), i.write(t, e, r, n, 23, 4), r + 4
        }
        function C(t, e, r, n, s) {
          return s || N(t, 0, r, 8), i.write(t, e, r, n, 52, 8), r + 8
        }
        ;(u.prototype.slice = function(t, e) {
          var r,
            n = this.length
          if (
            ((t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
            (e = void 0 === e ? n : ~~e) < 0
              ? (e += n) < 0 && (e = 0)
              : e > n && (e = n),
            e < t && (e = t),
            u.TYPED_ARRAY_SUPPORT)
          )
            (r = this.subarray(t, e)).__proto__ = u.prototype
          else {
            var i = e - t
            r = new u(i, void 0)
            for (var s = 0; s < i; ++s) r[s] = this[s + t]
          }
          return r
        }),
          (u.prototype.readUIntLE = function(t, e, r) {
            ;(t |= 0), (e |= 0), r || F(t, e, this.length)
            for (var n = this[t], i = 1, s = 0; ++s < e && (i *= 256); )
              n += this[t + s] * i
            return n
          }),
          (u.prototype.readUIntBE = function(t, e, r) {
            ;(t |= 0), (e |= 0), r || F(t, e, this.length)
            for (var n = this[t + --e], i = 1; e > 0 && (i *= 256); )
              n += this[t + --e] * i
            return n
          }),
          (u.prototype.readUInt8 = function(t, e) {
            return e || F(t, 1, this.length), this[t]
          }),
          (u.prototype.readUInt16LE = function(t, e) {
            return e || F(t, 2, this.length), this[t] | (this[t + 1] << 8)
          }),
          (u.prototype.readUInt16BE = function(t, e) {
            return e || F(t, 2, this.length), (this[t] << 8) | this[t + 1]
          }),
          (u.prototype.readUInt32LE = function(t, e) {
            return (
              e || F(t, 4, this.length),
              (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
                16777216 * this[t + 3]
            )
          }),
          (u.prototype.readUInt32BE = function(t, e) {
            return (
              e || F(t, 4, this.length),
              16777216 * this[t] +
                ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
            )
          }),
          (u.prototype.readIntLE = function(t, e, r) {
            ;(t |= 0), (e |= 0), r || F(t, e, this.length)
            for (var n = this[t], i = 1, s = 0; ++s < e && (i *= 256); )
              n += this[t + s] * i
            return n >= (i *= 128) && (n -= Math.pow(2, 8 * e)), n
          }),
          (u.prototype.readIntBE = function(t, e, r) {
            ;(t |= 0), (e |= 0), r || F(t, e, this.length)
            for (var n = e, i = 1, s = this[t + --n]; n > 0 && (i *= 256); )
              s += this[t + --n] * i
            return s >= (i *= 128) && (s -= Math.pow(2, 8 * e)), s
          }),
          (u.prototype.readInt8 = function(t, e) {
            return (
              e || F(t, 1, this.length),
              128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
            )
          }),
          (u.prototype.readInt16LE = function(t, e) {
            e || F(t, 2, this.length)
            var r = this[t] | (this[t + 1] << 8)
            return 32768 & r ? 4294901760 | r : r
          }),
          (u.prototype.readInt16BE = function(t, e) {
            e || F(t, 2, this.length)
            var r = this[t + 1] | (this[t] << 8)
            return 32768 & r ? 4294901760 | r : r
          }),
          (u.prototype.readInt32LE = function(t, e) {
            return (
              e || F(t, 4, this.length),
              this[t] |
                (this[t + 1] << 8) |
                (this[t + 2] << 16) |
                (this[t + 3] << 24)
            )
          }),
          (u.prototype.readInt32BE = function(t, e) {
            return (
              e || F(t, 4, this.length),
              (this[t] << 24) |
                (this[t + 1] << 16) |
                (this[t + 2] << 8) |
                this[t + 3]
            )
          }),
          (u.prototype.readFloatLE = function(t, e) {
            return e || F(t, 4, this.length), i.read(this, t, !0, 23, 4)
          }),
          (u.prototype.readFloatBE = function(t, e) {
            return e || F(t, 4, this.length), i.read(this, t, !1, 23, 4)
          }),
          (u.prototype.readDoubleLE = function(t, e) {
            return e || F(t, 8, this.length), i.read(this, t, !0, 52, 8)
          }),
          (u.prototype.readDoubleBE = function(t, e) {
            return e || F(t, 8, this.length), i.read(this, t, !1, 52, 8)
          }),
          (u.prototype.writeUIntLE = function(t, e, r, n) {
            ;((t = +t), (e |= 0), (r |= 0), n) ||
              x(this, t, e, r, Math.pow(2, 8 * r) - 1, 0)
            var i = 1,
              s = 0
            for (this[e] = 255 & t; ++s < r && (i *= 256); )
              this[e + s] = (t / i) & 255
            return e + r
          }),
          (u.prototype.writeUIntBE = function(t, e, r, n) {
            ;((t = +t), (e |= 0), (r |= 0), n) ||
              x(this, t, e, r, Math.pow(2, 8 * r) - 1, 0)
            var i = r - 1,
              s = 1
            for (this[e + i] = 255 & t; --i >= 0 && (s *= 256); )
              this[e + i] = (t / s) & 255
            return e + r
          }),
          (u.prototype.writeUInt8 = function(t, e, r) {
            return (
              (t = +t),
              (e |= 0),
              r || x(this, t, e, 1, 255, 0),
              u.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
              (this[e] = 255 & t),
              e + 1
            )
          }),
          (u.prototype.writeUInt16LE = function(t, e, r) {
            return (
              (t = +t),
              (e |= 0),
              r || x(this, t, e, 2, 65535, 0),
              u.TYPED_ARRAY_SUPPORT
                ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8))
                : M(this, t, e, !0),
              e + 2
            )
          }),
          (u.prototype.writeUInt16BE = function(t, e, r) {
            return (
              (t = +t),
              (e |= 0),
              r || x(this, t, e, 2, 65535, 0),
              u.TYPED_ARRAY_SUPPORT
                ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t))
                : M(this, t, e, !1),
              e + 2
            )
          }),
          (u.prototype.writeUInt32LE = function(t, e, r) {
            return (
              (t = +t),
              (e |= 0),
              r || x(this, t, e, 4, 4294967295, 0),
              u.TYPED_ARRAY_SUPPORT
                ? ((this[e + 3] = t >>> 24),
                  (this[e + 2] = t >>> 16),
                  (this[e + 1] = t >>> 8),
                  (this[e] = 255 & t))
                : E(this, t, e, !0),
              e + 4
            )
          }),
          (u.prototype.writeUInt32BE = function(t, e, r) {
            return (
              (t = +t),
              (e |= 0),
              r || x(this, t, e, 4, 4294967295, 0),
              u.TYPED_ARRAY_SUPPORT
                ? ((this[e] = t >>> 24),
                  (this[e + 1] = t >>> 16),
                  (this[e + 2] = t >>> 8),
                  (this[e + 3] = 255 & t))
                : E(this, t, e, !1),
              e + 4
            )
          }),
          (u.prototype.writeIntLE = function(t, e, r, n) {
            if (((t = +t), (e |= 0), !n)) {
              var i = Math.pow(2, 8 * r - 1)
              x(this, t, e, r, i - 1, -i)
            }
            var s = 0,
              o = 1,
              a = 0
            for (this[e] = 255 & t; ++s < r && (o *= 256); )
              t < 0 && 0 === a && 0 !== this[e + s - 1] && (a = 1),
                (this[e + s] = (((t / o) >> 0) - a) & 255)
            return e + r
          }),
          (u.prototype.writeIntBE = function(t, e, r, n) {
            if (((t = +t), (e |= 0), !n)) {
              var i = Math.pow(2, 8 * r - 1)
              x(this, t, e, r, i - 1, -i)
            }
            var s = r - 1,
              o = 1,
              a = 0
            for (this[e + s] = 255 & t; --s >= 0 && (o *= 256); )
              t < 0 && 0 === a && 0 !== this[e + s + 1] && (a = 1),
                (this[e + s] = (((t / o) >> 0) - a) & 255)
            return e + r
          }),
          (u.prototype.writeInt8 = function(t, e, r) {
            return (
              (t = +t),
              (e |= 0),
              r || x(this, t, e, 1, 127, -128),
              u.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
              t < 0 && (t = 255 + t + 1),
              (this[e] = 255 & t),
              e + 1
            )
          }),
          (u.prototype.writeInt16LE = function(t, e, r) {
            return (
              (t = +t),
              (e |= 0),
              r || x(this, t, e, 2, 32767, -32768),
              u.TYPED_ARRAY_SUPPORT
                ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8))
                : M(this, t, e, !0),
              e + 2
            )
          }),
          (u.prototype.writeInt16BE = function(t, e, r) {
            return (
              (t = +t),
              (e |= 0),
              r || x(this, t, e, 2, 32767, -32768),
              u.TYPED_ARRAY_SUPPORT
                ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t))
                : M(this, t, e, !1),
              e + 2
            )
          }),
          (u.prototype.writeInt32LE = function(t, e, r) {
            return (
              (t = +t),
              (e |= 0),
              r || x(this, t, e, 4, 2147483647, -2147483648),
              u.TYPED_ARRAY_SUPPORT
                ? ((this[e] = 255 & t),
                  (this[e + 1] = t >>> 8),
                  (this[e + 2] = t >>> 16),
                  (this[e + 3] = t >>> 24))
                : E(this, t, e, !0),
              e + 4
            )
          }),
          (u.prototype.writeInt32BE = function(t, e, r) {
            return (
              (t = +t),
              (e |= 0),
              r || x(this, t, e, 4, 2147483647, -2147483648),
              t < 0 && (t = 4294967295 + t + 1),
              u.TYPED_ARRAY_SUPPORT
                ? ((this[e] = t >>> 24),
                  (this[e + 1] = t >>> 16),
                  (this[e + 2] = t >>> 8),
                  (this[e + 3] = 255 & t))
                : E(this, t, e, !1),
              e + 4
            )
          }),
          (u.prototype.writeFloatLE = function(t, e, r) {
            return V(this, t, e, !0, r)
          }),
          (u.prototype.writeFloatBE = function(t, e, r) {
            return V(this, t, e, !1, r)
          }),
          (u.prototype.writeDoubleLE = function(t, e, r) {
            return C(this, t, e, !0, r)
          }),
          (u.prototype.writeDoubleBE = function(t, e, r) {
            return C(this, t, e, !1, r)
          }),
          (u.prototype.copy = function(t, e, r, n) {
            if (
              (r || (r = 0),
              n || 0 === n || (n = this.length),
              e >= t.length && (e = t.length),
              e || (e = 0),
              n > 0 && n < r && (n = r),
              n === r)
            )
              return 0
            if (0 === t.length || 0 === this.length) return 0
            if (e < 0) throw new RangeError("targetStart out of bounds")
            if (r < 0 || r >= this.length)
              throw new RangeError("sourceStart out of bounds")
            if (n < 0) throw new RangeError("sourceEnd out of bounds")
            n > this.length && (n = this.length),
              t.length - e < n - r && (n = t.length - e + r)
            var i,
              s = n - r
            if (this === t && r < e && e < n)
              for (i = s - 1; i >= 0; --i) t[i + e] = this[i + r]
            else if (s < 1e3 || !u.TYPED_ARRAY_SUPPORT)
              for (i = 0; i < s; ++i) t[i + e] = this[i + r]
            else Uint8Array.prototype.set.call(t, this.subarray(r, r + s), e)
            return s
          }),
          (u.prototype.fill = function(t, e, r, n) {
            if ("string" == typeof t) {
              if (
                ("string" == typeof e
                  ? ((n = e), (e = 0), (r = this.length))
                  : "string" == typeof r && ((n = r), (r = this.length)),
                1 === t.length)
              ) {
                var i = t.charCodeAt(0)
                i < 256 && (t = i)
              }
              if (void 0 !== n && "string" != typeof n)
                throw new TypeError("encoding must be a string")
              if ("string" == typeof n && !u.isEncoding(n))
                throw new TypeError("Unknown encoding: " + n)
            } else "number" == typeof t && (t &= 255)
            if (e < 0 || this.length < e || this.length < r)
              throw new RangeError("Out of range index")
            if (r <= e) return this
            var s
            if (
              ((e >>>= 0),
              (r = void 0 === r ? this.length : r >>> 0),
              t || (t = 0),
              "number" == typeof t)
            )
              for (s = e; s < r; ++s) this[s] = t
            else {
              var o = u.isBuffer(t) ? t : k(new u(t, n).toString()),
                a = o.length
              for (s = 0; s < r - e; ++s) this[s + e] = o[s % a]
            }
            return this
          })
        var R = /[^+\/0-9A-Za-z-_]/g
        function j(t) {
          return t < 16 ? "0" + t.toString(16) : t.toString(16)
        }
        function k(t, e) {
          var r
          e = e || 1 / 0
          for (var n = t.length, i = null, s = [], o = 0; o < n; ++o) {
            if ((r = t.charCodeAt(o)) > 55295 && r < 57344) {
              if (!i) {
                if (r > 56319) {
                  ;(e -= 3) > -1 && s.push(239, 191, 189)
                  continue
                }
                if (o + 1 === n) {
                  ;(e -= 3) > -1 && s.push(239, 191, 189)
                  continue
                }
                i = r
                continue
              }
              if (r < 56320) {
                ;(e -= 3) > -1 && s.push(239, 191, 189), (i = r)
                continue
              }
              r = 65536 + (((i - 55296) << 10) | (r - 56320))
            } else i && (e -= 3) > -1 && s.push(239, 191, 189)
            if (((i = null), r < 128)) {
              if ((e -= 1) < 0) break
              s.push(r)
            } else if (r < 2048) {
              if ((e -= 2) < 0) break
              s.push((r >> 6) | 192, (63 & r) | 128)
            } else if (r < 65536) {
              if ((e -= 3) < 0) break
              s.push((r >> 12) | 224, ((r >> 6) & 63) | 128, (63 & r) | 128)
            } else {
              if (!(r < 1114112)) throw Error("Invalid code point")
              if ((e -= 4) < 0) break
              s.push(
                (r >> 18) | 240,
                ((r >> 12) & 63) | 128,
                ((r >> 6) & 63) | 128,
                (63 & r) | 128
              )
            }
          }
          return s
        }
        function z(t) {
          return n.toByteArray(
            (function(t) {
              if (
                (t = (function(t) {
                  return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
                })(t).replace(R, "")).length < 2
              )
                return ""
              for (; t.length % 4 != 0; ) t += "="
              return t
            })(t)
          )
        }
        function P(t, e, r, n) {
          for (var i = 0; i < n && !(i + r >= e.length || i >= t.length); ++i)
            e[i + r] = t[i]
          return i
        }
      })(r(8))
    },
    function(t, e) {
      var r
      r = (function() {
        return this
      })()
      try {
        r = r || Function("return this")()
      } catch (n) {
        "object" == typeof window && (r = window)
      }
      t.exports = r
    },
    function(t, e, r) {
      "use strict"
      ;(e.byteLength = function(t) {
        var e = u(t),
          r = e[0],
          n = e[1]
        return (3 * (r + n)) / 4 - n
      }),
        (e.toByteArray = function(t) {
          for (
            var e,
              r = u(t),
              n = r[0],
              o = r[1],
              a = new s(
                (function(t, e, r) {
                  return (3 * (e + r)) / 4 - r
                })(0, n, o)
              ),
              c = 0,
              l = o > 0 ? n - 4 : n,
              h = 0;
            h < l;
            h += 4
          )
            (e =
              (i[t.charCodeAt(h)] << 18) |
              (i[t.charCodeAt(h + 1)] << 12) |
              (i[t.charCodeAt(h + 2)] << 6) |
              i[t.charCodeAt(h + 3)]),
              (a[c++] = (e >> 16) & 255),
              (a[c++] = (e >> 8) & 255),
              (a[c++] = 255 & e)
          2 === o &&
            ((e = (i[t.charCodeAt(h)] << 2) | (i[t.charCodeAt(h + 1)] >> 4)),
            (a[c++] = 255 & e))
          1 === o &&
            ((e =
              (i[t.charCodeAt(h)] << 10) |
              (i[t.charCodeAt(h + 1)] << 4) |
              (i[t.charCodeAt(h + 2)] >> 2)),
            (a[c++] = (e >> 8) & 255),
            (a[c++] = 255 & e))
          return a
        }),
        (e.fromByteArray = function(t) {
          for (
            var e, r = t.length, i = r % 3, s = [], o = 0, a = r - i;
            o < a;
            o += 16383
          )
            s.push(c(t, o, o + 16383 > a ? a : o + 16383))
          1 === i
            ? ((e = t[r - 1]), s.push(n[e >> 2] + n[(e << 4) & 63] + "=="))
            : 2 === i &&
              ((e = (t[r - 2] << 8) + t[r - 1]),
              s.push(n[e >> 10] + n[(e >> 4) & 63] + n[(e << 2) & 63] + "="))
          return s.join("")
        })
      for (
        var n = [],
          i = [],
          s = "undefined" != typeof Uint8Array ? Uint8Array : Array,
          o =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          a = 0;
        a < 64;
        ++a
      )
        (n[a] = o[a]), (i[o.charCodeAt(a)] = a)
      function u(t) {
        var e = t.length
        if (e % 4 > 0)
          throw Error("Invalid string. Length must be a multiple of 4")
        var r = t.indexOf("=")
        return -1 === r && (r = e), [r, r === e ? 0 : 4 - (r % 4)]
      }
      function c(t, e, r) {
        for (var i, s, o = [], a = e; a < r; a += 3)
          (i =
            ((t[a] << 16) & 16711680) +
            ((t[a + 1] << 8) & 65280) +
            (255 & t[a + 2])),
            o.push(
              n[((s = i) >> 18) & 63] +
                n[(s >> 12) & 63] +
                n[(s >> 6) & 63] +
                n[63 & s]
            )
        return o.join("")
      }
      ;(i[45] = 62), (i[95] = 63)
    },
    function(t, e) {
      ;(e.read = function(t, e, r, n, i) {
        var s,
          o,
          a = 8 * i - n - 1,
          u = (1 << a) - 1,
          c = u >> 1,
          l = -7,
          h = r ? i - 1 : 0,
          d = r ? -1 : 1,
          f = t[e + h]
        for (
          h += d, s = f & ((1 << -l) - 1), f >>= -l, l += a;
          l > 0;
          s = 256 * s + t[e + h], h += d, l -= 8
        );
        for (
          o = s & ((1 << -l) - 1), s >>= -l, l += n;
          l > 0;
          o = 256 * o + t[e + h], h += d, l -= 8
        );
        if (0 === s) s = 1 - c
        else {
          if (s === u) return o ? NaN : (1 / 0) * (f ? -1 : 1)
          ;(o += Math.pow(2, n)), (s -= c)
        }
        return (f ? -1 : 1) * o * Math.pow(2, s - n)
      }),
        (e.write = function(t, e, r, n, i, s) {
          var o,
            a,
            u,
            c = 8 * s - i - 1,
            l = (1 << c) - 1,
            h = l >> 1,
            d = 23 === i ? 5.960464477539062e-8 : 0,
            f = n ? 0 : s - 1,
            p = n ? 1 : -1,
            y = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0
          for (
            isNaN((e = Math.abs(e))) || e === 1 / 0
              ? ((a = isNaN(e) ? 1 : 0), (o = l))
              : (e *
                  (u = Math.pow(
                    2,
                    -(o = Math.floor(Math.log(e) / Math.LN2))
                  )) <
                  1 && (o--, (u *= 2)),
                (e += o + h >= 1 ? d / u : d * Math.pow(2, 1 - h)) * u >= 2 &&
                  (o++, (u /= 2)),
                o + h >= l
                  ? ((a = 0), (o = l))
                  : o + h >= 1
                  ? ((a = (e * u - 1) * Math.pow(2, i)), (o += h))
                  : ((a = e * Math.pow(2, h - 1) * Math.pow(2, i)), (o = 0)));
            i >= 8;
            t[r + f] = 255 & a, f += p, a /= 256, i -= 8
          );
          for (
            o = (o << i) | a, c += i;
            c > 0;
            t[r + f] = 255 & o, f += p, o /= 256, c -= 8
          );
          t[r + f - p] |= 128 * y
        })
    },
    function(t, e) {
      var r = {}.toString
      t.exports =
        Array.isArray ||
        function(t) {
          return "[object Array]" == r.call(t)
        }
    },
    function(t, e, r) {
      "use strict"
      r.r(e)
      var n = {}
      r.r(n),
        r.d(n, "getBool", function() {
          return T
        }),
        r.d(n, "getBit", function() {
          return O
        }),
        r.d(n, "setBool", function() {
          return D
        }),
        r.d(n, "truncateBitmap", function() {
          return U
        }),
        r.d(n, "packBools", function() {
          return L
        }),
        r.d(n, "iterateBits", function() {
          return F
        }),
        r.d(n, "popcnt_bit_range", function() {
          return x
        }),
        r.d(n, "popcnt_array", function() {
          return M
        }),
        r.d(n, "popcnt_uint32", function() {
          return E
        })
      var i = {}
      r.r(i),
        r.d(i, "uint16ToFloat64", function() {
          return fe
        }),
        r.d(i, "float64ToUint16", function() {
          return pe
        })
      var s = {}
      r.r(s),
        r.d(s, "isArrowBigNumSymbol", function() {
          return me
        }),
        r.d(s, "bignumToString", function() {
          return Se
        }),
        r.d(s, "bignumToBigInt", function() {
          return Te
        }),
        r.d(s, "BN", function() {
          return De
        })
      var o = {}
      r.r(o),
        r.d(o, "clampIndex", function() {
          return dr
        }),
        r.d(o, "clampRange", function() {
          return pr
        }),
        r.d(o, "createElementComparator", function() {
          return gr
        })
      var a = {}
      r.r(a),
        r.d(a, "BaseInt64", function() {
          return Cn
        }),
        r.d(a, "Uint64", function() {
          return Rn
        }),
        r.d(a, "Int64", function() {
          return jn
        }),
        r.d(a, "Int128", function() {
          return kn
        })
      var u = {}
      r.r(u),
        r.d(u, "Value", function() {
          return Aa
        }),
        r.d(u, "Literal", function() {
          return Ba
        }),
        r.d(u, "Col", function() {
          return Sa
        }),
        r.d(u, "Predicate", function() {
          return Ta
        }),
        r.d(u, "ComparisonPredicate", function() {
          return Oa
        }),
        r.d(u, "CombinationPredicate", function() {
          return Da
        }),
        r.d(u, "And", function() {
          return Ua
        }),
        r.d(u, "Or", function() {
          return La
        }),
        r.d(u, "Equals", function() {
          return Fa
        }),
        r.d(u, "LTeq", function() {
          return xa
        }),
        r.d(u, "GTeq", function() {
          return Ma
        }),
        r.d(u, "Not", function() {
          return Ea
        }),
        r.d(u, "CustomPredicate", function() {
          return Na
        }),
        r.d(u, "lit", function() {
          return Va
        }),
        r.d(u, "col", function() {
          return Ca
        }),
        r.d(u, "and", function() {
          return Ra
        }),
        r.d(u, "or", function() {
          return ja
        }),
        r.d(u, "custom", function() {
          return ka
        })
      var c,
        l,
        h,
        d,
        f,
        p = r(3)
      class y {}
      ;(d = c || (c = {})),
        (h = d.apache || (d.apache = {})),
        (function(t) {
          let e
          !(function(t) {
            ;(t[(t.V1 = 0)] = "V1"),
              (t[(t.V2 = 1)] = "V2"),
              (t[(t.V3 = 2)] = "V3"),
              (t[(t.V4 = 3)] = "V4")
          })((e = t.MetadataVersion || (t.MetadataVersion = {})))
        })((l = h.arrow || (h.arrow = {})).flatbuf || (l.flatbuf = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                let e
                !(function(t) {
                  ;(t[(t.Sparse = 0)] = "Sparse"), (t[(t.Dense = 1)] = "Dense")
                })((e = t.UnionMode || (t.UnionMode = {})))
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                let e
                !(function(t) {
                  ;(t[(t.HALF = 0)] = "HALF"),
                    (t[(t.SINGLE = 1)] = "SINGLE"),
                    (t[(t.DOUBLE = 2)] = "DOUBLE")
                })((e = t.Precision || (t.Precision = {})))
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                let e
                !(function(t) {
                  ;(t[(t.DAY = 0)] = "DAY"),
                    (t[(t.MILLISECOND = 1)] = "MILLISECOND")
                })((e = t.DateUnit || (t.DateUnit = {})))
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                let e
                !(function(t) {
                  ;(t[(t.SECOND = 0)] = "SECOND"),
                    (t[(t.MILLISECOND = 1)] = "MILLISECOND"),
                    (t[(t.MICROSECOND = 2)] = "MICROSECOND"),
                    (t[(t.NANOSECOND = 3)] = "NANOSECOND")
                })((e = t.TimeUnit || (t.TimeUnit = {})))
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                let e
                !(function(t) {
                  ;(t[(t.YEAR_MONTH = 0)] = "YEAR_MONTH"),
                    (t[(t.DAY_TIME = 1)] = "DAY_TIME")
                })((e = t.IntervalUnit || (t.IntervalUnit = {})))
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                let e
                !(function(t) {
                  ;(t[(t.NONE = 0)] = "NONE"),
                    (t[(t.Null = 1)] = "Null"),
                    (t[(t.Int = 2)] = "Int"),
                    (t[(t.FloatingPoint = 3)] = "FloatingPoint"),
                    (t[(t.Binary = 4)] = "Binary"),
                    (t[(t.Utf8 = 5)] = "Utf8"),
                    (t[(t.Bool = 6)] = "Bool"),
                    (t[(t.Decimal = 7)] = "Decimal"),
                    (t[(t.Date = 8)] = "Date"),
                    (t[(t.Time = 9)] = "Time"),
                    (t[(t.Timestamp = 10)] = "Timestamp"),
                    (t[(t.Interval = 11)] = "Interval"),
                    (t[(t.List = 12)] = "List"),
                    (t[(t.Struct_ = 13)] = "Struct_"),
                    (t[(t.Union = 14)] = "Union"),
                    (t[(t.FixedSizeBinary = 15)] = "FixedSizeBinary"),
                    (t[(t.FixedSizeList = 16)] = "FixedSizeList"),
                    (t[(t.Map = 17)] = "Map"),
                    (t[(t.Duration = 18)] = "Duration"),
                    (t[(t.LargeBinary = 19)] = "LargeBinary"),
                    (t[(t.LargeUtf8 = 20)] = "LargeUtf8"),
                    (t[(t.LargeList = 21)] = "LargeList")
                })((e = t.Type || (t.Type = {})))
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                let e
                !(function(t) {
                  ;(t[(t.Little = 0)] = "Little"), (t[(t.Big = 1)] = "Big")
                })((e = t.Endianness || (t.Endianness = {})))
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsNull(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  static startNull(t) {
                    t.startObject(0)
                  }
                  static endNull(t) {
                    return t.endObject()
                  }
                  static createNull(t) {
                    return e.startNull(t), e.endNull(t)
                  }
                }
                t.Null = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsStruct_(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  static startStruct_(t) {
                    t.startObject(0)
                  }
                  static endStruct_(t) {
                    return t.endObject()
                  }
                  static createStruct_(t) {
                    return e.startStruct_(t), e.endStruct_(t)
                  }
                }
                t.Struct_ = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsList(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  static startList(t) {
                    t.startObject(0)
                  }
                  static endList(t) {
                    return t.endObject()
                  }
                  static createList(t) {
                    return e.startList(t), e.endList(t)
                  }
                }
                t.List = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsLargeList(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  static startLargeList(t) {
                    t.startObject(0)
                  }
                  static endLargeList(t) {
                    return t.endObject()
                  }
                  static createLargeList(t) {
                    return e.startLargeList(t), e.endLargeList(t)
                  }
                }
                t.LargeList = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsFixedSizeList(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  listSize() {
                    let t = this.bb.__offset(this.bb_pos, 4)
                    return t ? this.bb.readInt32(this.bb_pos + t) : 0
                  }
                  static startFixedSizeList(t) {
                    t.startObject(1)
                  }
                  static addListSize(t, e) {
                    t.addFieldInt32(0, e, 0)
                  }
                  static endFixedSizeList(t) {
                    return t.endObject()
                  }
                  static createFixedSizeList(t, r) {
                    return (
                      e.startFixedSizeList(t),
                      e.addListSize(t, r),
                      e.endFixedSizeList(t)
                    )
                  }
                }
                t.FixedSizeList = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsMap(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  keysSorted() {
                    let t = this.bb.__offset(this.bb_pos, 4)
                    return !!t && !!this.bb.readInt8(this.bb_pos + t)
                  }
                  static startMap(t) {
                    t.startObject(1)
                  }
                  static addKeysSorted(t, e) {
                    t.addFieldInt8(0, +e, 0)
                  }
                  static endMap(t) {
                    return t.endObject()
                  }
                  static createMap(t, r) {
                    return e.startMap(t), e.addKeysSorted(t, r), e.endMap(t)
                  }
                }
                t.Map = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(e) {
            !(function(e) {
              !(function(e) {
                class r {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsUnion(t, e) {
                    return (e || new r()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  mode() {
                    let e = this.bb.__offset(this.bb_pos, 4)
                    return e
                      ? this.bb.readInt16(this.bb_pos + e)
                      : t.apache.arrow.flatbuf.UnionMode.Sparse
                  }
                  typeIds(t) {
                    let e = this.bb.__offset(this.bb_pos, 6)
                    return e
                      ? this.bb.readInt32(
                          this.bb.__vector(this.bb_pos + e) + 4 * t
                        )
                      : 0
                  }
                  typeIdsLength() {
                    let t = this.bb.__offset(this.bb_pos, 6)
                    return t ? this.bb.__vector_len(this.bb_pos + t) : 0
                  }
                  typeIdsArray() {
                    let t = this.bb.__offset(this.bb_pos, 6)
                    return t
                      ? new Int32Array(
                          this.bb.bytes().buffer,
                          this.bb.bytes().byteOffset +
                            this.bb.__vector(this.bb_pos + t),
                          this.bb.__vector_len(this.bb_pos + t)
                        )
                      : null
                  }
                  static startUnion(t) {
                    t.startObject(2)
                  }
                  static addMode(e, r) {
                    e.addFieldInt16(
                      0,
                      r,
                      t.apache.arrow.flatbuf.UnionMode.Sparse
                    )
                  }
                  static addTypeIds(t, e) {
                    t.addFieldOffset(1, e, 0)
                  }
                  static createTypeIdsVector(t, e) {
                    t.startVector(4, e.length, 4)
                    for (let r = e.length - 1; r >= 0; r--) t.addInt32(e[r])
                    return t.endVector()
                  }
                  static startTypeIdsVector(t, e) {
                    t.startVector(4, e, 4)
                  }
                  static endUnion(t) {
                    return t.endObject()
                  }
                  static createUnion(t, e, n) {
                    return (
                      r.startUnion(t),
                      r.addMode(t, e),
                      r.addTypeIds(t, n),
                      r.endUnion(t)
                    )
                  }
                }
                e.Union = r
              })(e.flatbuf || (e.flatbuf = {}))
            })(e.arrow || (e.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsInt(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  bitWidth() {
                    let t = this.bb.__offset(this.bb_pos, 4)
                    return t ? this.bb.readInt32(this.bb_pos + t) : 0
                  }
                  isSigned() {
                    let t = this.bb.__offset(this.bb_pos, 6)
                    return !!t && !!this.bb.readInt8(this.bb_pos + t)
                  }
                  static startInt(t) {
                    t.startObject(2)
                  }
                  static addBitWidth(t, e) {
                    t.addFieldInt32(0, e, 0)
                  }
                  static addIsSigned(t, e) {
                    t.addFieldInt8(1, +e, 0)
                  }
                  static endInt(t) {
                    return t.endObject()
                  }
                  static createInt(t, r, n) {
                    return (
                      e.startInt(t),
                      e.addBitWidth(t, r),
                      e.addIsSigned(t, n),
                      e.endInt(t)
                    )
                  }
                }
                t.Int = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(e) {
            !(function(e) {
              !(function(e) {
                class r {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsFloatingPoint(t, e) {
                    return (e || new r()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  precision() {
                    let e = this.bb.__offset(this.bb_pos, 4)
                    return e
                      ? this.bb.readInt16(this.bb_pos + e)
                      : t.apache.arrow.flatbuf.Precision.HALF
                  }
                  static startFloatingPoint(t) {
                    t.startObject(1)
                  }
                  static addPrecision(e, r) {
                    e.addFieldInt16(
                      0,
                      r,
                      t.apache.arrow.flatbuf.Precision.HALF
                    )
                  }
                  static endFloatingPoint(t) {
                    return t.endObject()
                  }
                  static createFloatingPoint(t, e) {
                    return (
                      r.startFloatingPoint(t),
                      r.addPrecision(t, e),
                      r.endFloatingPoint(t)
                    )
                  }
                }
                e.FloatingPoint = r
              })(e.flatbuf || (e.flatbuf = {}))
            })(e.arrow || (e.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsUtf8(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  static startUtf8(t) {
                    t.startObject(0)
                  }
                  static endUtf8(t) {
                    return t.endObject()
                  }
                  static createUtf8(t) {
                    return e.startUtf8(t), e.endUtf8(t)
                  }
                }
                t.Utf8 = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsBinary(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  static startBinary(t) {
                    t.startObject(0)
                  }
                  static endBinary(t) {
                    return t.endObject()
                  }
                  static createBinary(t) {
                    return e.startBinary(t), e.endBinary(t)
                  }
                }
                t.Binary = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsLargeUtf8(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  static startLargeUtf8(t) {
                    t.startObject(0)
                  }
                  static endLargeUtf8(t) {
                    return t.endObject()
                  }
                  static createLargeUtf8(t) {
                    return e.startLargeUtf8(t), e.endLargeUtf8(t)
                  }
                }
                t.LargeUtf8 = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsLargeBinary(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  static startLargeBinary(t) {
                    t.startObject(0)
                  }
                  static endLargeBinary(t) {
                    return t.endObject()
                  }
                  static createLargeBinary(t) {
                    return e.startLargeBinary(t), e.endLargeBinary(t)
                  }
                }
                t.LargeBinary = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsFixedSizeBinary(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  byteWidth() {
                    let t = this.bb.__offset(this.bb_pos, 4)
                    return t ? this.bb.readInt32(this.bb_pos + t) : 0
                  }
                  static startFixedSizeBinary(t) {
                    t.startObject(1)
                  }
                  static addByteWidth(t, e) {
                    t.addFieldInt32(0, e, 0)
                  }
                  static endFixedSizeBinary(t) {
                    return t.endObject()
                  }
                  static createFixedSizeBinary(t, r) {
                    return (
                      e.startFixedSizeBinary(t),
                      e.addByteWidth(t, r),
                      e.endFixedSizeBinary(t)
                    )
                  }
                }
                t.FixedSizeBinary = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsBool(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  static startBool(t) {
                    t.startObject(0)
                  }
                  static endBool(t) {
                    return t.endObject()
                  }
                  static createBool(t) {
                    return e.startBool(t), e.endBool(t)
                  }
                }
                t.Bool = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsDecimal(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  precision() {
                    let t = this.bb.__offset(this.bb_pos, 4)
                    return t ? this.bb.readInt32(this.bb_pos + t) : 0
                  }
                  scale() {
                    let t = this.bb.__offset(this.bb_pos, 6)
                    return t ? this.bb.readInt32(this.bb_pos + t) : 0
                  }
                  static startDecimal(t) {
                    t.startObject(2)
                  }
                  static addPrecision(t, e) {
                    t.addFieldInt32(0, e, 0)
                  }
                  static addScale(t, e) {
                    t.addFieldInt32(1, e, 0)
                  }
                  static endDecimal(t) {
                    return t.endObject()
                  }
                  static createDecimal(t, r, n) {
                    return (
                      e.startDecimal(t),
                      e.addPrecision(t, r),
                      e.addScale(t, n),
                      e.endDecimal(t)
                    )
                  }
                }
                t.Decimal = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(e) {
            !(function(e) {
              !(function(e) {
                class r {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsDate(t, e) {
                    return (e || new r()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  unit() {
                    let e = this.bb.__offset(this.bb_pos, 4)
                    return e
                      ? this.bb.readInt16(this.bb_pos + e)
                      : t.apache.arrow.flatbuf.DateUnit.MILLISECOND
                  }
                  static startDate(t) {
                    t.startObject(1)
                  }
                  static addUnit(e, r) {
                    e.addFieldInt16(
                      0,
                      r,
                      t.apache.arrow.flatbuf.DateUnit.MILLISECOND
                    )
                  }
                  static endDate(t) {
                    return t.endObject()
                  }
                  static createDate(t, e) {
                    return r.startDate(t), r.addUnit(t, e), r.endDate(t)
                  }
                }
                e.Date = r
              })(e.flatbuf || (e.flatbuf = {}))
            })(e.arrow || (e.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(e) {
            !(function(e) {
              !(function(e) {
                class r {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsTime(t, e) {
                    return (e || new r()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  unit() {
                    let e = this.bb.__offset(this.bb_pos, 4)
                    return e
                      ? this.bb.readInt16(this.bb_pos + e)
                      : t.apache.arrow.flatbuf.TimeUnit.MILLISECOND
                  }
                  bitWidth() {
                    let t = this.bb.__offset(this.bb_pos, 6)
                    return t ? this.bb.readInt32(this.bb_pos + t) : 32
                  }
                  static startTime(t) {
                    t.startObject(2)
                  }
                  static addUnit(e, r) {
                    e.addFieldInt16(
                      0,
                      r,
                      t.apache.arrow.flatbuf.TimeUnit.MILLISECOND
                    )
                  }
                  static addBitWidth(t, e) {
                    t.addFieldInt32(1, e, 32)
                  }
                  static endTime(t) {
                    return t.endObject()
                  }
                  static createTime(t, e, n) {
                    return (
                      r.startTime(t),
                      r.addUnit(t, e),
                      r.addBitWidth(t, n),
                      r.endTime(t)
                    )
                  }
                }
                e.Time = r
              })(e.flatbuf || (e.flatbuf = {}))
            })(e.arrow || (e.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(e) {
            !(function(e) {
              !(function(e) {
                class r {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsTimestamp(t, e) {
                    return (e || new r()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  unit() {
                    let e = this.bb.__offset(this.bb_pos, 4)
                    return e
                      ? this.bb.readInt16(this.bb_pos + e)
                      : t.apache.arrow.flatbuf.TimeUnit.SECOND
                  }
                  timezone(t) {
                    let e = this.bb.__offset(this.bb_pos, 6)
                    return e ? this.bb.__string(this.bb_pos + e, t) : null
                  }
                  static startTimestamp(t) {
                    t.startObject(2)
                  }
                  static addUnit(e, r) {
                    e.addFieldInt16(
                      0,
                      r,
                      t.apache.arrow.flatbuf.TimeUnit.SECOND
                    )
                  }
                  static addTimezone(t, e) {
                    t.addFieldOffset(1, e, 0)
                  }
                  static endTimestamp(t) {
                    return t.endObject()
                  }
                  static createTimestamp(t, e, n) {
                    return (
                      r.startTimestamp(t),
                      r.addUnit(t, e),
                      r.addTimezone(t, n),
                      r.endTimestamp(t)
                    )
                  }
                }
                e.Timestamp = r
              })(e.flatbuf || (e.flatbuf = {}))
            })(e.arrow || (e.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(e) {
            !(function(e) {
              !(function(e) {
                class r {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsInterval(t, e) {
                    return (e || new r()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  unit() {
                    let e = this.bb.__offset(this.bb_pos, 4)
                    return e
                      ? this.bb.readInt16(this.bb_pos + e)
                      : t.apache.arrow.flatbuf.IntervalUnit.YEAR_MONTH
                  }
                  static startInterval(t) {
                    t.startObject(1)
                  }
                  static addUnit(e, r) {
                    e.addFieldInt16(
                      0,
                      r,
                      t.apache.arrow.flatbuf.IntervalUnit.YEAR_MONTH
                    )
                  }
                  static endInterval(t) {
                    return t.endObject()
                  }
                  static createInterval(t, e) {
                    return (
                      r.startInterval(t), r.addUnit(t, e), r.endInterval(t)
                    )
                  }
                }
                e.Interval = r
              })(e.flatbuf || (e.flatbuf = {}))
            })(e.arrow || (e.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(e) {
            !(function(e) {
              !(function(e) {
                class r {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsDuration(t, e) {
                    return (e || new r()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  unit() {
                    let e = this.bb.__offset(this.bb_pos, 4)
                    return e
                      ? this.bb.readInt16(this.bb_pos + e)
                      : t.apache.arrow.flatbuf.TimeUnit.MILLISECOND
                  }
                  static startDuration(t) {
                    t.startObject(1)
                  }
                  static addUnit(e, r) {
                    e.addFieldInt16(
                      0,
                      r,
                      t.apache.arrow.flatbuf.TimeUnit.MILLISECOND
                    )
                  }
                  static endDuration(t) {
                    return t.endObject()
                  }
                  static createDuration(t, e) {
                    return (
                      r.startDuration(t), r.addUnit(t, e), r.endDuration(t)
                    )
                  }
                }
                e.Duration = r
              })(e.flatbuf || (e.flatbuf = {}))
            })(e.arrow || (e.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                class e {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsKeyValue(t, r) {
                    return (r || new e()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  key(t) {
                    let e = this.bb.__offset(this.bb_pos, 4)
                    return e ? this.bb.__string(this.bb_pos + e, t) : null
                  }
                  value(t) {
                    let e = this.bb.__offset(this.bb_pos, 6)
                    return e ? this.bb.__string(this.bb_pos + e, t) : null
                  }
                  static startKeyValue(t) {
                    t.startObject(2)
                  }
                  static addKey(t, e) {
                    t.addFieldOffset(0, e, 0)
                  }
                  static addValue(t, e) {
                    t.addFieldOffset(1, e, 0)
                  }
                  static endKeyValue(t) {
                    return t.endObject()
                  }
                  static createKeyValue(t, r, n) {
                    return (
                      e.startKeyValue(t),
                      e.addKey(t, r),
                      e.addValue(t, n),
                      e.endKeyValue(t)
                    )
                  }
                }
                t.KeyValue = e
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(e) {
            !(function(e) {
              !(function(e) {
                class r {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsDictionaryEncoding(t, e) {
                    return (e || new r()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  id() {
                    let t = this.bb.__offset(this.bb_pos, 4)
                    return t
                      ? this.bb.readInt64(this.bb_pos + t)
                      : this.bb.createLong(0, 0)
                  }
                  indexType(e) {
                    let r = this.bb.__offset(this.bb_pos, 6)
                    return r
                      ? (e || new t.apache.arrow.flatbuf.Int()).__init(
                          this.bb.__indirect(this.bb_pos + r),
                          this.bb
                        )
                      : null
                  }
                  isOrdered() {
                    let t = this.bb.__offset(this.bb_pos, 8)
                    return !!t && !!this.bb.readInt8(this.bb_pos + t)
                  }
                  static startDictionaryEncoding(t) {
                    t.startObject(3)
                  }
                  static addId(t, e) {
                    t.addFieldInt64(0, e, t.createLong(0, 0))
                  }
                  static addIndexType(t, e) {
                    t.addFieldOffset(1, e, 0)
                  }
                  static addIsOrdered(t, e) {
                    t.addFieldInt8(2, +e, 0)
                  }
                  static endDictionaryEncoding(t) {
                    return t.endObject()
                  }
                  static createDictionaryEncoding(t, e, n, i) {
                    return (
                      r.startDictionaryEncoding(t),
                      r.addId(t, e),
                      r.addIndexType(t, n),
                      r.addIsOrdered(t, i),
                      r.endDictionaryEncoding(t)
                    )
                  }
                }
                e.DictionaryEncoding = r
              })(e.flatbuf || (e.flatbuf = {}))
            })(e.arrow || (e.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(e) {
            !(function(e) {
              !(function(e) {
                class r {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsField(t, e) {
                    return (e || new r()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  name(t) {
                    let e = this.bb.__offset(this.bb_pos, 4)
                    return e ? this.bb.__string(this.bb_pos + e, t) : null
                  }
                  nullable() {
                    let t = this.bb.__offset(this.bb_pos, 6)
                    return !!t && !!this.bb.readInt8(this.bb_pos + t)
                  }
                  typeType() {
                    let e = this.bb.__offset(this.bb_pos, 8)
                    return e
                      ? this.bb.readUint8(this.bb_pos + e)
                      : t.apache.arrow.flatbuf.Type.NONE
                  }
                  type(t) {
                    let e = this.bb.__offset(this.bb_pos, 10)
                    return e ? this.bb.__union(t, this.bb_pos + e) : null
                  }
                  dictionary(e) {
                    let r = this.bb.__offset(this.bb_pos, 12)
                    return r
                      ? (
                          e || new t.apache.arrow.flatbuf.DictionaryEncoding()
                        ).__init(this.bb.__indirect(this.bb_pos + r), this.bb)
                      : null
                  }
                  children(e, r) {
                    let n = this.bb.__offset(this.bb_pos, 14)
                    return n
                      ? (r || new t.apache.arrow.flatbuf.Field()).__init(
                          this.bb.__indirect(
                            this.bb.__vector(this.bb_pos + n) + 4 * e
                          ),
                          this.bb
                        )
                      : null
                  }
                  childrenLength() {
                    let t = this.bb.__offset(this.bb_pos, 14)
                    return t ? this.bb.__vector_len(this.bb_pos + t) : 0
                  }
                  customMetadata(e, r) {
                    let n = this.bb.__offset(this.bb_pos, 16)
                    return n
                      ? (r || new t.apache.arrow.flatbuf.KeyValue()).__init(
                          this.bb.__indirect(
                            this.bb.__vector(this.bb_pos + n) + 4 * e
                          ),
                          this.bb
                        )
                      : null
                  }
                  customMetadataLength() {
                    let t = this.bb.__offset(this.bb_pos, 16)
                    return t ? this.bb.__vector_len(this.bb_pos + t) : 0
                  }
                  static startField(t) {
                    t.startObject(7)
                  }
                  static addName(t, e) {
                    t.addFieldOffset(0, e, 0)
                  }
                  static addNullable(t, e) {
                    t.addFieldInt8(1, +e, 0)
                  }
                  static addTypeType(e, r) {
                    e.addFieldInt8(2, r, t.apache.arrow.flatbuf.Type.NONE)
                  }
                  static addType(t, e) {
                    t.addFieldOffset(3, e, 0)
                  }
                  static addDictionary(t, e) {
                    t.addFieldOffset(4, e, 0)
                  }
                  static addChildren(t, e) {
                    t.addFieldOffset(5, e, 0)
                  }
                  static createChildrenVector(t, e) {
                    t.startVector(4, e.length, 4)
                    for (let r = e.length - 1; r >= 0; r--) t.addOffset(e[r])
                    return t.endVector()
                  }
                  static startChildrenVector(t, e) {
                    t.startVector(4, e, 4)
                  }
                  static addCustomMetadata(t, e) {
                    t.addFieldOffset(6, e, 0)
                  }
                  static createCustomMetadataVector(t, e) {
                    t.startVector(4, e.length, 4)
                    for (let r = e.length - 1; r >= 0; r--) t.addOffset(e[r])
                    return t.endVector()
                  }
                  static startCustomMetadataVector(t, e) {
                    t.startVector(4, e, 4)
                  }
                  static endField(t) {
                    return t.endObject()
                  }
                  static createField(t, e, n, i, s, o, a, u) {
                    return (
                      r.startField(t),
                      r.addName(t, e),
                      r.addNullable(t, n),
                      r.addTypeType(t, i),
                      r.addType(t, s),
                      r.addDictionary(t, o),
                      r.addChildren(t, a),
                      r.addCustomMetadata(t, u),
                      r.endField(t)
                    )
                  }
                }
                e.Field = r
              })(e.flatbuf || (e.flatbuf = {}))
            })(e.arrow || (e.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                t.Buffer = class {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  offset() {
                    return this.bb.readInt64(this.bb_pos)
                  }
                  length() {
                    return this.bb.readInt64(this.bb_pos + 8)
                  }
                  static createBuffer(t, e, r) {
                    return (
                      t.prep(8, 16),
                      t.writeInt64(r),
                      t.writeInt64(e),
                      t.offset()
                    )
                  }
                }
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(e) {
            !(function(e) {
              !(function(e) {
                class r {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsSchema(t, e) {
                    return (e || new r()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  endianness() {
                    let e = this.bb.__offset(this.bb_pos, 4)
                    return e
                      ? this.bb.readInt16(this.bb_pos + e)
                      : t.apache.arrow.flatbuf.Endianness.Little
                  }
                  fields(e, r) {
                    let n = this.bb.__offset(this.bb_pos, 6)
                    return n
                      ? (r || new t.apache.arrow.flatbuf.Field()).__init(
                          this.bb.__indirect(
                            this.bb.__vector(this.bb_pos + n) + 4 * e
                          ),
                          this.bb
                        )
                      : null
                  }
                  fieldsLength() {
                    let t = this.bb.__offset(this.bb_pos, 6)
                    return t ? this.bb.__vector_len(this.bb_pos + t) : 0
                  }
                  customMetadata(e, r) {
                    let n = this.bb.__offset(this.bb_pos, 8)
                    return n
                      ? (r || new t.apache.arrow.flatbuf.KeyValue()).__init(
                          this.bb.__indirect(
                            this.bb.__vector(this.bb_pos + n) + 4 * e
                          ),
                          this.bb
                        )
                      : null
                  }
                  customMetadataLength() {
                    let t = this.bb.__offset(this.bb_pos, 8)
                    return t ? this.bb.__vector_len(this.bb_pos + t) : 0
                  }
                  static startSchema(t) {
                    t.startObject(3)
                  }
                  static addEndianness(e, r) {
                    e.addFieldInt16(
                      0,
                      r,
                      t.apache.arrow.flatbuf.Endianness.Little
                    )
                  }
                  static addFields(t, e) {
                    t.addFieldOffset(1, e, 0)
                  }
                  static createFieldsVector(t, e) {
                    t.startVector(4, e.length, 4)
                    for (let r = e.length - 1; r >= 0; r--) t.addOffset(e[r])
                    return t.endVector()
                  }
                  static startFieldsVector(t, e) {
                    t.startVector(4, e, 4)
                  }
                  static addCustomMetadata(t, e) {
                    t.addFieldOffset(2, e, 0)
                  }
                  static createCustomMetadataVector(t, e) {
                    t.startVector(4, e.length, 4)
                    for (let r = e.length - 1; r >= 0; r--) t.addOffset(e[r])
                    return t.endVector()
                  }
                  static startCustomMetadataVector(t, e) {
                    t.startVector(4, e, 4)
                  }
                  static endSchema(t) {
                    return t.endObject()
                  }
                  static finishSchemaBuffer(t, e) {
                    t.finish(e)
                  }
                  static createSchema(t, e, n, i) {
                    return (
                      r.startSchema(t),
                      r.addEndianness(t, e),
                      r.addFields(t, n),
                      r.addCustomMetadata(t, i),
                      r.endSchema(t)
                    )
                  }
                }
                e.Schema = r
              })(e.flatbuf || (e.flatbuf = {}))
            })(e.arrow || (e.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(c || (c = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                t.Schema = c.apache.arrow.flatbuf.Schema
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(f || (f = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                let e
                !(function(t) {
                  ;(t[(t.NONE = 0)] = "NONE"),
                    (t[(t.Schema = 1)] = "Schema"),
                    (t[(t.DictionaryBatch = 2)] = "DictionaryBatch"),
                    (t[(t.RecordBatch = 3)] = "RecordBatch"),
                    (t[(t.Tensor = 4)] = "Tensor"),
                    (t[(t.SparseTensor = 5)] = "SparseTensor")
                })((e = t.MessageHeader || (t.MessageHeader = {})))
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(f || (f = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                t.FieldNode = class {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  length() {
                    return this.bb.readInt64(this.bb_pos)
                  }
                  nullCount() {
                    return this.bb.readInt64(this.bb_pos + 8)
                  }
                  static createFieldNode(t, e, r) {
                    return (
                      t.prep(8, 16),
                      t.writeInt64(r),
                      t.writeInt64(e),
                      t.offset()
                    )
                  }
                }
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(f || (f = {})),
        (function(t) {
          !(function(e) {
            !(function(e) {
              !(function(e) {
                class r {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsRecordBatch(t, e) {
                    return (e || new r()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  length() {
                    let t = this.bb.__offset(this.bb_pos, 4)
                    return t
                      ? this.bb.readInt64(this.bb_pos + t)
                      : this.bb.createLong(0, 0)
                  }
                  nodes(e, r) {
                    let n = this.bb.__offset(this.bb_pos, 6)
                    return n
                      ? (r || new t.apache.arrow.flatbuf.FieldNode()).__init(
                          this.bb.__vector(this.bb_pos + n) + 16 * e,
                          this.bb
                        )
                      : null
                  }
                  nodesLength() {
                    let t = this.bb.__offset(this.bb_pos, 6)
                    return t ? this.bb.__vector_len(this.bb_pos + t) : 0
                  }
                  buffers(t, e) {
                    let r = this.bb.__offset(this.bb_pos, 8)
                    return r
                      ? (e || new c.apache.arrow.flatbuf.Buffer()).__init(
                          this.bb.__vector(this.bb_pos + r) + 16 * t,
                          this.bb
                        )
                      : null
                  }
                  buffersLength() {
                    let t = this.bb.__offset(this.bb_pos, 8)
                    return t ? this.bb.__vector_len(this.bb_pos + t) : 0
                  }
                  static startRecordBatch(t) {
                    t.startObject(3)
                  }
                  static addLength(t, e) {
                    t.addFieldInt64(0, e, t.createLong(0, 0))
                  }
                  static addNodes(t, e) {
                    t.addFieldOffset(1, e, 0)
                  }
                  static startNodesVector(t, e) {
                    t.startVector(16, e, 8)
                  }
                  static addBuffers(t, e) {
                    t.addFieldOffset(2, e, 0)
                  }
                  static startBuffersVector(t, e) {
                    t.startVector(16, e, 8)
                  }
                  static endRecordBatch(t) {
                    return t.endObject()
                  }
                  static createRecordBatch(t, e, n, i) {
                    return (
                      r.startRecordBatch(t),
                      r.addLength(t, e),
                      r.addNodes(t, n),
                      r.addBuffers(t, i),
                      r.endRecordBatch(t)
                    )
                  }
                }
                e.RecordBatch = r
              })(e.flatbuf || (e.flatbuf = {}))
            })(e.arrow || (e.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(f || (f = {})),
        (function(t) {
          !(function(e) {
            !(function(e) {
              !(function(e) {
                class r {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsDictionaryBatch(t, e) {
                    return (e || new r()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  id() {
                    let t = this.bb.__offset(this.bb_pos, 4)
                    return t
                      ? this.bb.readInt64(this.bb_pos + t)
                      : this.bb.createLong(0, 0)
                  }
                  data(e) {
                    let r = this.bb.__offset(this.bb_pos, 6)
                    return r
                      ? (e || new t.apache.arrow.flatbuf.RecordBatch()).__init(
                          this.bb.__indirect(this.bb_pos + r),
                          this.bb
                        )
                      : null
                  }
                  isDelta() {
                    let t = this.bb.__offset(this.bb_pos, 8)
                    return !!t && !!this.bb.readInt8(this.bb_pos + t)
                  }
                  static startDictionaryBatch(t) {
                    t.startObject(3)
                  }
                  static addId(t, e) {
                    t.addFieldInt64(0, e, t.createLong(0, 0))
                  }
                  static addData(t, e) {
                    t.addFieldOffset(1, e, 0)
                  }
                  static addIsDelta(t, e) {
                    t.addFieldInt8(2, +e, 0)
                  }
                  static endDictionaryBatch(t) {
                    return t.endObject()
                  }
                  static createDictionaryBatch(t, e, n, i) {
                    return (
                      r.startDictionaryBatch(t),
                      r.addId(t, e),
                      r.addData(t, n),
                      r.addIsDelta(t, i),
                      r.endDictionaryBatch(t)
                    )
                  }
                }
                e.DictionaryBatch = r
              })(e.flatbuf || (e.flatbuf = {}))
            })(e.arrow || (e.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(f || (f = {})),
        (function(t) {
          !(function(e) {
            !(function(e) {
              !(function(e) {
                class r {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsMessage(t, e) {
                    return (e || new r()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  version() {
                    let t = this.bb.__offset(this.bb_pos, 4)
                    return t
                      ? this.bb.readInt16(this.bb_pos + t)
                      : c.apache.arrow.flatbuf.MetadataVersion.V1
                  }
                  headerType() {
                    let e = this.bb.__offset(this.bb_pos, 6)
                    return e
                      ? this.bb.readUint8(this.bb_pos + e)
                      : t.apache.arrow.flatbuf.MessageHeader.NONE
                  }
                  header(t) {
                    let e = this.bb.__offset(this.bb_pos, 8)
                    return e ? this.bb.__union(t, this.bb_pos + e) : null
                  }
                  bodyLength() {
                    let t = this.bb.__offset(this.bb_pos, 10)
                    return t
                      ? this.bb.readInt64(this.bb_pos + t)
                      : this.bb.createLong(0, 0)
                  }
                  customMetadata(t, e) {
                    let r = this.bb.__offset(this.bb_pos, 12)
                    return r
                      ? (e || new c.apache.arrow.flatbuf.KeyValue()).__init(
                          this.bb.__indirect(
                            this.bb.__vector(this.bb_pos + r) + 4 * t
                          ),
                          this.bb
                        )
                      : null
                  }
                  customMetadataLength() {
                    let t = this.bb.__offset(this.bb_pos, 12)
                    return t ? this.bb.__vector_len(this.bb_pos + t) : 0
                  }
                  static startMessage(t) {
                    t.startObject(5)
                  }
                  static addVersion(t, e) {
                    t.addFieldInt16(
                      0,
                      e,
                      c.apache.arrow.flatbuf.MetadataVersion.V1
                    )
                  }
                  static addHeaderType(e, r) {
                    e.addFieldInt8(
                      1,
                      r,
                      t.apache.arrow.flatbuf.MessageHeader.NONE
                    )
                  }
                  static addHeader(t, e) {
                    t.addFieldOffset(2, e, 0)
                  }
                  static addBodyLength(t, e) {
                    t.addFieldInt64(3, e, t.createLong(0, 0))
                  }
                  static addCustomMetadata(t, e) {
                    t.addFieldOffset(4, e, 0)
                  }
                  static createCustomMetadataVector(t, e) {
                    t.startVector(4, e.length, 4)
                    for (let r = e.length - 1; r >= 0; r--) t.addOffset(e[r])
                    return t.endVector()
                  }
                  static startCustomMetadataVector(t, e) {
                    t.startVector(4, e, 4)
                  }
                  static endMessage(t) {
                    return t.endObject()
                  }
                  static finishMessageBuffer(t, e) {
                    t.finish(e)
                  }
                  static createMessage(t, e, n, i, s, o) {
                    return (
                      r.startMessage(t),
                      r.addVersion(t, e),
                      r.addHeaderType(t, n),
                      r.addHeader(t, i),
                      r.addBodyLength(t, s),
                      r.addCustomMetadata(t, o),
                      r.endMessage(t)
                    )
                  }
                }
                e.Message = r
              })(e.flatbuf || (e.flatbuf = {}))
            })(e.arrow || (e.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(f || (f = {}))
      var b,
        g,
        _ = c.apache.arrow.flatbuf.Type,
        m = c.apache.arrow.flatbuf.DateUnit,
        w = c.apache.arrow.flatbuf.TimeUnit,
        v = c.apache.arrow.flatbuf.Precision,
        I = c.apache.arrow.flatbuf.UnionMode,
        A = c.apache.arrow.flatbuf.IntervalUnit,
        B = f.apache.arrow.flatbuf.MessageHeader,
        S = c.apache.arrow.flatbuf.MetadataVersion
      function T(t, e, r, n) {
        return 0 != (r & (1 << n))
      }
      function O(t, e, r, n) {
        return (r & (1 << n)) >> n
      }
      function D(t, e, r) {
        return r
          ? !!(t[e >> 3] |= 1 << e % 8) || !0
          : !(t[e >> 3] &= ~(1 << e % 8)) && !1
      }
      function U(t, e, r) {
        const n = (r.byteLength + 7) & -8
        if (t > 0 || r.byteLength < n) {
          const i = new Uint8Array(n)
          return (
            i.set(
              t % 8 == 0
                ? r.subarray(t >> 3)
                : L(F(r, t, e, null, T)).subarray(0, n)
            ),
            i
          )
        }
        return r
      }
      function L(t) {
        let e = [],
          r = 0,
          n = 0,
          i = 0
        for (const o of t)
          o && (i |= 1 << n), 8 == ++n && ((e[r++] = i), (i = n = 0))
        ;(0 === r || n > 0) && (e[r++] = i)
        let s = new Uint8Array((e.length + 7) & -8)
        return s.set(e), s
      }
      function* F(t, e, r, n, i) {
        let s = e % 8,
          o = e >> 3,
          a = 0,
          u = r
        for (; u > 0; s = 0) {
          let e = t[o++]
          do {
            yield i(n, a++, e, s)
          } while (--u > 0 && ++s < 8)
        }
      }
      function x(t, e, r) {
        if (r - e <= 0) return 0
        if (r - e < 8) {
          let n = 0
          for (const i of F(t, e, r - e, t, O)) n += i
          return n
        }
        const n = (r >> 3) << 3,
          i = e + (e % 8 == 0 ? 0 : 8 - (e % 8))
        return x(t, e, i) + x(t, n, r) + M(t, i >> 3, (n - i) >> 3)
      }
      function M(t, e, r) {
        let n = 0,
          i = 0 | e
        const s = new DataView(t.buffer, t.byteOffset, t.byteLength),
          o = void 0 === r ? t.byteLength : i + r
        for (; o - i >= 4; ) (n += E(s.getUint32(i))), (i += 4)
        for (; o - i >= 2; ) (n += E(s.getUint16(i))), (i += 2)
        for (; o - i >= 1; ) (n += E(s.getUint8(i))), (i += 1)
        return n
      }
      function E(t) {
        let e = 0 | t
        return (
          (16843009 *
            (((e =
              (858993459 & (e -= (e >>> 1) & 1431655765)) +
              ((e >>> 2) & 858993459)) +
              (e >>> 4)) &
              252645135)) >>>
          24
        )
      }
      !(function(t) {
        ;(t[(t.NONE = 0)] = "NONE"),
          (t[(t.Null = 1)] = "Null"),
          (t[(t.Int = 2)] = "Int"),
          (t[(t.Float = 3)] = "Float"),
          (t[(t.Binary = 4)] = "Binary"),
          (t[(t.Utf8 = 5)] = "Utf8"),
          (t[(t.Bool = 6)] = "Bool"),
          (t[(t.Decimal = 7)] = "Decimal"),
          (t[(t.Date = 8)] = "Date"),
          (t[(t.Time = 9)] = "Time"),
          (t[(t.Timestamp = 10)] = "Timestamp"),
          (t[(t.Interval = 11)] = "Interval"),
          (t[(t.List = 12)] = "List"),
          (t[(t.Struct = 13)] = "Struct"),
          (t[(t.Union = 14)] = "Union"),
          (t[(t.FixedSizeBinary = 15)] = "FixedSizeBinary"),
          (t[(t.FixedSizeList = 16)] = "FixedSizeList"),
          (t[(t.Map = 17)] = "Map"),
          (t[(t.Dictionary = -1)] = "Dictionary"),
          (t[(t.Int8 = -2)] = "Int8"),
          (t[(t.Int16 = -3)] = "Int16"),
          (t[(t.Int32 = -4)] = "Int32"),
          (t[(t.Int64 = -5)] = "Int64"),
          (t[(t.Uint8 = -6)] = "Uint8"),
          (t[(t.Uint16 = -7)] = "Uint16"),
          (t[(t.Uint32 = -8)] = "Uint32"),
          (t[(t.Uint64 = -9)] = "Uint64"),
          (t[(t.Float16 = -10)] = "Float16"),
          (t[(t.Float32 = -11)] = "Float32"),
          (t[(t.Float64 = -12)] = "Float64"),
          (t[(t.DateDay = -13)] = "DateDay"),
          (t[(t.DateMillisecond = -14)] = "DateMillisecond"),
          (t[(t.TimestampSecond = -15)] = "TimestampSecond"),
          (t[(t.TimestampMillisecond = -16)] = "TimestampMillisecond"),
          (t[(t.TimestampMicrosecond = -17)] = "TimestampMicrosecond"),
          (t[(t.TimestampNanosecond = -18)] = "TimestampNanosecond"),
          (t[(t.TimeSecond = -19)] = "TimeSecond"),
          (t[(t.TimeMillisecond = -20)] = "TimeMillisecond"),
          (t[(t.TimeMicrosecond = -21)] = "TimeMicrosecond"),
          (t[(t.TimeNanosecond = -22)] = "TimeNanosecond"),
          (t[(t.DenseUnion = -23)] = "DenseUnion"),
          (t[(t.SparseUnion = -24)] = "SparseUnion"),
          (t[(t.IntervalDayTime = -25)] = "IntervalDayTime"),
          (t[(t.IntervalYearMonth = -26)] = "IntervalYearMonth")
      })(b || (b = {})),
        (function(t) {
          ;(t[(t.OFFSET = 0)] = "OFFSET"),
            (t[(t.DATA = 1)] = "DATA"),
            (t[(t.VALIDITY = 2)] = "VALIDITY"),
            (t[(t.TYPE = 3)] = "TYPE")
        })(g || (g = {}))
      class N {
        visitMany(t, ...e) {
          return t.map((t, r) => this.visit(t, ...e.map(t => t[r])))
        }
        visit(...t) {
          return this.getVisitFn(t[0], !1).apply(this, t)
        }
        getVisitFn(t, e = !0) {
          return (function(t, e, r = !0) {
            let n = null,
              i = b.NONE
            e instanceof Pt
              ? (i = V(e.type))
              : e instanceof y
              ? (i = V(e.type))
              : e instanceof J
              ? (i = V(e))
              : "number" != typeof (i = e) && (i = b[e])
            switch (i) {
              case b.Null:
                n = t.visitNull
                break
              case b.Bool:
                n = t.visitBool
                break
              case b.Int:
                n = t.visitInt
                break
              case b.Int8:
                n = t.visitInt8 || t.visitInt
                break
              case b.Int16:
                n = t.visitInt16 || t.visitInt
                break
              case b.Int32:
                n = t.visitInt32 || t.visitInt
                break
              case b.Int64:
                n = t.visitInt64 || t.visitInt
                break
              case b.Uint8:
                n = t.visitUint8 || t.visitInt
                break
              case b.Uint16:
                n = t.visitUint16 || t.visitInt
                break
              case b.Uint32:
                n = t.visitUint32 || t.visitInt
                break
              case b.Uint64:
                n = t.visitUint64 || t.visitInt
                break
              case b.Float:
                n = t.visitFloat
                break
              case b.Float16:
                n = t.visitFloat16 || t.visitFloat
                break
              case b.Float32:
                n = t.visitFloat32 || t.visitFloat
                break
              case b.Float64:
                n = t.visitFloat64 || t.visitFloat
                break
              case b.Utf8:
                n = t.visitUtf8
                break
              case b.Binary:
                n = t.visitBinary
                break
              case b.FixedSizeBinary:
                n = t.visitFixedSizeBinary
                break
              case b.Date:
                n = t.visitDate
                break
              case b.DateDay:
                n = t.visitDateDay || t.visitDate
                break
              case b.DateMillisecond:
                n = t.visitDateMillisecond || t.visitDate
                break
              case b.Timestamp:
                n = t.visitTimestamp
                break
              case b.TimestampSecond:
                n = t.visitTimestampSecond || t.visitTimestamp
                break
              case b.TimestampMillisecond:
                n = t.visitTimestampMillisecond || t.visitTimestamp
                break
              case b.TimestampMicrosecond:
                n = t.visitTimestampMicrosecond || t.visitTimestamp
                break
              case b.TimestampNanosecond:
                n = t.visitTimestampNanosecond || t.visitTimestamp
                break
              case b.Time:
                n = t.visitTime
                break
              case b.TimeSecond:
                n = t.visitTimeSecond || t.visitTime
                break
              case b.TimeMillisecond:
                n = t.visitTimeMillisecond || t.visitTime
                break
              case b.TimeMicrosecond:
                n = t.visitTimeMicrosecond || t.visitTime
                break
              case b.TimeNanosecond:
                n = t.visitTimeNanosecond || t.visitTime
                break
              case b.Decimal:
                n = t.visitDecimal
                break
              case b.List:
                n = t.visitList
                break
              case b.Struct:
                n = t.visitStruct
                break
              case b.Union:
                n = t.visitUnion
                break
              case b.DenseUnion:
                n = t.visitDenseUnion || t.visitUnion
                break
              case b.SparseUnion:
                n = t.visitSparseUnion || t.visitUnion
                break
              case b.Dictionary:
                n = t.visitDictionary
                break
              case b.Interval:
                n = t.visitInterval
                break
              case b.IntervalDayTime:
                n = t.visitIntervalDayTime || t.visitInterval
                break
              case b.IntervalYearMonth:
                n = t.visitIntervalYearMonth || t.visitInterval
                break
              case b.FixedSizeList:
                n = t.visitFixedSizeList
                break
              case b.Map:
                n = t.visitMap
            }
            if ("function" == typeof n) return n
            if (!r) return () => null
            throw Error(`Unrecognized type '${b[i]}'`)
          })(this, t, e)
        }
        visitNull(t, ...e) {
          return null
        }
        visitBool(t, ...e) {
          return null
        }
        visitInt(t, ...e) {
          return null
        }
        visitFloat(t, ...e) {
          return null
        }
        visitUtf8(t, ...e) {
          return null
        }
        visitBinary(t, ...e) {
          return null
        }
        visitFixedSizeBinary(t, ...e) {
          return null
        }
        visitDate(t, ...e) {
          return null
        }
        visitTimestamp(t, ...e) {
          return null
        }
        visitTime(t, ...e) {
          return null
        }
        visitDecimal(t, ...e) {
          return null
        }
        visitList(t, ...e) {
          return null
        }
        visitStruct(t, ...e) {
          return null
        }
        visitUnion(t, ...e) {
          return null
        }
        visitDictionary(t, ...e) {
          return null
        }
        visitInterval(t, ...e) {
          return null
        }
        visitFixedSizeList(t, ...e) {
          return null
        }
        visitMap(t, ...e) {
          return null
        }
      }
      function V(t) {
        switch (t.typeId) {
          case b.Null:
            return b.Null
          case b.Int:
            const { bitWidth: e, isSigned: r } = t
            switch (e) {
              case 8:
                return r ? b.Int8 : b.Uint8
              case 16:
                return r ? b.Int16 : b.Uint16
              case 32:
                return r ? b.Int32 : b.Uint32
              case 64:
                return r ? b.Int64 : b.Uint64
            }
            return b.Int
          case b.Float:
            switch (t.precision) {
              case v.HALF:
                return b.Float16
              case v.SINGLE:
                return b.Float32
              case v.DOUBLE:
                return b.Float64
            }
            return b.Float
          case b.Binary:
            return b.Binary
          case b.Utf8:
            return b.Utf8
          case b.Bool:
            return b.Bool
          case b.Decimal:
            return b.Decimal
          case b.Time:
            switch (t.unit) {
              case w.SECOND:
                return b.TimeSecond
              case w.MILLISECOND:
                return b.TimeMillisecond
              case w.MICROSECOND:
                return b.TimeMicrosecond
              case w.NANOSECOND:
                return b.TimeNanosecond
            }
            return b.Time
          case b.Timestamp:
            switch (t.unit) {
              case w.SECOND:
                return b.TimestampSecond
              case w.MILLISECOND:
                return b.TimestampMillisecond
              case w.MICROSECOND:
                return b.TimestampMicrosecond
              case w.NANOSECOND:
                return b.TimestampNanosecond
            }
            return b.Timestamp
          case b.Date:
            switch (t.unit) {
              case m.DAY:
                return b.DateDay
              case m.MILLISECOND:
                return b.DateMillisecond
            }
            return b.Date
          case b.Interval:
            switch (t.unit) {
              case A.DAY_TIME:
                return b.IntervalDayTime
              case A.YEAR_MONTH:
                return b.IntervalYearMonth
            }
            return b.Interval
          case b.Map:
            return b.Map
          case b.List:
            return b.List
          case b.Struct:
            return b.Struct
          case b.Union:
            switch (t.mode) {
              case I.Dense:
                return b.DenseUnion
              case I.Sparse:
                return b.SparseUnion
            }
            return b.Union
          case b.FixedSizeBinary:
            return b.FixedSizeBinary
          case b.FixedSizeList:
            return b.FixedSizeList
          case b.Dictionary:
            return b.Dictionary
        }
        throw Error(`Unrecognized type '${b[t.typeId]}'`)
      }
      ;(N.prototype.visitInt8 = null),
        (N.prototype.visitInt16 = null),
        (N.prototype.visitInt32 = null),
        (N.prototype.visitInt64 = null),
        (N.prototype.visitUint8 = null),
        (N.prototype.visitUint16 = null),
        (N.prototype.visitUint32 = null),
        (N.prototype.visitUint64 = null),
        (N.prototype.visitFloat16 = null),
        (N.prototype.visitFloat32 = null),
        (N.prototype.visitFloat64 = null),
        (N.prototype.visitDateDay = null),
        (N.prototype.visitDateMillisecond = null),
        (N.prototype.visitTimestampSecond = null),
        (N.prototype.visitTimestampMillisecond = null),
        (N.prototype.visitTimestampMicrosecond = null),
        (N.prototype.visitTimestampNanosecond = null),
        (N.prototype.visitTimeSecond = null),
        (N.prototype.visitTimeMillisecond = null),
        (N.prototype.visitTimeMicrosecond = null),
        (N.prototype.visitTimeNanosecond = null),
        (N.prototype.visitDenseUnion = null),
        (N.prototype.visitSparseUnion = null),
        (N.prototype.visitIntervalDayTime = null),
        (N.prototype.visitIntervalYearMonth = null)
      class C extends N {
        compareSchemas(t, e) {
          return (
            t === e ||
            (e instanceof t.constructor && K.compareFields(t.fields, e.fields))
          )
        }
        compareFields(t, e) {
          return (
            t === e ||
            (Array.isArray(t) &&
              Array.isArray(e) &&
              t.length === e.length &&
              t.every((t, r) => K.compareField(t, e[r])))
          )
        }
        compareField(t, e) {
          return (
            t === e ||
            (e instanceof t.constructor &&
              t.name === e.name &&
              t.nullable === e.nullable &&
              K.visit(t.type, e.type))
          )
        }
      }
      function R(t, e) {
        return e instanceof t.constructor
      }
      function j(t, e) {
        return t === e || R(t, e)
      }
      function k(t, e) {
        return (
          t === e ||
          (R(t, e) && t.bitWidth === e.bitWidth && t.isSigned === e.isSigned)
        )
      }
      function z(t, e) {
        return t === e || (R(t, e) && t.precision === e.precision)
      }
      function P(t, e) {
        return t === e || (R(t, e) && t.unit === e.unit)
      }
      function Y(t, e) {
        return (
          t === e ||
          (R(t, e) && t.unit === e.unit && t.timezone === e.timezone)
        )
      }
      function $(t, e) {
        return (
          t === e ||
          (R(t, e) && t.unit === e.unit && t.bitWidth === e.bitWidth)
        )
      }
      function W(t, e) {
        return (
          t === e ||
          (R(t, e) &&
            t.mode === e.mode &&
            t.typeIds.every((t, r) => t === e.typeIds[r]) &&
            K.compareFields(t.children, e.children))
        )
      }
      function H(t, e) {
        return t === e || (R(t, e) && t.unit === e.unit)
      }
      ;(C.prototype.visitNull = j),
        (C.prototype.visitBool = j),
        (C.prototype.visitInt = k),
        (C.prototype.visitInt8 = k),
        (C.prototype.visitInt16 = k),
        (C.prototype.visitInt32 = k),
        (C.prototype.visitInt64 = k),
        (C.prototype.visitUint8 = k),
        (C.prototype.visitUint16 = k),
        (C.prototype.visitUint32 = k),
        (C.prototype.visitUint64 = k),
        (C.prototype.visitFloat = z),
        (C.prototype.visitFloat16 = z),
        (C.prototype.visitFloat32 = z),
        (C.prototype.visitFloat64 = z),
        (C.prototype.visitUtf8 = j),
        (C.prototype.visitBinary = j),
        (C.prototype.visitFixedSizeBinary = function(t, e) {
          return t === e || (R(t, e) && t.byteWidth === e.byteWidth)
        }),
        (C.prototype.visitDate = P),
        (C.prototype.visitDateDay = P),
        (C.prototype.visitDateMillisecond = P),
        (C.prototype.visitTimestamp = Y),
        (C.prototype.visitTimestampSecond = Y),
        (C.prototype.visitTimestampMillisecond = Y),
        (C.prototype.visitTimestampMicrosecond = Y),
        (C.prototype.visitTimestampNanosecond = Y),
        (C.prototype.visitTime = $),
        (C.prototype.visitTimeSecond = $),
        (C.prototype.visitTimeMillisecond = $),
        (C.prototype.visitTimeMicrosecond = $),
        (C.prototype.visitTimeNanosecond = $),
        (C.prototype.visitDecimal = j),
        (C.prototype.visitList = function(t, e) {
          return (
            t === e ||
            (R(t, e) &&
              t.children.length === e.children.length &&
              K.compareFields(t.children, e.children))
          )
        }),
        (C.prototype.visitStruct = function(t, e) {
          return (
            t === e ||
            (R(t, e) &&
              t.children.length === e.children.length &&
              K.compareFields(t.children, e.children))
          )
        }),
        (C.prototype.visitUnion = W),
        (C.prototype.visitDenseUnion = W),
        (C.prototype.visitSparseUnion = W),
        (C.prototype.visitDictionary = function(t, e) {
          return (
            t === e ||
            (R(t, e) &&
              t.id === e.id &&
              t.isOrdered === e.isOrdered &&
              K.visit(t.indices, e.indices) &&
              K.visit(t.dictionary, e.dictionary))
          )
        }),
        (C.prototype.visitInterval = H),
        (C.prototype.visitIntervalDayTime = H),
        (C.prototype.visitIntervalYearMonth = H),
        (C.prototype.visitFixedSizeList = function(t, e) {
          return (
            t === e ||
            (R(t, e) &&
              t.listSize === e.listSize &&
              t.children.length === e.children.length &&
              K.compareFields(t.children, e.children))
          )
        }),
        (C.prototype.visitMap = function(t, e) {
          return (
            t === e ||
            (R(t, e) &&
              t.keysSorted === e.keysSorted &&
              t.children.length === e.children.length &&
              K.compareFields(t.children, e.children))
          )
        })
      const K = new C()
      class J {
        static isNull(t) {
          return t && t.typeId === b.Null
        }
        static isInt(t) {
          return t && t.typeId === b.Int
        }
        static isFloat(t) {
          return t && t.typeId === b.Float
        }
        static isBinary(t) {
          return t && t.typeId === b.Binary
        }
        static isUtf8(t) {
          return t && t.typeId === b.Utf8
        }
        static isBool(t) {
          return t && t.typeId === b.Bool
        }
        static isDecimal(t) {
          return t && t.typeId === b.Decimal
        }
        static isDate(t) {
          return t && t.typeId === b.Date
        }
        static isTime(t) {
          return t && t.typeId === b.Time
        }
        static isTimestamp(t) {
          return t && t.typeId === b.Timestamp
        }
        static isInterval(t) {
          return t && t.typeId === b.Interval
        }
        static isList(t) {
          return t && t.typeId === b.List
        }
        static isStruct(t) {
          return t && t.typeId === b.Struct
        }
        static isUnion(t) {
          return t && t.typeId === b.Union
        }
        static isFixedSizeBinary(t) {
          return t && t.typeId === b.FixedSizeBinary
        }
        static isFixedSizeList(t) {
          return t && t.typeId === b.FixedSizeList
        }
        static isMap(t) {
          return t && t.typeId === b.Map
        }
        static isDictionary(t) {
          return t && t.typeId === b.Dictionary
        }
        get typeId() {
          return b.NONE
        }
        compareTo(t) {
          return K.visit(this, t)
        }
      }
      J[Symbol.toStringTag] = (t => (
        (t.children = null),
        (t.ArrayType = Array),
        (t[Symbol.toStringTag] = "DataType")
      ))(J.prototype)
      class G extends J {
        toString() {
          return "Null"
        }
        get typeId() {
          return b.Null
        }
      }
      G[Symbol.toStringTag] = (t =>
        (G.prototype[Symbol.toStringTag] = "Null"))()
      class q extends J {
        constructor(t, e) {
          super(), (this.isSigned = t), (this.bitWidth = e)
        }
        get typeId() {
          return b.Int
        }
        get ArrayType() {
          switch (this.bitWidth) {
            case 8:
              return this.isSigned ? Int8Array : Uint8Array
            case 16:
              return this.isSigned ? Int16Array : Uint16Array
            case 32:
            case 64:
              return this.isSigned ? Int32Array : Uint32Array
          }
          throw Error(`Unrecognized ${this[Symbol.toStringTag]} type`)
        }
        toString() {
          return `${this.isSigned ? "I" : "Ui"}nt${this.bitWidth}`
        }
      }
      q[Symbol.toStringTag] = (t => (
        (t.isSigned = null),
        (t.bitWidth = null),
        (t[Symbol.toStringTag] = "Int")
      ))(q.prototype)
      class Z extends q {
        constructor() {
          super(!0, 8)
        }
      }
      class X extends q {
        constructor() {
          super(!0, 16)
        }
      }
      class Q extends q {
        constructor() {
          super(!0, 32)
        }
      }
      class tt extends q {
        constructor() {
          super(!0, 64)
        }
      }
      class et extends q {
        constructor() {
          super(!1, 8)
        }
      }
      class rt extends q {
        constructor() {
          super(!1, 16)
        }
      }
      class nt extends q {
        constructor() {
          super(!1, 32)
        }
      }
      class it extends q {
        constructor() {
          super(!1, 64)
        }
      }
      Object.defineProperty(Z.prototype, "ArrayType", { value: Int8Array }),
        Object.defineProperty(X.prototype, "ArrayType", { value: Int16Array }),
        Object.defineProperty(Q.prototype, "ArrayType", { value: Int32Array }),
        Object.defineProperty(tt.prototype, "ArrayType", {
          value: Int32Array,
        }),
        Object.defineProperty(et.prototype, "ArrayType", {
          value: Uint8Array,
        }),
        Object.defineProperty(rt.prototype, "ArrayType", {
          value: Uint16Array,
        }),
        Object.defineProperty(nt.prototype, "ArrayType", {
          value: Uint32Array,
        }),
        Object.defineProperty(it.prototype, "ArrayType", {
          value: Uint32Array,
        })
      class st extends J {
        constructor(t) {
          super(), (this.precision = t)
        }
        get typeId() {
          return b.Float
        }
        get ArrayType() {
          switch (this.precision) {
            case v.HALF:
              return Uint16Array
            case v.SINGLE:
              return Float32Array
            case v.DOUBLE:
              return Float64Array
          }
          throw Error(`Unrecognized ${this[Symbol.toStringTag]} type`)
        }
        toString() {
          return `Float${this.precision << 5 || 16}`
        }
      }
      st[Symbol.toStringTag] = (t => (
        (t.precision = null), (t[Symbol.toStringTag] = "Float")
      ))(st.prototype)
      class ot extends st {
        constructor() {
          super(v.HALF)
        }
      }
      class at extends st {
        constructor() {
          super(v.SINGLE)
        }
      }
      class ut extends st {
        constructor() {
          super(v.DOUBLE)
        }
      }
      Object.defineProperty(ot.prototype, "ArrayType", { value: Uint16Array }),
        Object.defineProperty(at.prototype, "ArrayType", {
          value: Float32Array,
        }),
        Object.defineProperty(ut.prototype, "ArrayType", {
          value: Float64Array,
        })
      class ct extends J {
        constructor() {
          super()
        }
        get typeId() {
          return b.Binary
        }
        toString() {
          return "Binary"
        }
      }
      ct[Symbol.toStringTag] = (t => (
        (t.ArrayType = Uint8Array), (t[Symbol.toStringTag] = "Binary")
      ))(ct.prototype)
      class lt extends J {
        constructor() {
          super()
        }
        get typeId() {
          return b.Utf8
        }
        toString() {
          return "Utf8"
        }
      }
      lt[Symbol.toStringTag] = (t => (
        (t.ArrayType = Uint8Array), (t[Symbol.toStringTag] = "Utf8")
      ))(lt.prototype)
      class ht extends J {
        constructor() {
          super()
        }
        get typeId() {
          return b.Bool
        }
        toString() {
          return "Bool"
        }
      }
      ht[Symbol.toStringTag] = (t => (
        (t.ArrayType = Uint8Array), (t[Symbol.toStringTag] = "Bool")
      ))(ht.prototype)
      class dt extends J {
        constructor(t, e) {
          super(), (this.scale = t), (this.precision = e)
        }
        get typeId() {
          return b.Decimal
        }
        toString() {
          return `Decimal[${this.precision}e${this.scale > 0 ? "+" : ""}${
            this.scale
          }]`
        }
      }
      dt[Symbol.toStringTag] = (t => (
        (t.scale = null),
        (t.precision = null),
        (t.ArrayType = Uint32Array),
        (t[Symbol.toStringTag] = "Decimal")
      ))(dt.prototype)
      class ft extends J {
        constructor(t) {
          super(), (this.unit = t)
        }
        get typeId() {
          return b.Date
        }
        toString() {
          return `Date${32 * (this.unit + 1)}<${m[this.unit]}>`
        }
      }
      ft[Symbol.toStringTag] = (t => (
        (t.unit = null),
        (t.ArrayType = Int32Array),
        (t[Symbol.toStringTag] = "Date")
      ))(ft.prototype)
      class pt extends ft {
        constructor() {
          super(m.DAY)
        }
      }
      class yt extends ft {
        constructor() {
          super(m.MILLISECOND)
        }
      }
      class bt extends J {
        constructor(t, e) {
          super(), (this.unit = t), (this.bitWidth = e)
        }
        get typeId() {
          return b.Time
        }
        toString() {
          return `Time${this.bitWidth}<${w[this.unit]}>`
        }
      }
      bt[Symbol.toStringTag] = (t => (
        (t.unit = null),
        (t.bitWidth = null),
        (t.ArrayType = Int32Array),
        (t[Symbol.toStringTag] = "Time")
      ))(bt.prototype)
      class gt extends bt {
        constructor() {
          super(w.SECOND, 32)
        }
      }
      class _t extends bt {
        constructor() {
          super(w.MILLISECOND, 32)
        }
      }
      class mt extends bt {
        constructor() {
          super(w.MICROSECOND, 64)
        }
      }
      class wt extends bt {
        constructor() {
          super(w.NANOSECOND, 64)
        }
      }
      class vt extends J {
        constructor(t, e) {
          super(), (this.unit = t), (this.timezone = e)
        }
        get typeId() {
          return b.Timestamp
        }
        toString() {
          return `Timestamp<${w[this.unit]}${
            this.timezone ? `, ${this.timezone}` : ""
          }>`
        }
      }
      vt[Symbol.toStringTag] = (t => (
        (t.unit = null),
        (t.timezone = null),
        (t.ArrayType = Int32Array),
        (t[Symbol.toStringTag] = "Timestamp")
      ))(vt.prototype)
      class It extends vt {
        constructor(t) {
          super(w.SECOND, t)
        }
      }
      class At extends vt {
        constructor(t) {
          super(w.MILLISECOND, t)
        }
      }
      class Bt extends vt {
        constructor(t) {
          super(w.MICROSECOND, t)
        }
      }
      class St extends vt {
        constructor(t) {
          super(w.NANOSECOND, t)
        }
      }
      class Tt extends J {
        constructor(t) {
          super(), (this.unit = t)
        }
        get typeId() {
          return b.Interval
        }
        toString() {
          return `Interval<${A[this.unit]}>`
        }
      }
      Tt[Symbol.toStringTag] = (t => (
        (t.unit = null),
        (t.ArrayType = Int32Array),
        (t[Symbol.toStringTag] = "Interval")
      ))(Tt.prototype)
      class Ot extends Tt {
        constructor() {
          super(A.DAY_TIME)
        }
      }
      class Dt extends Tt {
        constructor() {
          super(A.YEAR_MONTH)
        }
      }
      class Ut extends J {
        constructor(t) {
          super(), (this.children = [t])
        }
        get typeId() {
          return b.List
        }
        toString() {
          return `List<${this.valueType}>`
        }
        get valueType() {
          return this.children[0].type
        }
        get valueField() {
          return this.children[0]
        }
        get ArrayType() {
          return this.valueType.ArrayType
        }
      }
      Ut[Symbol.toStringTag] = (t => (
        (t.children = null), (t[Symbol.toStringTag] = "List")
      ))(Ut.prototype)
      class Lt extends J {
        constructor(t) {
          super(), (this.children = t)
        }
        get typeId() {
          return b.Struct
        }
        toString() {
          return `Struct<{${this.children
            .map(t => `${t.name}:${t.type}`)
            .join(", ")}}>`
        }
      }
      Lt[Symbol.toStringTag] = (t => (
        (t.children = null), (t[Symbol.toStringTag] = "Struct")
      ))(Lt.prototype)
      class Ft extends J {
        constructor(t, e, r) {
          super(),
            (this.mode = t),
            (this.children = r),
            (this.typeIds = e = Int32Array.from(e)),
            (this.typeIdToChildIndex = e.reduce(
              (t, e, r) => ((t[e] = r) && t) || t,
              Object.create(null)
            ))
        }
        get typeId() {
          return b.Union
        }
        toString() {
          return `${this[Symbol.toStringTag]}<${this.children
            .map(t => `${t.type}`)
            .join(" | ")}>`
        }
      }
      Ft[Symbol.toStringTag] = (t => (
        (t.mode = null),
        (t.typeIds = null),
        (t.children = null),
        (t.typeIdToChildIndex = null),
        (t.ArrayType = Int8Array),
        (t[Symbol.toStringTag] = "Union")
      ))(Ft.prototype)
      class xt extends Ft {
        constructor(t, e) {
          super(I.Dense, t, e)
        }
      }
      class Mt extends Ft {
        constructor(t, e) {
          super(I.Sparse, t, e)
        }
      }
      class Et extends J {
        constructor(t) {
          super(), (this.byteWidth = t)
        }
        get typeId() {
          return b.FixedSizeBinary
        }
        toString() {
          return `FixedSizeBinary[${this.byteWidth}]`
        }
      }
      Et[Symbol.toStringTag] = (t => (
        (t.byteWidth = null),
        (t.ArrayType = Uint8Array),
        (t[Symbol.toStringTag] = "FixedSizeBinary")
      ))(Et.prototype)
      class Nt extends J {
        constructor(t, e) {
          super(), (this.listSize = t), (this.children = [e])
        }
        get typeId() {
          return b.FixedSizeList
        }
        get valueType() {
          return this.children[0].type
        }
        get valueField() {
          return this.children[0]
        }
        get ArrayType() {
          return this.valueType.ArrayType
        }
        toString() {
          return `FixedSizeList[${this.listSize}]<${this.valueType}>`
        }
      }
      Nt[Symbol.toStringTag] = (t => (
        (t.children = null),
        (t.listSize = null),
        (t[Symbol.toStringTag] = "FixedSizeList")
      ))(Nt.prototype)
      class Vt extends J {
        constructor(t, e = !1) {
          super(), (this.children = [t]), (this.keysSorted = e)
        }
        get typeId() {
          return b.Map
        }
        get keyType() {
          return this.children[0].type.children[0].type
        }
        get valueType() {
          return this.children[0].type.children[1].type
        }
        toString() {
          return `Map<{${this.children[0].type.children
            .map(t => `${t.name}:${t.type}`)
            .join(", ")}}>`
        }
      }
      Vt[Symbol.toStringTag] = (t => (
        (t.children = null),
        (t.keysSorted = null),
        (t[Symbol.toStringTag] = "Map_")
      ))(Vt.prototype)
      const Ct = (t => () => ++t)(-1)
      class Rt extends J {
        constructor(t, e, r, n) {
          super(),
            (this.indices = e),
            (this.dictionary = t),
            (this.isOrdered = n || !1),
            (this.id = null == r ? Ct() : "number" == typeof r ? r : r.low)
        }
        get typeId() {
          return b.Dictionary
        }
        get children() {
          return this.dictionary.children
        }
        get valueType() {
          return this.dictionary
        }
        get ArrayType() {
          return this.dictionary.ArrayType
        }
        toString() {
          return `Dictionary<${this.indices}, ${this.dictionary}>`
        }
      }
      function jt(t) {
        let e = t
        switch (t.typeId) {
          case b.Decimal:
            return 4
          case b.Timestamp:
            return 2
          case b.Date:
          case b.Interval:
            return 1 + e.unit
          case b.Int:
          case b.Time:
            return +(e.bitWidth > 32) + 1
          case b.FixedSizeList:
            return e.listSize
          case b.FixedSizeBinary:
            return e.byteWidth
          default:
            return 1
        }
      }
      Rt[Symbol.toStringTag] = (t => (
        (t.id = null),
        (t.indices = null),
        (t.isOrdered = null),
        (t.dictionary = null),
        (t[Symbol.toStringTag] = "Dictionary")
      ))(Rt.prototype)
      var kt = r(0)
      const zt = -1
      class Pt {
        constructor(t, e, r, n, i, s, o) {
          let a
          ;(this.type = t),
            (this.dictionary = o),
            (this.offset = Math.floor(Math.max(e || 0, 0))),
            (this.length = Math.floor(Math.max(r || 0, 0))),
            (this._nullCount = Math.floor(Math.max(n || 0, -1))),
            (this.childData = (s || []).map(t =>
              t instanceof Pt ? t : t.data
            )),
            i instanceof Pt
              ? ((this.stride = i.stride),
                (this.values = i.values),
                (this.typeIds = i.typeIds),
                (this.nullBitmap = i.nullBitmap),
                (this.valueOffsets = i.valueOffsets))
              : ((this.stride = jt(t)),
                i &&
                  ((a = i[0]) && (this.valueOffsets = a),
                  (a = i[1]) && (this.values = a),
                  (a = i[2]) && (this.nullBitmap = a),
                  (a = i[3]) && (this.typeIds = a)))
        }
        get typeId() {
          return this.type.typeId
        }
        get ArrayType() {
          return this.type.ArrayType
        }
        get buffers() {
          return [
            this.valueOffsets,
            this.values,
            this.nullBitmap,
            this.typeIds,
          ]
        }
        get byteLength() {
          let t = 0,
            { valueOffsets: e, values: r, nullBitmap: n, typeIds: i } = this
          return (
            e && (t += e.byteLength),
            r && (t += r.byteLength),
            n && (t += n.byteLength),
            i && (t += i.byteLength),
            this.childData.reduce((t, e) => t + e.byteLength, t)
          )
        }
        get nullCount() {
          let t,
            e = this._nullCount
          return (
            e <= zt &&
              (t = this.nullBitmap) &&
              (this._nullCount = e =
                this.length - x(t, this.offset, this.offset + this.length)),
            e
          )
        }
        clone(
          t,
          e = this.offset,
          r = this.length,
          n = this._nullCount,
          i = this,
          s = this.childData
        ) {
          return new Pt(t, e, r, n, i, s, this.dictionary)
        }
        slice(t, e) {
          const { stride: r, typeId: n, childData: i } = this,
            s = +(0 === this._nullCount) - 1,
            o = 16 === n ? r : 1,
            a = this._sliceBuffers(t, e, r, n)
          return this.clone(
            this.type,
            this.offset + t,
            e,
            s,
            a,
            !i.length || this.valueOffsets
              ? i
              : this._sliceChildren(i, o * t, o * e)
          )
        }
        _changeLengthAndBackfillNullBitmap(t) {
          if (this.typeId === b.Null) return this.clone(this.type, 0, t, 0)
          const { length: e, nullCount: r } = this,
            n = new Uint8Array(((t + 63) & -64) >> 3).fill(255, 0, e >> 3)
          ;(n[e >> 3] = (1 << (e - (-8 & e))) - 1),
            r > 0 && n.set(U(this.offset, e, this.nullBitmap), 0)
          const i = this.buffers
          return (
            (i[g.VALIDITY] = n), this.clone(this.type, 0, t, r + (t - e), i)
          )
        }
        _sliceBuffers(t, e, r, n) {
          let i,
            { buffers: s } = this
          return (
            (i = s[g.TYPE]) && (s[g.TYPE] = i.subarray(t, t + e)),
            ((i = s[g.OFFSET]) && (s[g.OFFSET] = i.subarray(t, t + e + 1))) ||
              ((i = s[g.DATA]) &&
                (s[g.DATA] = 6 === n ? i : i.subarray(r * t, r * (t + e)))),
            s
          )
        }
        _sliceChildren(t, e, r) {
          return t.map(t => t.slice(e, r))
        }
        static new(t, e, r, n, i, s, o) {
          switch (
            (i instanceof Pt ? (i = i.buffers) : i || (i = []), t.typeId)
          ) {
            case b.Null:
              return Pt.Null(t, e, r)
            case b.Int:
              return Pt.Int(t, e, r, n || 0, i[g.VALIDITY], i[g.DATA] || [])
            case b.Dictionary:
              return Pt.Dictionary(
                t,
                e,
                r,
                n || 0,
                i[g.VALIDITY],
                i[g.DATA] || [],
                o
              )
            case b.Float:
              return Pt.Float(t, e, r, n || 0, i[g.VALIDITY], i[g.DATA] || [])
            case b.Bool:
              return Pt.Bool(t, e, r, n || 0, i[g.VALIDITY], i[g.DATA] || [])
            case b.Decimal:
              return Pt.Decimal(
                t,
                e,
                r,
                n || 0,
                i[g.VALIDITY],
                i[g.DATA] || []
              )
            case b.Date:
              return Pt.Date(t, e, r, n || 0, i[g.VALIDITY], i[g.DATA] || [])
            case b.Time:
              return Pt.Time(t, e, r, n || 0, i[g.VALIDITY], i[g.DATA] || [])
            case b.Timestamp:
              return Pt.Timestamp(
                t,
                e,
                r,
                n || 0,
                i[g.VALIDITY],
                i[g.DATA] || []
              )
            case b.Interval:
              return Pt.Interval(
                t,
                e,
                r,
                n || 0,
                i[g.VALIDITY],
                i[g.DATA] || []
              )
            case b.FixedSizeBinary:
              return Pt.FixedSizeBinary(
                t,
                e,
                r,
                n || 0,
                i[g.VALIDITY],
                i[g.DATA] || []
              )
            case b.Binary:
              return Pt.Binary(
                t,
                e,
                r,
                n || 0,
                i[g.VALIDITY],
                i[g.OFFSET] || [],
                i[g.DATA] || []
              )
            case b.Utf8:
              return Pt.Utf8(
                t,
                e,
                r,
                n || 0,
                i[g.VALIDITY],
                i[g.OFFSET] || [],
                i[g.DATA] || []
              )
            case b.List:
              return Pt.List(
                t,
                e,
                r,
                n || 0,
                i[g.VALIDITY],
                i[g.OFFSET] || [],
                (s || [])[0]
              )
            case b.FixedSizeList:
              return Pt.FixedSizeList(
                t,
                e,
                r,
                n || 0,
                i[g.VALIDITY],
                (s || [])[0]
              )
            case b.Struct:
              return Pt.Struct(t, e, r, n || 0, i[g.VALIDITY], s || [])
            case b.Map:
              return Pt.Map(
                t,
                e,
                r,
                n || 0,
                i[g.VALIDITY],
                i[g.OFFSET] || [],
                (s || [])[0]
              )
            case b.Union:
              return Pt.Union(
                t,
                e,
                r,
                n || 0,
                i[g.VALIDITY],
                i[g.TYPE] || [],
                i[g.OFFSET] || s,
                s
              )
          }
          throw Error(`Unrecognized typeId ${t.typeId}`)
        }
        static Null(t, e, r) {
          return new Pt(t, e, r, 0)
        }
        static Int(t, e, r, n, i, s) {
          return new Pt(t, e, r, n, [
            void 0,
            Object(kt.toArrayBufferView)(t.ArrayType, s),
            Object(kt.toUint8Array)(i),
          ])
        }
        static Dictionary(t, e, r, n, i, s, o) {
          return new Pt(
            t,
            e,
            r,
            n,
            [
              void 0,
              Object(kt.toArrayBufferView)(t.indices.ArrayType, s),
              Object(kt.toUint8Array)(i),
            ],
            [],
            o
          )
        }
        static Float(t, e, r, n, i, s) {
          return new Pt(t, e, r, n, [
            void 0,
            Object(kt.toArrayBufferView)(t.ArrayType, s),
            Object(kt.toUint8Array)(i),
          ])
        }
        static Bool(t, e, r, n, i, s) {
          return new Pt(t, e, r, n, [
            void 0,
            Object(kt.toArrayBufferView)(t.ArrayType, s),
            Object(kt.toUint8Array)(i),
          ])
        }
        static Decimal(t, e, r, n, i, s) {
          return new Pt(t, e, r, n, [
            void 0,
            Object(kt.toArrayBufferView)(t.ArrayType, s),
            Object(kt.toUint8Array)(i),
          ])
        }
        static Date(t, e, r, n, i, s) {
          return new Pt(t, e, r, n, [
            void 0,
            Object(kt.toArrayBufferView)(t.ArrayType, s),
            Object(kt.toUint8Array)(i),
          ])
        }
        static Time(t, e, r, n, i, s) {
          return new Pt(t, e, r, n, [
            void 0,
            Object(kt.toArrayBufferView)(t.ArrayType, s),
            Object(kt.toUint8Array)(i),
          ])
        }
        static Timestamp(t, e, r, n, i, s) {
          return new Pt(t, e, r, n, [
            void 0,
            Object(kt.toArrayBufferView)(t.ArrayType, s),
            Object(kt.toUint8Array)(i),
          ])
        }
        static Interval(t, e, r, n, i, s) {
          return new Pt(t, e, r, n, [
            void 0,
            Object(kt.toArrayBufferView)(t.ArrayType, s),
            Object(kt.toUint8Array)(i),
          ])
        }
        static FixedSizeBinary(t, e, r, n, i, s) {
          return new Pt(t, e, r, n, [
            void 0,
            Object(kt.toArrayBufferView)(t.ArrayType, s),
            Object(kt.toUint8Array)(i),
          ])
        }
        static Binary(t, e, r, n, i, s, o) {
          return new Pt(t, e, r, n, [
            Object(kt.toInt32Array)(s),
            Object(kt.toUint8Array)(o),
            Object(kt.toUint8Array)(i),
          ])
        }
        static Utf8(t, e, r, n, i, s, o) {
          return new Pt(t, e, r, n, [
            Object(kt.toInt32Array)(s),
            Object(kt.toUint8Array)(o),
            Object(kt.toUint8Array)(i),
          ])
        }
        static List(t, e, r, n, i, s, o) {
          return new Pt(
            t,
            e,
            r,
            n,
            [Object(kt.toInt32Array)(s), void 0, Object(kt.toUint8Array)(i)],
            [o]
          )
        }
        static FixedSizeList(t, e, r, n, i, s) {
          return new Pt(
            t,
            e,
            r,
            n,
            [void 0, void 0, Object(kt.toUint8Array)(i)],
            [s]
          )
        }
        static Struct(t, e, r, n, i, s) {
          return new Pt(
            t,
            e,
            r,
            n,
            [void 0, void 0, Object(kt.toUint8Array)(i)],
            s
          )
        }
        static Map(t, e, r, n, i, s, o) {
          return new Pt(
            t,
            e,
            r,
            n,
            [Object(kt.toInt32Array)(s), void 0, Object(kt.toUint8Array)(i)],
            [o]
          )
        }
        static Union(t, e, r, n, i, s, o, a) {
          const u = [
            void 0,
            void 0,
            Object(kt.toUint8Array)(i),
            Object(kt.toArrayBufferView)(t.ArrayType, s),
          ]
          return t.mode === I.Sparse
            ? new Pt(t, e, r, n, u, o)
            : ((u[g.OFFSET] = Object(kt.toInt32Array)(o)),
              new Pt(t, e, r, n, u, a))
        }
      }
      Pt.prototype.childData = Object.freeze([])
      const Yt = void 0
      function $t(t) {
        if (null === t) return "null"
        if (t === Yt) return "undefined"
        switch (typeof t) {
          case "number":
          case "bigint":
            return `${t}`
          case "string":
            return `"${t}"`
        }
        return "function" == typeof t[Symbol.toPrimitive]
          ? t[Symbol.toPrimitive]("string")
          : ArrayBuffer.isView(t)
          ? `[${t}]`
          : JSON.stringify(t)
      }
      var Wt = r(1)
      function Ht(t) {
        if (!t || t.length <= 0)
          return function(t) {
            return !0
          }
        let e = "",
          r = t.filter(t => t == t)
        return (
          r.length > 0 &&
            (e = `\n    switch (x) {${r
              .map(
                t =>
                  `\n        case ${(function(t) {
                    if ("bigint" != typeof t) return $t(t)
                    if (Wt.c) return `${$t(t)}n`
                    return `"${$t(t)}"`
                  })(t)}:`
              )
              .join("")}\n            return false;\n    }`),
          t.length !== r.length && (e = `if (x !== x) return false;\n${e}`),
          Function("x", `${e}\nreturn true;`)
        )
      }
      const Kt = (t, e) => ((t * e + 63) & -64 || 64) / e,
        Jt = (t, e = 0) =>
          t.length >= e
            ? t.subarray(0, e)
            : Object(kt.memcpy)(new t.constructor(e), t, 0)
      class Gt {
        constructor(t, e = 1) {
          ;(this.buffer = t),
            (this.stride = e),
            (this.BYTES_PER_ELEMENT = t.BYTES_PER_ELEMENT),
            (this.ArrayType = t.constructor),
            this._resize((this.length = (t.length / e) | 0))
        }
        get byteLength() {
          return (this.length * this.stride * this.BYTES_PER_ELEMENT) | 0
        }
        get reservedLength() {
          return this.buffer.length / this.stride
        }
        get reservedByteLength() {
          return this.buffer.byteLength
        }
        set(t, e) {
          return this
        }
        append(t) {
          return this.set(this.length, t)
        }
        reserve(t) {
          if (t > 0) {
            this.length += t
            const e = this.stride,
              r = this.length * e,
              n = this.buffer.length
            r >= n &&
              this._resize(Kt(0 === n ? 1 * r : 2 * r, this.BYTES_PER_ELEMENT))
          }
          return this
        }
        flush(t = this.length) {
          t = Kt(t * this.stride, this.BYTES_PER_ELEMENT)
          const e = Jt(this.buffer, t)
          return this.clear(), e
        }
        clear() {
          return (this.length = 0), this._resize(0), this
        }
        _resize(t) {
          return (this.buffer = Object(kt.memcpy)(
            new this.ArrayType(t),
            this.buffer
          ))
        }
      }
      Gt.prototype.offset = 0
      class qt extends Gt {
        last() {
          return this.get(this.length - 1)
        }
        get(t) {
          return this.buffer[t]
        }
        set(t, e) {
          return (
            this.reserve(t - this.length + 1),
            (this.buffer[t * this.stride] = e),
            this
          )
        }
      }
      class Zt extends qt {
        constructor(t = new Uint8Array(0)) {
          super(t, 1 / 8), (this.numValid = 0)
        }
        get numInvalid() {
          return this.length - this.numValid
        }
        get(t) {
          return (this.buffer[t >> 3] >> t % 8) & 1
        }
        set(t, e) {
          const { buffer: r } = this.reserve(t - this.length + 1),
            n = t >> 3,
            i = t % 8,
            s = (r[n] >> i) & 1
          return (
            e
              ? 0 === s && ((r[n] |= 1 << i), ++this.numValid)
              : 1 === s && ((r[n] &= ~(1 << i)), --this.numValid),
            this
          )
        }
        clear() {
          return (this.numValid = 0), super.clear()
        }
      }
      class Xt extends qt {
        constructor(t = new Int32Array(1)) {
          super(t, 1)
        }
        append(t) {
          return this.set(this.length - 1, t)
        }
        set(t, e) {
          const r = this.length - 1,
            n = this.reserve(t - r + 1).buffer
          return r < t++ && n.fill(n[r], r, t), (n[t] = n[t - 1] + e), this
        }
        flush(t = this.length - 1) {
          return t > this.length && this.set(t - 1, 0), super.flush(t + 1)
        }
      }
      class Qt extends Gt {
        get ArrayType64() {
          return (
            this._ArrayType64 ||
            (this._ArrayType64 =
              this.buffer instanceof Int32Array ? Wt.b : Wt.d)
          )
        }
        set(t, e) {
          switch ((this.reserve(t - this.length + 1), typeof e)) {
            case "bigint":
              this.buffer64[t] = e
              break
            case "number":
              this.buffer[t * this.stride] = e
              break
            default:
              this.buffer.set(e, t * this.stride)
          }
          return this
        }
        _resize(t) {
          const e = super._resize(t),
            r = e.byteLength / (this.BYTES_PER_ELEMENT * this.stride)
          return (
            Wt.c &&
              (this.buffer64 = new this.ArrayType64(
                e.buffer,
                e.byteOffset,
                r
              )),
            e
          )
        }
      }
      class te {
        constructor({ type: t, nullValues: e }) {
          ;(this.length = 0),
            (this.finished = !1),
            (this.type = t),
            (this.children = []),
            (this.nullValues = e),
            (this.stride = jt(t)),
            (this._nulls = new Zt()),
            e && e.length > 0 && (this._isValid = Ht(e))
        }
        static new(t) {}
        static throughNode(t) {
          throw Error('"throughNode" not available in this environment')
        }
        static throughDOM(t) {
          throw Error('"throughDOM" not available in this environment')
        }
        static throughIterable(t) {
          return (function(t) {
            const { queueingStrategy: e = "count" } = t,
              { highWaterMark: r = "bytes" !== e ? 1e3 : 16384 } = t,
              n = "bytes" !== e ? "length" : "byteLength"
            return function*(e) {
              let i = 0,
                s = te.new(t)
              for (const t of e)
                s.append(t)[n] >= r && ++i && (yield s.toVector())
              ;(s.finish().length > 0 || 0 === i) && (yield s.toVector())
            }
          })(t)
        }
        static throughAsyncIterable(t) {
          return (function(t) {
            const { queueingStrategy: e = "count" } = t,
              { highWaterMark: r = "bytes" !== e ? 1e3 : 16384 } = t,
              n = "bytes" !== e ? "length" : "byteLength"
            return async function*(e) {
              let i = 0,
                s = te.new(t)
              for await (const t of e)
                s.append(t)[n] >= r && ++i && (yield s.toVector())
              ;(s.finish().length > 0 || 0 === i) && (yield s.toVector())
            }
          })(t)
        }
        toVector() {
          return y.new(this.flush())
        }
        get ArrayType() {
          return this.type.ArrayType
        }
        get nullCount() {
          return this._nulls.numInvalid
        }
        get numChildren() {
          return this.children.length
        }
        get byteLength() {
          let t = 0
          return (
            this._offsets && (t += this._offsets.byteLength),
            this._values && (t += this._values.byteLength),
            this._nulls && (t += this._nulls.byteLength),
            this._typeIds && (t += this._typeIds.byteLength),
            this.children.reduce((t, e) => t + e.byteLength, t)
          )
        }
        get reservedLength() {
          return this._nulls.reservedLength
        }
        get reservedByteLength() {
          let t = 0
          return (
            this._offsets && (t += this._offsets.reservedByteLength),
            this._values && (t += this._values.reservedByteLength),
            this._nulls && (t += this._nulls.reservedByteLength),
            this._typeIds && (t += this._typeIds.reservedByteLength),
            this.children.reduce((t, e) => t + e.reservedByteLength, t)
          )
        }
        get valueOffsets() {
          return this._offsets ? this._offsets.buffer : null
        }
        get values() {
          return this._values ? this._values.buffer : null
        }
        get nullBitmap() {
          return this._nulls ? this._nulls.buffer : null
        }
        get typeIds() {
          return this._typeIds ? this._typeIds.buffer : null
        }
        append(t) {
          return this.set(this.length, t)
        }
        isValid(t) {
          return this._isValid(t)
        }
        set(t, e) {
          return this.setValid(t, this.isValid(e)) && this.setValue(t, e), this
        }
        setValue(t, e) {
          this._setValue(this, t, e)
        }
        setValid(t, e) {
          return (this.length = this._nulls.set(t, +e).length), e
        }
        addChild(t, e = `${this.numChildren}`) {
          throw Error(
            `Cannot append children to non-nested type "${this.type}"`
          )
        }
        getChildAt(t) {
          return this.children[t] || null
        }
        flush() {
          const t = [],
            e = this._values,
            r = this._offsets,
            n = this._typeIds,
            { length: i, nullCount: s } = this
          n
            ? ((t[g.TYPE] = n.flush(i)), r && (t[g.OFFSET] = r.flush(i)))
            : r
            ? (e && (t[g.DATA] = e.flush(r.last())),
              (t[g.OFFSET] = r.flush(i)))
            : e && (t[g.DATA] = e.flush(i)),
            s > 0 && (t[g.VALIDITY] = this._nulls.flush(i))
          const o = Pt.new(
            this.type,
            0,
            i,
            s,
            t,
            this.children.map(t => t.flush())
          )
          return this.clear(), o
        }
        finish() {
          return (
            (this.finished = !0), this.children.forEach(t => t.finish()), this
          )
        }
        clear() {
          return (
            (this.length = 0),
            this._offsets && this._offsets.clear(),
            this._values && this._values.clear(),
            this._nulls && this._nulls.clear(),
            this._typeIds && this._typeIds.clear(),
            this.children.forEach(t => t.clear()),
            this
          )
        }
      }
      ;(te.prototype.length = 1),
        (te.prototype.stride = 1),
        (te.prototype.children = null),
        (te.prototype.finished = !1),
        (te.prototype.nullValues = null),
        (te.prototype._isValid = () => !0)
      class ee extends te {
        constructor(t) {
          super(t), (this._values = new qt(new this.ArrayType(0), this.stride))
        }
        setValue(t, e) {
          const r = this._values
          return r.reserve(t - r.length + 1), super.setValue(t, e)
        }
      }
      class re extends te {
        constructor(t) {
          super(t), (this._pendingLength = 0), (this._offsets = new Xt())
        }
        setValue(t, e) {
          const r = this._pending || (this._pending = new Map()),
            n = r.get(t)
          n && (this._pendingLength -= n.length),
            (this._pendingLength += e.length),
            r.set(t, e)
        }
        setValid(t, e) {
          return (
            !!super.setValid(t, e) ||
            ((this._pending || (this._pending = new Map())).set(t, void 0), !1)
          )
        }
        clear() {
          return (
            (this._pendingLength = 0), (this._pending = void 0), super.clear()
          )
        }
        flush() {
          return this._flush(), super.flush()
        }
        finish() {
          return this._flush(), super.finish()
        }
        _flush() {
          const t = this._pending,
            e = this._pendingLength
          return (
            (this._pendingLength = 0),
            (this._pending = void 0),
            t && t.size > 0 && this._flushPending(t, e),
            this
          )
        }
      }
      class ne extends te {
        constructor(t) {
          super(t), (this._values = new Zt())
        }
        setValue(t, e) {
          this._values.set(t, +e)
        }
      }
      class ie extends te {
        setValue(t, e) {}
        setValid(t, e) {
          return (this.length = Math.max(t + 1, this.length)), e
        }
      }
      class se extends ee {}
      class oe extends se {}
      class ae extends se {}
      class ue extends ee {}
      class ce extends te {
        constructor({ type: t, nullValues: e, dictionaryHashFunction: r }) {
          super({ type: new Rt(t.dictionary, t.indices, t.id, t.isOrdered) }),
            (this._nulls = null),
            (this._dictionaryOffset = 0),
            (this._keysToIndices = Object.create(null)),
            (this.indices = te.new({
              type: this.type.indices,
              nullValues: e,
            })),
            (this.dictionary = te.new({
              type: this.type.dictionary,
              nullValues: null,
            })),
            "function" == typeof r && (this.valueToKey = r)
        }
        get values() {
          return this.indices.values
        }
        get nullCount() {
          return this.indices.nullCount
        }
        get nullBitmap() {
          return this.indices.nullBitmap
        }
        get byteLength() {
          return this.indices.byteLength + this.dictionary.byteLength
        }
        get reservedLength() {
          return this.indices.reservedLength + this.dictionary.reservedLength
        }
        get reservedByteLength() {
          return (
            this.indices.reservedByteLength +
            this.dictionary.reservedByteLength
          )
        }
        isValid(t) {
          return this.indices.isValid(t)
        }
        setValid(t, e) {
          const r = this.indices
          return (e = r.setValid(t, e)), (this.length = r.length), e
        }
        setValue(t, e) {
          let r = this._keysToIndices,
            n = this.valueToKey(e),
            i = r[n]
          return (
            void 0 === i &&
              (r[n] = i =
                this._dictionaryOffset + this.dictionary.append(e).length - 1),
            this.indices.setValue(t, i)
          )
        }
        flush() {
          const t = this.type,
            e = this._dictionary,
            r = this.dictionary.toVector(),
            n = this.indices.flush().clone(t)
          return (
            (n.dictionary = e ? e.concat(r) : r),
            this.finished || (this._dictionaryOffset += r.length),
            (this._dictionary = n.dictionary),
            this.clear(),
            n
          )
        }
        finish() {
          return (
            this.indices.finish(),
            this.dictionary.finish(),
            (this._dictionaryOffset = 0),
            (this._keysToIndices = Object.create(null)),
            super.finish()
          )
        }
        clear() {
          return this.indices.clear(), this.dictionary.clear(), super.clear()
        }
        valueToKey(t) {
          return "string" == typeof t ? t : `${t}`
        }
      }
      class le extends ee {}
      const he = new Float64Array(1),
        de = new Uint32Array(he.buffer)
      function fe(t) {
        let e = (31744 & t) >> 10,
          r = (1023 & t) / 1024,
          n = (-1) ** ((32768 & t) >> 15)
        switch (e) {
          case 31:
            return n * (r ? NaN : 1 / 0)
          case 0:
            return n * (r ? 6103515625e-14 * r : 0)
        }
        return n * 2 ** (e - 15) * (1 + r)
      }
      function pe(t) {
        if (t != t) return 32256
        he[0] = t
        let e = ((2147483648 & de[1]) >> 16) & 65535,
          r = 2146435072 & de[1],
          n = 0
        return (
          r >= 1089470464
            ? de[0] > 0
              ? (r = 31744)
              : ((r = (2080374784 & r) >> 16), (n = (1048575 & de[1]) >> 10))
            : r <= 1056964608
            ? ((n =
                (1048576 +
                  ((n = 1048576 + (1048575 & de[1])) << ((r >> 20) - 998))) >>
                21),
              (r = 0))
            : ((r = (r - 1056964608) >> 10),
              (n = (512 + (1048575 & de[1])) >> 10)),
          e | r | (65535 & n)
        )
      }
      class ye extends ee {}
      class be extends ye {
        setValue(t, e) {
          this._values.set(t, pe(e))
        }
      }
      class ge extends ye {
        setValue(t, e) {
          this._values.set(t, e)
        }
      }
      class _e extends ye {
        setValue(t, e) {
          this._values.set(t, e)
        }
      }
      const me = Symbol.for("isArrowBigNum")
      function we(t, ...e) {
        return 0 === e.length
          ? Object.setPrototypeOf(
              Object(kt.toArrayBufferView)(this.TypedArray, t),
              this.constructor.prototype
            )
          : Object.setPrototypeOf(
              new this.TypedArray(t, ...e),
              this.constructor.prototype
            )
      }
      function ve(...t) {
        return we.apply(this, t)
      }
      function Ie(...t) {
        return we.apply(this, t)
      }
      function Ae(...t) {
        return we.apply(this, t)
      }
      function Be(t) {
        let e,
          r,
          { buffer: n, byteOffset: i, length: s, signed: o } = t,
          a = new Int32Array(n, i, s),
          u = 0,
          c = 0,
          l = a.length
        for (; c < l; )
          (r = a[c++]),
            (e = a[c++]),
            o || (e >>>= 0),
            (u += (r >>> 0) + e * c ** 32)
        return u
      }
      let Se, Te
      function Oe(t) {
        let e = "",
          r = new Uint32Array(2),
          n = new Uint16Array(t.buffer, t.byteOffset, t.byteLength / 2),
          i = new Uint32Array((n = new Uint16Array(n).reverse()).buffer),
          s = -1,
          o = n.length - 1
        do {
          for (r[0] = n[(s = 0)]; s < o; )
            (n[s++] = r[1] = r[0] / 10),
              (r[0] = ((r[0] - 10 * r[1]) << 16) + n[s])
          ;(n[s] = r[1] = r[0] / 10),
            (r[0] = r[0] - 10 * r[1]),
            (e = `${r[0]}${e}`)
        } while (i[0] || i[1] || i[2] || i[3])
        return e || "0"
      }
      ;(we.prototype[me] = !0),
        (we.prototype.toJSON = function() {
          return `"${Se(this)}"`
        }),
        (we.prototype.valueOf = function() {
          return Be(this)
        }),
        (we.prototype.toString = function() {
          return Se(this)
        }),
        (we.prototype[Symbol.toPrimitive] = function(t = "default") {
          switch (t) {
            case "number":
              return Be(this)
            case "string":
              return Se(this)
            case "default":
              return Te(this)
          }
          return Se(this)
        }),
        Object.setPrototypeOf(
          ve.prototype,
          Object.create(Int32Array.prototype)
        ),
        Object.setPrototypeOf(
          Ie.prototype,
          Object.create(Uint32Array.prototype)
        ),
        Object.setPrototypeOf(
          Ae.prototype,
          Object.create(Uint32Array.prototype)
        ),
        Object.assign(ve.prototype, we.prototype, {
          constructor: ve,
          signed: !0,
          TypedArray: Int32Array,
          BigIntArray: Wt.b,
        }),
        Object.assign(Ie.prototype, we.prototype, {
          constructor: Ie,
          signed: !1,
          TypedArray: Uint32Array,
          BigIntArray: Wt.d,
        }),
        Object.assign(Ae.prototype, we.prototype, {
          constructor: Ae,
          signed: !0,
          TypedArray: Uint32Array,
          BigIntArray: Wt.d,
        }),
        Wt.c
          ? ((Te = t =>
              8 === t.byteLength
                ? new t.BigIntArray(t.buffer, t.byteOffset, 1)[0]
                : Oe(t)),
            (Se = t =>
              8 === t.byteLength
                ? `${new t.BigIntArray(t.buffer, t.byteOffset, 1)[0]}`
                : Oe(t)))
          : (Te = Se = Oe)
      class De {
        constructor(t, e) {
          return De.new(t, e)
        }
        static new(t, e) {
          switch (e) {
            case !0:
              return new ve(t)
            case !1:
              return new Ie(t)
          }
          switch (t.constructor) {
            case Int8Array:
            case Int16Array:
            case Int32Array:
            case Wt.b:
              return new ve(t)
          }
          return 16 === t.byteLength ? new Ae(t) : new Ie(t)
        }
        static signed(t) {
          return new ve(t)
        }
        static unsigned(t) {
          return new Ie(t)
        }
        static decimal(t) {
          return new Ae(t)
        }
      }
      class Ue extends ee {
        setValue(t, e) {
          this._values.set(t, e)
        }
      }
      class Le extends Ue {}
      class Fe extends Ue {}
      class xe extends Ue {}
      class Me extends Ue {
        constructor(t) {
          t.nullValues && (t.nullValues = t.nullValues.map(Re)),
            super(t),
            (this._values = new Qt(new Int32Array(0), 2))
        }
        get values64() {
          return this._values.buffer64
        }
        isValid(t) {
          return super.isValid(Re(t))
        }
      }
      class Ee extends Ue {}
      class Ne extends Ue {}
      class Ve extends Ue {}
      class Ce extends Ue {
        constructor(t) {
          t.nullValues && (t.nullValues = t.nullValues.map(Re)),
            super(t),
            (this._values = new Qt(new Uint32Array(0), 2))
        }
        get values64() {
          return this._values.buffer64
        }
        isValid(t) {
          return super.isValid(Re(t))
        }
      }
      const Re = (t => e => (
        ArrayBuffer.isView(e) &&
          ((t.buffer = e.buffer),
          (t.byteOffset = e.byteOffset),
          (t.byteLength = e.byteLength),
          (e = Te(t)),
          (t.buffer = null)),
        e
      ))({ BigIntArray: Wt.b })
      class je extends ee {}
      class ke extends je {}
      class ze extends je {}
      class Pe extends je {}
      class Ye extends je {}
      class $e extends ee {}
      class We extends $e {}
      class He extends $e {}
      class Ke extends $e {}
      class Je extends $e {}
      class Ge extends ee {}
      class qe extends Ge {}
      class Ze extends Ge {}
      var Xe = r(5)
      class Qe extends re {
        constructor(t) {
          super(t), (this._values = new Gt(new Uint8Array(0)))
        }
        get byteLength() {
          let t = this._pendingLength + 4 * this.length
          return (
            this._offsets && (t += this._offsets.byteLength),
            this._values && (t += this._values.byteLength),
            this._nulls && (t += this._nulls.byteLength),
            t
          )
        }
        setValue(t, e) {
          return super.setValue(t, Object(kt.toUint8Array)(e))
        }
        _flushPending(t, e) {
          const r = this._offsets,
            n = this._values.reserve(e).buffer
          let i,
            s = 0,
            o = 0,
            a = 0
          for ([s, i] of t)
            void 0 === i
              ? r.set(s, 0)
              : ((o = i.length), n.set(i, a), r.set(s, o), (a += o))
        }
      }
      class tr extends re {
        constructor(t) {
          super(t), (this._values = new Gt(new Uint8Array(0)))
        }
        get byteLength() {
          let t = this._pendingLength + 4 * this.length
          return (
            this._offsets && (t += this._offsets.byteLength),
            this._values && (t += this._values.byteLength),
            this._nulls && (t += this._nulls.byteLength),
            t
          )
        }
        setValue(t, e) {
          return super.setValue(t, Object(Xe.b)(e))
        }
        _flushPending(t, e) {}
      }
      tr.prototype._flushPending = Qe.prototype._flushPending
      class er {
        get length() {
          return this._values.length
        }
        get(t) {
          return this._values[t]
        }
        clear() {
          return (this._values = null), this
        }
        bind(t) {
          return t instanceof y ? t : ((this._values = t), this)
        }
      }
      const rr = Symbol.for("parent"),
        nr = Symbol.for("rowIndex"),
        ir = Symbol.for("keyToIdx"),
        sr = Symbol.for("idxToVal"),
        or = Symbol.for("nodejs.util.inspect.custom")
      class ar {
        constructor(t, e) {
          ;(this[rr] = t), (this.size = e)
        }
        entries() {
          return this[Symbol.iterator]()
        }
        has(t) {
          return void 0 !== this.get(t)
        }
        get(t) {
          let e = void 0
          if (null != t) {
            const r = this[ir] || (this[ir] = new Map())
            let n = r.get(t)
            if (void 0 !== n) {
              const t = this[sr] || (this[sr] = Array(this.size))
              void 0 !== (e = t[n]) || (t[n] = e = this.getValue(n))
            } else if ((n = this.getIndex(t)) > -1) {
              r.set(t, n)
              const i = this[sr] || (this[sr] = Array(this.size))
              void 0 !== (e = i[n]) || (i[n] = e = this.getValue(n))
            }
          }
          return e
        }
        set(t, e) {
          if (null != t) {
            const r = this[ir] || (this[ir] = new Map())
            let n = r.get(t)
            if ((void 0 === n && r.set(t, (n = this.getIndex(t))), n > -1)) {
              ;(this[sr] || (this[sr] = Array(this.size)))[n] = this.setValue(
                n,
                e
              )
            }
          }
          return this
        }
        clear() {
          throw Error(`Clearing ${this[Symbol.toStringTag]} not supported.`)
        }
        delete(t) {
          throw Error(
            `Deleting ${this[Symbol.toStringTag]} values not supported.`
          )
        }
        *[Symbol.iterator]() {
          const t = this.keys(),
            e = this.values(),
            r = this[ir] || (this[ir] = new Map()),
            n = this[sr] || (this[sr] = Array(this.size))
          for (
            let i, s, o, a, u = 0;
            !(o = t.next()).done && !(a = e.next()).done;
            ++u
          )
            (i = o.value),
              (s = a.value),
              (n[u] = s),
              r.has(i) || r.set(i, u),
              yield [i, s]
        }
        forEach(t, e) {
          const r = this.keys(),
            n = this.values(),
            i = void 0 === e ? t : (r, n, i) => t.call(e, r, n, i),
            s = this[ir] || (this[ir] = new Map()),
            o = this[sr] || (this[sr] = Array(this.size))
          for (
            let a, u, c, l, h = 0;
            !(c = r.next()).done && !(l = n.next()).done;
            ++h
          )
            (a = c.value),
              (u = l.value),
              (o[h] = u),
              s.has(a) || s.set(a, h),
              i(u, a, this)
        }
        toArray() {
          return [...this.values()]
        }
        toJSON() {
          const t = {}
          return this.forEach((e, r) => (t[r] = e)), t
        }
        inspect() {
          return this.toString()
        }
        [or]() {
          return this.toString()
        }
        toString() {
          const t = []
          return (
            this.forEach((e, r) => {
              ;(r = $t(r)), (e = $t(e)), t.push(`${r}: ${e}`)
            }),
            `{ ${t.join(", ")} }`
          )
        }
      }
      ar[Symbol.toStringTag] = (t => (
        Object.defineProperties(t, {
          size: { writable: !0, enumerable: !1, configurable: !1, value: 0 },
          [rr]: {
            writable: !0,
            enumerable: !1,
            configurable: !1,
            value: null,
          },
          [nr]: { writable: !0, enumerable: !1, configurable: !1, value: -1 },
        }),
        (t[Symbol.toStringTag] = "Row")
      ))(ar.prototype)
      class ur extends ar {
        constructor(t) {
          return super(t, t.length), hr(this)
        }
        keys() {
          return this[rr].getChildAt(0)[Symbol.iterator]()
        }
        values() {
          return this[rr].getChildAt(1)[Symbol.iterator]()
        }
        getKey(t) {
          return this[rr].getChildAt(0).get(t)
        }
        getIndex(t) {
          return this[rr].getChildAt(0).indexOf(t)
        }
        getValue(t) {
          return this[rr].getChildAt(1).get(t)
        }
        setValue(t, e) {
          this[rr].getChildAt(1).set(t, e)
        }
      }
      class cr extends ar {
        constructor(t) {
          return super(t, t.type.children.length), lr(this)
        }
        *keys() {
          for (const t of this[rr].type.children) yield t.name
        }
        *values() {
          for (const t of this[rr].type.children) yield this[t.name]
        }
        getKey(t) {
          return this[rr].type.children[t].name
        }
        getIndex(t) {
          return this[rr].type.children.findIndex(e => e.name === t)
        }
        getValue(t) {
          return this[rr].getChildAt(t).get(this[nr])
        }
        setValue(t, e) {
          return this[rr].getChildAt(t).set(this[nr], e)
        }
      }
      Object.setPrototypeOf(ar.prototype, Map.prototype)
      const lr = (() => {
          const t = { enumerable: !0, configurable: !1, get: null, set: null }
          return e => {
            let r = -1,
              n = e[ir] || (e[ir] = new Map())
            const i = t =>
                function() {
                  return this.get(t)
                },
              s = t =>
                function(e) {
                  return this.set(t, e)
                }
            for (const o of e.keys())
              n.set(o, ++r),
                (t.get = i(o)),
                (t.set = s(o)),
                e.hasOwnProperty(o) ||
                  ((t.enumerable = !0), Object.defineProperty(e, o, t)),
                e.hasOwnProperty(r) ||
                  ((t.enumerable = !1), Object.defineProperty(e, r, t))
            return (t.get = t.set = null), e
          }
        })(),
        hr = (() => {
          if ("undefined" == typeof Proxy) return lr
          const t = ar.prototype.has,
            e = ar.prototype.get,
            r = ar.prototype.set,
            n = ar.prototype.getKey,
            i = {
              isExtensible: () => !1,
              deleteProperty: () => !1,
              preventExtensions: () => !0,
              ownKeys: t => [...t.keys()].map(t => `${t}`),
              has(t, e) {
                switch (e) {
                  case "getKey":
                  case "getIndex":
                  case "getValue":
                  case "setValue":
                  case "toArray":
                  case "toJSON":
                  case "inspect":
                  case "constructor":
                  case "isPrototypeOf":
                  case "propertyIsEnumerable":
                  case "toString":
                  case "toLocaleString":
                  case "valueOf":
                  case "size":
                  case "has":
                  case "get":
                  case "set":
                  case "clear":
                  case "delete":
                  case "keys":
                  case "values":
                  case "entries":
                  case "forEach":
                  case "__proto__":
                  case "__defineGetter__":
                  case "__defineSetter__":
                  case "hasOwnProperty":
                  case "__lookupGetter__":
                  case "__lookupSetter__":
                  case Symbol.iterator:
                  case Symbol.toStringTag:
                  case rr:
                  case nr:
                  case sr:
                  case ir:
                  case or:
                    return !0
                }
                return (
                  "number" != typeof e || t.has(e) || (e = t.getKey(e)),
                  t.has(e)
                )
              },
              get(r, i, s) {
                switch (i) {
                  case "getKey":
                  case "getIndex":
                  case "getValue":
                  case "setValue":
                  case "toArray":
                  case "toJSON":
                  case "inspect":
                  case "constructor":
                  case "isPrototypeOf":
                  case "propertyIsEnumerable":
                  case "toString":
                  case "toLocaleString":
                  case "valueOf":
                  case "size":
                  case "has":
                  case "get":
                  case "set":
                  case "clear":
                  case "delete":
                  case "keys":
                  case "values":
                  case "entries":
                  case "forEach":
                  case "__proto__":
                  case "__defineGetter__":
                  case "__defineSetter__":
                  case "hasOwnProperty":
                  case "__lookupGetter__":
                  case "__lookupSetter__":
                  case Symbol.iterator:
                  case Symbol.toStringTag:
                  case rr:
                  case nr:
                  case sr:
                  case ir:
                  case or:
                    return Reflect.get(r, i, s)
                }
                return (
                  "number" != typeof i || t.call(s, i) || (i = n.call(s, i)),
                  e.call(s, i)
                )
              },
              set(e, i, s, o) {
                switch (i) {
                  case rr:
                  case nr:
                  case sr:
                  case ir:
                    return Reflect.set(e, i, s, o)
                  case "getKey":
                  case "getIndex":
                  case "getValue":
                  case "setValue":
                  case "toArray":
                  case "toJSON":
                  case "inspect":
                  case "constructor":
                  case "isPrototypeOf":
                  case "propertyIsEnumerable":
                  case "toString":
                  case "toLocaleString":
                  case "valueOf":
                  case "size":
                  case "has":
                  case "get":
                  case "set":
                  case "clear":
                  case "delete":
                  case "keys":
                  case "values":
                  case "entries":
                  case "forEach":
                  case "__proto__":
                  case "__defineGetter__":
                  case "__defineSetter__":
                  case "hasOwnProperty":
                  case "__lookupGetter__":
                  case "__lookupSetter__":
                  case Symbol.iterator:
                  case Symbol.toStringTag:
                    return !1
                }
                return (
                  "number" != typeof i || t.call(o, i) || (i = n.call(o, i)),
                  !!t.call(o, i) && !!r.call(o, i, s)
                )
              },
            }
          return t => new Proxy(t, i)
        })()
      function dr(t, e, r) {
        const n = t.length,
          i = e > -1 ? e : n + (e % n)
        return r ? r(t, i) : i
      }
      let fr
      function pr(t, e, r, n) {
        let { length: i = 0 } = t,
          s = "number" != typeof e ? 0 : e,
          o = "number" != typeof r ? i : r
        return (
          s < 0 && (s = ((s % i) + i) % i),
          o < 0 && (o = ((o % i) + i) % i),
          o < s && ((fr = s), (s = o), (o = fr)),
          o > i && (o = i),
          n ? n(t, s, o) : [s, o]
        )
      }
      const yr = Wt.c ? Object(Wt.a)(0) : 0,
        br = t => t != t
      function gr(t) {
        let e = typeof t
        if ("object" !== e || null === t)
          return br(t) ? br : "bigint" !== e ? e => e === t : e => yr + e === t
        if (t instanceof Date) {
          const e = t.valueOf()
          return t => t instanceof Date && t.valueOf() === e
        }
        return ArrayBuffer.isView(t)
          ? e => !!e && Object(kt.compareArrayLike)(t, e)
          : t instanceof Map
          ? (function(t) {
              let e = -1
              const r = []
              return t.forEach(t => (r[++e] = gr(t))), _r(r)
            })(t)
          : Array.isArray(t)
          ? (function(t) {
              const e = []
              for (let r = -1, n = t.length; ++r < n; ) e[r] = gr(t[r])
              return _r(e)
            })(t)
          : t instanceof y
          ? (function(t) {
              const e = []
              for (let r = -1, n = t.length; ++r < n; ) e[r] = gr(t.get(r))
              return _r(e)
            })(t)
          : (function(t) {
              const e = Object.keys(t)
              if (0 === e.length) return () => !1
              const r = []
              for (let n = -1, i = e.length; ++n < i; ) r[n] = gr(t[e[n]])
              return _r(r, e)
            })(t)
      }
      function _r(t, e) {
        return r => {
          if (!r || "object" != typeof r) return !1
          switch (r.constructor) {
            case Array:
              return (function(t, e) {
                const r = t.length
                if (e.length !== r) return !1
                for (let n = -1; ++n < r; ) if (!t[n](e[n])) return !1
                return !0
              })(t, r)
            case Map:
            case ur:
            case cr:
              return mr(t, r, r.keys())
            case Object:
            case void 0:
              return mr(t, r, e || Object.keys(r))
          }
          return (
            r instanceof y &&
            (function(t, e) {
              const r = t.length
              if (e.length !== r) return !1
              for (let n = -1; ++n < r; ) if (!t[n](e.get(n))) return !1
              return !0
            })(t, r)
          )
        }
      }
      function mr(t, e, r) {
        const n = r[Symbol.iterator](),
          i = e instanceof Map ? e.keys() : Object.keys(e)[Symbol.iterator](),
          s =
            e instanceof Map ? e.values() : Object.values(e)[Symbol.iterator]()
        let o = 0,
          a = t.length,
          u = s.next(),
          c = n.next(),
          l = i.next()
        for (
          ;
          o < a &&
          !c.done &&
          !l.done &&
          !u.done &&
          (c.value === l.value && t[o](u.value));
          ++o, c = n.next(), l = i.next(), u = s.next()
        );
        return (
          !!(o === a && c.done && l.done && u.done) ||
          (n.return && n.return(),
          i.return && i.return(),
          s.return && s.return(),
          !1)
        )
      }
      class wr extends y {
        constructor(
          t,
          e = [],
          r = (function(t) {
            let e = new Uint32Array((t || []).length + 1),
              r = (e[0] = 0),
              n = e.length
            for (let i = 0; ++i < n; ) e[i] = r += t[i - 1].length
            return e
          })(e)
        ) {
          super(),
            (this._nullCount = -1),
            (this._type = t),
            (this._chunks = e),
            (this._chunkOffsets = r),
            (this._length = r[r.length - 1]),
            (this._numChildren = (this._type.children || []).length)
        }
        static flatten(...t) {
          return Ur(y, t)
        }
        static concat(...t) {
          const e = wr.flatten(...t)
          return new wr(e[0].type, e)
        }
        get type() {
          return this._type
        }
        get length() {
          return this._length
        }
        get chunks() {
          return this._chunks
        }
        get typeId() {
          return this._type.typeId
        }
        get VectorName() {
          return `Chunked<${this._type}>`
        }
        get data() {
          return this._chunks[0] ? this._chunks[0].data : null
        }
        get ArrayType() {
          return this._type.ArrayType
        }
        get numChildren() {
          return this._numChildren
        }
        get stride() {
          return this._chunks[0] ? this._chunks[0].stride : 1
        }
        get byteLength() {
          return this._chunks.reduce((t, e) => t + e.byteLength, 0)
        }
        get nullCount() {
          let t = this._nullCount
          return (
            t < 0 &&
              (this._nullCount = t = this._chunks.reduce(
                (t, { nullCount: e }) => t + e,
                0
              )),
            t
          )
        }
        get indices() {
          if (J.isDictionary(this._type)) {
            if (!this._indices) {
              const t = this._chunks
              this._indices =
                1 === t.length
                  ? t[0].indices
                  : wr.concat(...t.map(t => t.indices))
            }
            return this._indices
          }
          return null
        }
        get dictionary() {
          return J.isDictionary(this._type)
            ? this._chunks[this._chunks.length - 1].data.dictionary
            : null
        }
        *[Symbol.iterator]() {
          for (const t of this._chunks) yield* t
        }
        clone(t = this._chunks) {
          return new wr(this._type, t)
        }
        concat(...t) {
          return this.clone(wr.flatten(this, ...t))
        }
        slice(t, e) {
          return pr(this, t, e, this._sliceInternal)
        }
        getChildAt(t) {
          if (t < 0 || t >= this._numChildren) return null
          let e,
            r,
            n,
            i = this._children || (this._children = [])
          return (e = i[t])
            ? e
            : (r = (this._type.children || [])[t]) &&
              (n = this._chunks
                .map(e => e.getChildAt(t))
                .filter(t => null != t)).length > 0
            ? (i[t] = new wr(r.type, n))
            : null
        }
        search(t, e) {
          let r = t,
            n = this._chunkOffsets,
            i = n.length - 1
          if (r < 0) return null
          if (r >= n[i]) return null
          if (i <= 1) return e ? e(this, 0, r) : [0, r]
          let s = 0,
            o = 0,
            a = 0
          do {
            if (s + 1 === i) return e ? e(this, s, r - o) : [s, r - o]
            r >= n[(a = (s + (i - s) / 2) | 0)] ? (s = a) : (i = a)
          } while (r < n[i] && r >= (o = n[s]))
          return null
        }
        isValid(t) {
          return !!this.search(t, this.isValidInternal)
        }
        get(t) {
          return this.search(t, this.getInternal)
        }
        set(t, e) {
          this.search(t, ({ chunks: t }, r, n) => t[r].set(n, e))
        }
        indexOf(t, e) {
          return e && "number" == typeof e
            ? this.search(e, (e, r, n) => this.indexOfInternal(e, r, n, t))
            : this.indexOfInternal(this, 0, Math.max(0, e || 0), t)
        }
        toArray() {
          const { chunks: t } = this,
            e = t.length
          let r = this._type.ArrayType
          if (e <= 0) return new r(0)
          if (e <= 1) return t[0].toArray()
          let n = 0,
            i = Array(e)
          for (let a = -1; ++a < e; ) n += (i[a] = t[a].toArray()).length
          r !== i[0].constructor && (r = i[0].constructor)
          let s = new r(n),
            o = r === Array ? Ir : vr
          for (let a = -1, u = 0; ++a < e; ) u = o(i[a], s, u)
          return s
        }
        getInternal({ _chunks: t }, e, r) {
          return t[e].get(r)
        }
        isValidInternal({ _chunks: t }, e, r) {
          return t[e].isValid(r)
        }
        indexOfInternal({ _chunks: t }, e, r, n) {
          let i = e - 1,
            s = t.length,
            o = r,
            a = 0,
            u = -1
          for (; ++i < s; ) {
            if (~(u = t[i].indexOf(n, o))) return a + u
            ;(o = 0), (a += t[i].length)
          }
          return -1
        }
        _sliceInternal(t, e, r) {
          const n = [],
            { chunks: i, _chunkOffsets: s } = t
          for (let o = -1, a = i.length; ++o < a; ) {
            const t = i[o],
              a = t.length,
              u = s[o]
            if (u >= r) break
            if (e >= u + a) continue
            if (u >= e && u + a <= r) {
              n.push(t)
              continue
            }
            const c = Math.max(0, e - u),
              l = Math.min(r - u, a)
            n.push(t.slice(c, l))
          }
          return t.clone(n)
        }
      }
      const vr = (t, e, r) => (e.set(t, r), r + t.length),
        Ir = (t, e, r) => {
          let n = r
          for (let i = -1, s = t.length; ++i < s; ) e[n++] = t[i]
          return n
        }
      class Ar extends wr {
        constructor(t, e = [], r) {
          if (
            ((e = wr.flatten(...e)),
            super(t.type, e, r),
            (this._field = t),
            1 === e.length && !(this instanceof Br))
          )
            return new Br(t, e[0], this._chunkOffsets)
        }
        static new(t, e, ...r) {
          const n = wr.flatten(
            Array.isArray(e)
              ? [...e, ...r]
              : e instanceof y
              ? [e, ...r]
              : [y.new(e, ...r)]
          )
          if ("string" == typeof t) {
            const e = n[0].data.type
            t = new Vr(t, e, !0)
          } else
            !t.nullable &&
              n.some(({ nullCount: t }) => t > 0) &&
              (t = t.clone({ nullable: !0 }))
          return new Ar(t, n)
        }
        get field() {
          return this._field
        }
        get name() {
          return this._field.name
        }
        get nullable() {
          return this._field.nullable
        }
        get metadata() {
          return this._field.metadata
        }
        clone(t = this._chunks) {
          return new Ar(this._field, t)
        }
        getChildAt(t) {
          if (t < 0 || t >= this.numChildren) return null
          let e,
            r,
            n,
            i = this._children || (this._children = [])
          return (e = i[t])
            ? e
            : (r = (this.type.children || [])[t]) &&
              (n = this._chunks
                .map(e => e.getChildAt(t))
                .filter(t => null != t)).length > 0
            ? (i[t] = new Ar(r, n))
            : null
        }
      }
      class Br extends Ar {
        constructor(t, e, r) {
          super(t, [e], r), (this._chunk = e)
        }
        search(t, e) {
          return e ? e(this, 0, t) : [0, t]
        }
        isValid(t) {
          return this._chunk.isValid(t)
        }
        get(t) {
          return this._chunk.get(t)
        }
        set(t, e) {
          this._chunk.set(t, e)
        }
        indexOf(t, e) {
          return this._chunk.indexOf(t, e)
        }
      }
      const Sr = Array.isArray,
        Tr = (t, e) => xr(t, e, [], 0),
        Or = t => {
          const [e, r] = Er(t, [[], []])
          return r.map((t, r) =>
            t instanceof Ar
              ? Ar.new(t.field.clone(e[r]), t)
              : t instanceof y
              ? Ar.new(e[r], t)
              : Ar.new(e[r], [])
          )
        },
        Dr = t => Er(t, [[], []]),
        Ur = (t, e) =>
          (function t(e, r, n, i) {
            let s,
              o = i
            let a = -1,
              u = r.length
            for (; ++a < u; )
              Sr((s = r[a]))
                ? (o = t(e, s, n, o).length)
                : s instanceof wr
                ? (o = t(e, s.chunks, n, o).length)
                : s instanceof e && (n[o++] = s)
            return n
          })(t, e, [], 0),
        Lr = (t, e) =>
          (function t(e, r, n, i) {
            let s,
              o = i
            let a = -1,
              u = r.length
            for (; ++a < u; )
              Sr((s = r[a]))
                ? (o = t(e, s, n, o).length)
                : s instanceof e
                ? (o = xr(
                    y,
                    s.schema.fields.map((t, e) => s.getChildAt(e)),
                    n,
                    o
                  ).length)
                : s instanceof y && (n[o++] = s)
            return n
          })(t, e, [], 0),
        Fr = (t, e) =>
          (function t(e, r, n, i) {
            let s,
              o = i
            let a = -1,
              u = r.length
            for (; ++a < u; )
              Sr((s = r[a]))
                ? (o = t(e, s, n, o).length)
                : s instanceof e
                ? (o = xr(
                    Ar,
                    s.schema.fields.map((t, e) => Ar.new(t, s.getChildAt(e))),
                    n,
                    o
                  ).length)
                : s instanceof Ar && (n[o++] = s)
            return n
          })(t, e, [], 0)
      function xr(t, e, r, n) {
        let i,
          s = n,
          o = -1,
          a = e.length
        for (; ++o < a; )
          Sr((i = e[o]))
            ? (s = xr(t, i, r, s).length)
            : i instanceof t && (r[s++] = i)
        return r
      }
      const Mr = (t, [e, r], n) => ((t[0][n] = e), (t[1][n] = r), t)
      function Er(t, e) {
        let r, n
        switch ((n = t.length)) {
          case 0:
            return e
          case 1:
            if (((r = e[0]), !t[0])) return e
            if (Sr(t[0])) return Er(t[0], e)
            t[0] instanceof Pt ||
              t[0] instanceof y ||
              t[0] instanceof J ||
              ([r, t] = Object.entries(t[0]).reduce(Mr, e))
            break
          default:
            Sr((r = t[n - 1]))
              ? (t = Sr(t[0]) ? t[0] : t.slice(0, n - 1))
              : ((t = Sr(t[0]) ? t[0] : t), (r = []))
        }
        let i,
          s,
          o = -1,
          a = -1,
          u = -1,
          c = t.length,
          [l, h] = e
        for (; ++u < c; )
          (s = t[u]) instanceof Ar && (h[++a] = s)
            ? (l[++o] = s.field.clone(r[u], s.type, !0))
            : (({ [u]: i = u } = r),
              s instanceof J && (h[++a] = s)
                ? (l[++o] = Vr.new(i, s, !0))
                : s &&
                  s.type &&
                  (h[++a] = s) &&
                  (s instanceof Pt && (h[a] = s = y.new(s)),
                  (l[++o] = Vr.new(i, s.type, !0))))
        return e
      }
      class Nr {
        constructor(t = [], e, r) {
          ;(this.fields = t || []),
            (this.metadata = e || new Map()),
            r || (r = Rr(t)),
            (this.dictionaries = r)
        }
        static from(...t) {
          return Nr.new(t[0], t[1])
        }
        static new(...t) {
          return new Nr(Dr(t)[0])
        }
        get [Symbol.toStringTag]() {
          return "Schema"
        }
        toString() {
          return `Schema<{ ${this.fields
            .map((t, e) => `${e}: ${t}`)
            .join(", ")} }>`
        }
        compareTo(t) {
          return K.compareSchemas(this, t)
        }
        select(...t) {
          const e = t.reduce((t, e) => (t[e] = !0) && t, Object.create(null))
          return new Nr(this.fields.filter(t => e[t.name]), this.metadata)
        }
        selectAt(...t) {
          return new Nr(
            t.map(t => this.fields[t]).filter(Boolean),
            this.metadata
          )
        }
        assign(...t) {
          const e = t[0] instanceof Nr ? t[0] : new Nr(Tr(Vr, t)),
            r = [...this.fields],
            n = Cr(Cr(new Map(), this.metadata), e.metadata),
            i = e.fields.filter(t => {
              const e = r.findIndex(e => e.name === t.name)
              return (
                !~e ||
                ((r[e] = t.clone({
                  metadata: Cr(Cr(new Map(), r[e].metadata), t.metadata),
                })) &&
                  !1)
              )
            }),
            s = Rr(i, new Map())
          return new Nr([...r, ...i], n, new Map([...this.dictionaries, ...s]))
        }
      }
      class Vr {
        constructor(t, e, r = !1, n) {
          ;(this.name = t),
            (this.type = e),
            (this.nullable = r),
            (this.metadata = n || new Map())
        }
        static new(...t) {
          let [e, r, n, i] = t
          return (
            t[0] &&
              "object" == typeof t[0] &&
              (({ name: e } = t[0]),
              void 0 === r && (r = t[0].type),
              void 0 === n && (n = t[0].nullable),
              void 0 === i && (i = t[0].metadata)),
            new Vr(`${e}`, r, n, i)
          )
        }
        get typeId() {
          return this.type.typeId
        }
        get [Symbol.toStringTag]() {
          return "Field"
        }
        toString() {
          return `${this.name}: ${this.type}`
        }
        compareTo(t) {
          return K.compareField(this, t)
        }
        clone(...t) {
          let [e, r, n, i] = t
          return (
            t[0] && "object" == typeof t[0]
              ? ({
                  name: e = this.name,
                  type: r = this.type,
                  nullable: n = this.nullable,
                  metadata: i = this.metadata,
                } = t[0])
              : ([
                  e = this.name,
                  r = this.type,
                  n = this.nullable,
                  i = this.metadata,
                ] = t),
            Vr.new(e, r, n, i)
          )
        }
      }
      function Cr(t, e) {
        return new Map([...(t || new Map()), ...(e || new Map())])
      }
      function Rr(t, e = new Map()) {
        for (let r = -1, n = t.length; ++r < n; ) {
          const n = t[r].type
          if (J.isDictionary(n))
            if (e.has(n.id)) {
              if (e.get(n.id) !== n.dictionary)
                throw Error(
                  "Cannot create Schema containing two different dictionaries with the same Id"
                )
            } else e.set(n.id, n.dictionary)
          n.children && n.children.length > 0 && Rr(n.children, e)
        }
        return e
      }
      ;(Nr.prototype.fields = null),
        (Nr.prototype.metadata = null),
        (Nr.prototype.dictionaries = null),
        (Vr.prototype.type = null),
        (Vr.prototype.name = null),
        (Vr.prototype.nullable = null),
        (Vr.prototype.metadata = null)
      class jr extends re {
        constructor(t) {
          super(t), (this._run = new er()), (this._offsets = new Xt())
        }
        addChild(t, e = "0") {
          if (this.numChildren > 0)
            throw Error("ListBuilder can only have one child.")
          return (
            (this.children[this.numChildren] = t),
            (this.type = new Ut(new Vr(e, t.type, !0))),
            this.numChildren - 1
          )
        }
        clear() {
          return this._run.clear(), super.clear()
        }
        _flushPending(t) {
          const e = this._run,
            r = this._offsets,
            n = this._setValue
          let i,
            s = 0
          for ([s, i] of t)
            void 0 === i
              ? r.set(s, 0)
              : (r.set(s, i.length), n(this, s, e.bind(i)))
        }
      }
      class kr extends te {
        constructor() {
          super(...arguments), (this._run = new er())
        }
        setValue(t, e) {
          super.setValue(t, this._run.bind(e))
        }
        addChild(t, e = "0") {
          if (this.numChildren > 0)
            throw Error("FixedSizeListBuilder can only have one child.")
          const r = this.children.push(t)
          return (
            (this.type = new Nt(this.type.listSize, new Vr(e, t.type, !0))), r
          )
        }
        clear() {
          return this._run.clear(), super.clear()
        }
      }
      class zr extends re {
        set(t, e) {
          return super.set(t, e)
        }
        setValue(t, e) {
          e = e instanceof Map ? e : new Map(Object.entries(e))
          const r = this._pending || (this._pending = new Map()),
            n = r.get(t)
          n && (this._pendingLength -= n.size),
            (this._pendingLength += e.size),
            r.set(t, e)
        }
        addChild(t, e = `${this.numChildren}`) {
          if (this.numChildren > 0)
            throw Error("ListBuilder can only have one child.")
          return (
            (this.children[this.numChildren] = t),
            (this.type = new Vt(new Vr(e, t.type, !0), this.type.keysSorted)),
            this.numChildren - 1
          )
        }
        _flushPending(t) {
          const e = this._offsets,
            r = this._setValue
          t.forEach((t, n) => {
            void 0 === t ? e.set(n, 0) : (e.set(n, t.size), r(this, n, t))
          })
        }
      }
      class Pr extends te {
        addChild(t, e = `${this.numChildren}`) {
          const r = this.children.push(t)
          return (
            (this.type = new Lt([
              ...this.type.children,
              new Vr(e, t.type, !0),
            ])),
            r
          )
        }
      }
      class Yr extends te {
        constructor(t) {
          super(t),
            (this._typeIds = new qt(new Int8Array(0), 1)),
            "function" == typeof t.valueToChildTypeId &&
              (this._valueToChildTypeId = t.valueToChildTypeId)
        }
        get typeIdToChildIndex() {
          return this.type.typeIdToChildIndex
        }
        append(t, e) {
          return this.set(this.length, t, e)
        }
        set(t, e, r) {
          return (
            void 0 === r && (r = this._valueToChildTypeId(this, e, t)),
            this.setValid(t, this.isValid(e)) && this.setValue(t, e, r),
            this
          )
        }
        setValue(t, e, r) {
          this._typeIds.set(t, r), super.setValue(t, e)
        }
        addChild(t, e = `${this.children.length}`) {
          const r = this.children.push(t),
            {
              type: { children: n, mode: i, typeIds: s },
            } = this,
            o = [...n, new Vr(e, t.type)]
          return (this.type = new Ft(i, [...s, r], o)), r
        }
        _valueToChildTypeId(t, e, r) {
          throw Error(
            "Cannot map UnionBuilder value to child typeId. Pass the `childTypeId` as the second argument to unionBuilder.append(), or supply a `valueToChildTypeId` function as part of the UnionBuilder constructor options."
          )
        }
      }
      class $r extends Yr {}
      class Wr extends Yr {
        constructor(t) {
          super(t), (this._offsets = new qt(new Int32Array(0)))
        }
        setValue(t, e, r) {
          const n = this.type.typeIdToChildIndex[r]
          return (
            this._offsets.set(t, this.getChildAt(n).length),
            super.setValue(t, e, r)
          )
        }
      }
      class Hr extends N {}
      const Kr = (t, e, r) => {
          ;(t[e] = r % 4294967296 | 0), (t[e + 1] = (r / 4294967296) | 0)
        },
        Jr = (t, e, r, n) => {
          const { [r]: i, [r + 1]: s } = e
          null != i && null != s && t.set(n.subarray(0, s - i), i)
        },
        Gr = ({ values: t }, e, r) => {
          ;((t, e, r) => {
            t[e] = (r / 864e5) | 0
          })(t, e, r.valueOf())
        },
        qr = ({ values: t }, e, r) => {
          Kr(t, 2 * e, r.valueOf())
        },
        Zr = ({ stride: t, values: e }, r, n) => {
          e[t * r] = n
        },
        Xr = ({ stride: t, values: e }, r, n) => {
          e[t * r] = pe(n)
        },
        Qr = (t, e, r) => {
          switch (typeof r) {
            case "bigint":
              t.values64[e] = r
              break
            case "number":
              t.values[e * t.stride] = r
              break
            default:
              const n = r,
                { stride: i, ArrayType: s } = t,
                o = Object(kt.toArrayBufferView)(s, n)
              t.values.set(o.subarray(0, i), i * e)
          }
        },
        tn = ({ values: t }, e, r) => Kr(t, 2 * e, r / 1e3),
        en = ({ values: t }, e, r) => Kr(t, 2 * e, r),
        rn = ({ values: t }, e, r) =>
          ((t, e, r) => {
            ;(t[e] = (1e3 * r) % 4294967296 | 0),
              (t[e + 1] = ((1e3 * r) / 4294967296) | 0)
          })(t, 2 * e, r),
        nn = ({ values: t }, e, r) =>
          ((t, e, r) => {
            ;(t[e] = (1e6 * r) % 4294967296 | 0),
              (t[e + 1] = ((1e6 * r) / 4294967296) | 0)
          })(t, 2 * e, r),
        sn = ({ values: t, stride: e }, r, n) => {
          t[e * r] = n
        },
        on = ({ values: t, stride: e }, r, n) => {
          t[e * r] = n
        },
        an = ({ values: t }, e, r) => {
          t.set(r.subarray(0, 2), 2 * e)
        },
        un = ({ values: t }, e, r) => {
          t.set(r.subarray(0, 2), 2 * e)
        },
        cn = (t, e, r) => {
          const n = t.typeIdToChildIndex[t.typeIds[e]],
            i = t.getChildAt(n)
          i && i.set(t.valueOffsets[e], r)
        },
        ln = (t, e, r) => {
          const n = t.typeIdToChildIndex[t.typeIds[e]],
            i = t.getChildAt(n)
          i && i.set(e, r)
        },
        hn = ({ values: t }, e, r) => {
          t.set(r.subarray(0, 2), 2 * e)
        },
        dn = ({ values: t }, e, r) => {
          t[e] = 12 * r[0] + (r[1] % 12)
        }
      ;(Hr.prototype.visitBool = ({ offset: t, values: e }, r, n) => {
        const i = t + r
        n ? (e[i >> 3] |= 1 << i % 8) : (e[i >> 3] &= ~(1 << i % 8))
      }),
        (Hr.prototype.visitInt = (t, e, r) => {
          t.type.bitWidth < 64 ? Zr(t, e, r) : Qr(t, e, r)
        }),
        (Hr.prototype.visitInt8 = Zr),
        (Hr.prototype.visitInt16 = Zr),
        (Hr.prototype.visitInt32 = Zr),
        (Hr.prototype.visitInt64 = Qr),
        (Hr.prototype.visitUint8 = Zr),
        (Hr.prototype.visitUint16 = Zr),
        (Hr.prototype.visitUint32 = Zr),
        (Hr.prototype.visitUint64 = Qr),
        (Hr.prototype.visitFloat = (t, e, r) => {
          t.type.precision !== v.HALF ? Zr(t, e, r) : Xr(t, e, r)
        }),
        (Hr.prototype.visitFloat16 = Xr),
        (Hr.prototype.visitFloat32 = Zr),
        (Hr.prototype.visitFloat64 = Zr),
        (Hr.prototype.visitUtf8 = ({ values: t, valueOffsets: e }, r, n) => {
          Jr(t, e, r, Object(Xe.b)(n))
        }),
        (Hr.prototype.visitBinary = ({ values: t, valueOffsets: e }, r, n) =>
          Jr(t, e, r, n)),
        (Hr.prototype.visitFixedSizeBinary = (
          { stride: t, values: e },
          r,
          n
        ) => {
          e.set(n.subarray(0, t), t * r)
        }),
        (Hr.prototype.visitDate = (t, e, r) => {
          t.type.unit === m.DAY ? Gr(t, e, r) : qr(t, e, r)
        }),
        (Hr.prototype.visitDateDay = Gr),
        (Hr.prototype.visitDateMillisecond = qr),
        (Hr.prototype.visitTimestamp = (t, e, r) => {
          switch (t.type.unit) {
            case w.SECOND:
              return tn(t, e, r)
            case w.MILLISECOND:
              return en(t, e, r)
            case w.MICROSECOND:
              return rn(t, e, r)
            case w.NANOSECOND:
              return nn(t, e, r)
          }
        }),
        (Hr.prototype.visitTimestampSecond = tn),
        (Hr.prototype.visitTimestampMillisecond = en),
        (Hr.prototype.visitTimestampMicrosecond = rn),
        (Hr.prototype.visitTimestampNanosecond = nn),
        (Hr.prototype.visitTime = (t, e, r) => {
          switch (t.type.unit) {
            case w.SECOND:
              return sn(t, e, r)
            case w.MILLISECOND:
              return on(t, e, r)
            case w.MICROSECOND:
              return an(t, e, r)
            case w.NANOSECOND:
              return un(t, e, r)
          }
        }),
        (Hr.prototype.visitTimeSecond = sn),
        (Hr.prototype.visitTimeMillisecond = on),
        (Hr.prototype.visitTimeMicrosecond = an),
        (Hr.prototype.visitTimeNanosecond = un),
        (Hr.prototype.visitDecimal = ({ values: t }, e, r) => {
          t.set(r.subarray(0, 4), 4 * e)
        }),
        (Hr.prototype.visitList = (t, e, r) => {
          const n = t.getChildAt(0),
            i = t.valueOffsets
          for (let s = -1, o = i[e], a = i[e + 1]; o < a; )
            n.set(o++, r.get(++s))
        }),
        (Hr.prototype.visitStruct = (t, e, r) => {
          const n =
            r instanceof Map
              ? ((t, e) => (r, n, i) => r && r.set(t, e.get(n.name)))(e, r)
              : r instanceof y
              ? ((t, e) => (r, n, i) => r && r.set(t, e.get(i)))(e, r)
              : Array.isArray(r)
              ? ((t, e) => (r, n, i) => r && r.set(t, e[i]))(e, r)
              : ((t, e) => (r, n, i) => r && r.set(t, e[n.name]))(e, r)
          t.type.children.forEach((e, r) => n(t.getChildAt(r), e, r))
        }),
        (Hr.prototype.visitUnion = (t, e, r) => {
          t.type.mode === I.Dense ? cn(t, e, r) : ln(t, e, r)
        }),
        (Hr.prototype.visitDenseUnion = cn),
        (Hr.prototype.visitSparseUnion = ln),
        (Hr.prototype.visitDictionary = (t, e, r) => {
          const n = t.getKey(e)
          null !== n && t.setValue(n, r)
        }),
        (Hr.prototype.visitInterval = (t, e, r) => {
          t.type.unit === A.DAY_TIME ? hn(t, e, r) : dn(t, e, r)
        }),
        (Hr.prototype.visitIntervalDayTime = hn),
        (Hr.prototype.visitIntervalYearMonth = dn),
        (Hr.prototype.visitFixedSizeList = (t, e, r) => {
          const n = t.getChildAt(0),
            { stride: i } = t
          for (let s = -1, o = e * i; ++s < i; ) n.set(o + s, r.get(s))
        }),
        (Hr.prototype.visitMap = (t, e, r) => {
          const n = t.getChildAt(0),
            i = t.valueOffsets,
            s = r instanceof Map ? [...r] : Object.entries(r)
          for (let o = -1, a = i[e], u = i[e + 1]; a < u; ) n.set(a++, s[++o])
        })
      const fn = new Hr()
      const pn = new (class extends N {
        visitNull() {
          return ie
        }
        visitBool() {
          return ne
        }
        visitInt() {
          return Ue
        }
        visitInt8() {
          return Le
        }
        visitInt16() {
          return Fe
        }
        visitInt32() {
          return xe
        }
        visitInt64() {
          return Me
        }
        visitUint8() {
          return Ee
        }
        visitUint16() {
          return Ne
        }
        visitUint32() {
          return Ve
        }
        visitUint64() {
          return Ce
        }
        visitFloat() {
          return ye
        }
        visitFloat16() {
          return be
        }
        visitFloat32() {
          return ge
        }
        visitFloat64() {
          return _e
        }
        visitUtf8() {
          return tr
        }
        visitBinary() {
          return Qe
        }
        visitFixedSizeBinary() {
          return le
        }
        visitDate() {
          return se
        }
        visitDateDay() {
          return oe
        }
        visitDateMillisecond() {
          return ae
        }
        visitTimestamp() {
          return $e
        }
        visitTimestampSecond() {
          return We
        }
        visitTimestampMillisecond() {
          return He
        }
        visitTimestampMicrosecond() {
          return Ke
        }
        visitTimestampNanosecond() {
          return Je
        }
        visitTime() {
          return je
        }
        visitTimeSecond() {
          return ke
        }
        visitTimeMillisecond() {
          return ze
        }
        visitTimeMicrosecond() {
          return Pe
        }
        visitTimeNanosecond() {
          return Ye
        }
        visitDecimal() {
          return ue
        }
        visitList() {
          return jr
        }
        visitStruct() {
          return Pr
        }
        visitUnion() {
          return Yr
        }
        visitDenseUnion() {
          return Wr
        }
        visitSparseUnion() {
          return $r
        }
        visitDictionary() {
          return ce
        }
        visitInterval() {
          return Ge
        }
        visitIntervalDayTime() {
          return qe
        }
        visitIntervalYearMonth() {
          return Ze
        }
        visitFixedSizeList() {
          return kr
        }
        visitMap() {
          return zr
        }
      })()
      var yn
      ;(te.new = function t(e) {
        const r = e.type
        const n = new (pn.getVisitFn(r)())(e)
        if (r.children && r.children.length > 0) {
          const i = e.children || [],
            s = { nullValues: e.nullValues },
            o = Array.isArray(i)
              ? (t, e) => i[e] || s
              : ({ name: t }) => i[t] || s
          r.children.forEach((e, r) => {
            const { type: i } = e,
              s = o(e, r)
            n.children.push(t({ ...s, type: i }))
          })
        }
        return n
      }),
        Object.keys(b)
          .map(t => b[t])
          .filter(t => "number" == typeof t && t !== b.NONE)
          .forEach(t => {
            pn.visit(t).prototype._setValue = fn.getVisitFn(t)
          }),
        (tr.prototype._setValue = fn.visitBinary),
        (function(t) {
          !(function(e) {
            !(function(e) {
              !(function(e) {
                class r {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  static getRootAsFooter(t, e) {
                    return (e || new r()).__init(
                      t.readInt32(t.position()) + t.position(),
                      t
                    )
                  }
                  version() {
                    let t = this.bb.__offset(this.bb_pos, 4)
                    return t
                      ? this.bb.readInt16(this.bb_pos + t)
                      : c.apache.arrow.flatbuf.MetadataVersion.V1
                  }
                  schema(t) {
                    let e = this.bb.__offset(this.bb_pos, 6)
                    return e
                      ? (t || new c.apache.arrow.flatbuf.Schema()).__init(
                          this.bb.__indirect(this.bb_pos + e),
                          this.bb
                        )
                      : null
                  }
                  dictionaries(e, r) {
                    let n = this.bb.__offset(this.bb_pos, 8)
                    return n
                      ? (r || new t.apache.arrow.flatbuf.Block()).__init(
                          this.bb.__vector(this.bb_pos + n) + 24 * e,
                          this.bb
                        )
                      : null
                  }
                  dictionariesLength() {
                    let t = this.bb.__offset(this.bb_pos, 8)
                    return t ? this.bb.__vector_len(this.bb_pos + t) : 0
                  }
                  recordBatches(e, r) {
                    let n = this.bb.__offset(this.bb_pos, 10)
                    return n
                      ? (r || new t.apache.arrow.flatbuf.Block()).__init(
                          this.bb.__vector(this.bb_pos + n) + 24 * e,
                          this.bb
                        )
                      : null
                  }
                  recordBatchesLength() {
                    let t = this.bb.__offset(this.bb_pos, 10)
                    return t ? this.bb.__vector_len(this.bb_pos + t) : 0
                  }
                  static startFooter(t) {
                    t.startObject(4)
                  }
                  static addVersion(t, e) {
                    t.addFieldInt16(
                      0,
                      e,
                      c.apache.arrow.flatbuf.MetadataVersion.V1
                    )
                  }
                  static addSchema(t, e) {
                    t.addFieldOffset(1, e, 0)
                  }
                  static addDictionaries(t, e) {
                    t.addFieldOffset(2, e, 0)
                  }
                  static startDictionariesVector(t, e) {
                    t.startVector(24, e, 8)
                  }
                  static addRecordBatches(t, e) {
                    t.addFieldOffset(3, e, 0)
                  }
                  static startRecordBatchesVector(t, e) {
                    t.startVector(24, e, 8)
                  }
                  static endFooter(t) {
                    return t.endObject()
                  }
                  static finishFooterBuffer(t, e) {
                    t.finish(e)
                  }
                  static createFooter(t, e, n, i, s) {
                    return (
                      r.startFooter(t),
                      r.addVersion(t, e),
                      r.addSchema(t, n),
                      r.addDictionaries(t, i),
                      r.addRecordBatches(t, s),
                      r.endFooter(t)
                    )
                  }
                }
                e.Footer = r
              })(e.flatbuf || (e.flatbuf = {}))
            })(e.arrow || (e.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(yn || (yn = {})),
        (function(t) {
          !(function(t) {
            !(function(t) {
              !(function(t) {
                t.Block = class {
                  constructor() {
                    ;(this.bb = null), (this.bb_pos = 0)
                  }
                  __init(t, e) {
                    return (this.bb_pos = t), (this.bb = e), this
                  }
                  offset() {
                    return this.bb.readInt64(this.bb_pos)
                  }
                  metaDataLength() {
                    return this.bb.readInt32(this.bb_pos + 8)
                  }
                  bodyLength() {
                    return this.bb.readInt64(this.bb_pos + 16)
                  }
                  static createBlock(t, e, r, n) {
                    return (
                      t.prep(8, 24),
                      t.writeInt64(n),
                      t.pad(4),
                      t.writeInt32(r),
                      t.writeInt64(e),
                      t.offset()
                    )
                  }
                }
              })(t.flatbuf || (t.flatbuf = {}))
            })(t.arrow || (t.arrow = {}))
          })(t.apache || (t.apache = {}))
        })(yn || (yn = {}))
      var bn = r(4),
        gn = bn.a.Long,
        _n = bn.a.Builder,
        mn = bn.a.ByteBuffer,
        wn = yn.apache.arrow.flatbuf.Block,
        vn = yn.apache.arrow.flatbuf.Footer
      class In {
        constructor(t, e = S.V4, r, n) {
          ;(this.schema = t),
            (this.version = e),
            r && (this._recordBatches = r),
            n && (this._dictionaryBatches = n)
        }
        static decode(t) {
          t = new mn(Object(kt.toUint8Array)(t))
          const e = vn.getRootAsFooter(t),
            r = Nr.decode(e.schema())
          return new An(r, e)
        }
        static encode(t) {
          const e = new _n(),
            r = Nr.encode(e, t.schema)
          vn.startRecordBatchesVector(e, t.numRecordBatches),
            [...t.recordBatches()]
              .slice()
              .reverse()
              .forEach(t => Bn.encode(e, t))
          const n = e.endVector()
          vn.startDictionariesVector(e, t.numDictionaries),
            [...t.dictionaryBatches()]
              .slice()
              .reverse()
              .forEach(t => Bn.encode(e, t))
          const i = e.endVector()
          return (
            vn.startFooter(e),
            vn.addSchema(e, r),
            vn.addVersion(e, S.V4),
            vn.addRecordBatches(e, n),
            vn.addDictionaries(e, i),
            vn.finishFooterBuffer(e, vn.endFooter(e)),
            e.asUint8Array()
          )
        }
        get numRecordBatches() {
          return this._recordBatches.length
        }
        get numDictionaries() {
          return this._dictionaryBatches.length
        }
        *recordBatches() {
          for (let t, e = -1, r = this.numRecordBatches; ++e < r; )
            (t = this.getRecordBatch(e)) && (yield t)
        }
        *dictionaryBatches() {
          for (let t, e = -1, r = this.numDictionaries; ++e < r; )
            (t = this.getDictionaryBatch(e)) && (yield t)
        }
        getRecordBatch(t) {
          return (
            (t >= 0 && t < this.numRecordBatches && this._recordBatches[t]) ||
            null
          )
        }
        getDictionaryBatch(t) {
          return (
            (t >= 0 &&
              t < this.numDictionaries &&
              this._dictionaryBatches[t]) ||
            null
          )
        }
      }
      class An extends In {
        constructor(t, e) {
          super(t, e.version()), (this._footer = e)
        }
        get numRecordBatches() {
          return this._footer.recordBatchesLength()
        }
        get numDictionaries() {
          return this._footer.dictionariesLength()
        }
        getRecordBatch(t) {
          if (t >= 0 && t < this.numRecordBatches) {
            const e = this._footer.recordBatches(t)
            if (e) return Bn.decode(e)
          }
          return null
        }
        getDictionaryBatch(t) {
          if (t >= 0 && t < this.numDictionaries) {
            const e = this._footer.dictionaries(t)
            if (e) return Bn.decode(e)
          }
          return null
        }
      }
      class Bn {
        static decode(t) {
          return new Bn(t.metaDataLength(), t.bodyLength(), t.offset())
        }
        static encode(t, e) {
          const { metaDataLength: r } = e,
            n = new gn(e.offset, 0),
            i = new gn(e.bodyLength, 0)
          return wn.createBlock(t, n, r, i)
        }
        constructor(t, e, r) {
          ;(this.metaDataLength = t),
            (this.offset = "number" == typeof r ? r : r.low),
            (this.bodyLength = "number" == typeof e ? e : e.low)
        }
      }
      var Sn = r(2)
      class Tn extends Sn.b {
        write(t) {
          if ((t = Object(kt.toUint8Array)(t)).byteLength > 0)
            return super.write(t)
        }
        toString(t = !1) {
          return t
            ? Object(Xe.a)(this.toUint8Array(!0))
            : this.toUint8Array(!1).then(Xe.a)
        }
        toUint8Array(t = !1) {
          return t
            ? Object(kt.joinUint8Arrays)(this._values)[0]
            : (async () => {
                let t = [],
                  e = 0
                for await (const r of this) t.push(r), (e += r.byteLength)
                return Object(kt.joinUint8Arrays)(t, e)[0]
              })()
        }
      }
      class On {
        constructor(t) {
          t && (this.source = new Un(p.a.fromIterable(t)))
        }
        [Symbol.iterator]() {
          return this
        }
        next(t) {
          return this.source.next(t)
        }
        throw(t) {
          return this.source.throw(t)
        }
        return(t) {
          return this.source.return(t)
        }
        peek(t) {
          return this.source.peek(t)
        }
        read(t) {
          return this.source.read(t)
        }
      }
      class Dn {
        constructor(t) {
          t instanceof Dn
            ? (this.source = t.source)
            : t instanceof Tn
            ? (this.source = new Ln(p.a.fromAsyncIterable(t)))
            : Object(Wt.n)(t)
            ? (this.source = new Ln(p.a.fromNodeStream(t)))
            : Object(Wt.m)(t)
            ? (this.source = new Ln(p.a.fromDOMStream(t)))
            : Object(Wt.g)(t)
            ? (this.source = new Ln(p.a.fromDOMStream(t.body)))
            : Object(Wt.i)(t)
            ? (this.source = new Ln(p.a.fromIterable(t)))
            : Object(Wt.l)(t)
            ? (this.source = new Ln(p.a.fromAsyncIterable(t)))
            : Object(Wt.f)(t) &&
              (this.source = new Ln(p.a.fromAsyncIterable(t)))
        }
        [Symbol.asyncIterator]() {
          return this
        }
        next(t) {
          return this.source.next(t)
        }
        throw(t) {
          return this.source.throw(t)
        }
        return(t) {
          return this.source.return(t)
        }
        get closed() {
          return this.source.closed
        }
        cancel(t) {
          return this.source.cancel(t)
        }
        peek(t) {
          return this.source.peek(t)
        }
        read(t) {
          return this.source.read(t)
        }
      }
      class Un {
        constructor(t) {
          this.source = t
        }
        cancel(t) {
          this.return(t)
        }
        peek(t) {
          return this.next(t, "peek").value
        }
        read(t) {
          return this.next(t, "read").value
        }
        next(t, e = "read") {
          return this.source.next({ cmd: e, size: t })
        }
        throw(t) {
          return Object.create(
            (this.source.throw && this.source.throw(t)) || Sn.c
          )
        }
        return(t) {
          return Object.create(
            (this.source.return && this.source.return(t)) || Sn.c
          )
        }
      }
      class Ln {
        constructor(t) {
          ;(this.source = t),
            (this._closedPromise = new Promise(
              t => (this._closedPromiseResolve = t)
            ))
        }
        async cancel(t) {
          await this.return(t)
        }
        get closed() {
          return this._closedPromise
        }
        async read(t) {
          return (await this.next(t, "read")).value
        }
        async peek(t) {
          return (await this.next(t, "peek")).value
        }
        async next(t, e = "read") {
          return await this.source.next({ cmd: e, size: t })
        }
        async throw(t) {
          const e = (this.source.throw && (await this.source.throw(t))) || Sn.c
          return (
            this._closedPromiseResolve && this._closedPromiseResolve(),
            (this._closedPromiseResolve = void 0),
            Object.create(e)
          )
        }
        async return(t) {
          const e =
            (this.source.return && (await this.source.return(t))) || Sn.c
          return (
            this._closedPromiseResolve && this._closedPromiseResolve(),
            (this._closedPromiseResolve = void 0),
            Object.create(e)
          )
        }
      }
      class Fn extends On {
        constructor(t, e) {
          super(),
            (this.position = 0),
            (this.buffer = Object(kt.toUint8Array)(t)),
            (this.size = void 0 === e ? this.buffer.byteLength : e)
        }
        readInt32(t) {
          const { buffer: e, byteOffset: r } = this.readAt(t, 4)
          return new DataView(e, r).getInt32(0, !0)
        }
        seek(t) {
          return (this.position = Math.min(t, this.size)), t < this.size
        }
        read(t) {
          const { buffer: e, size: r, position: n } = this
          return e && n < r
            ? ("number" != typeof t && (t = 1 / 0),
              (this.position = Math.min(r, n + Math.min(r - n, t))),
              e.subarray(n, this.position))
            : null
        }
        readAt(t, e) {
          const r = this.buffer,
            n = Math.min(this.size, t + e)
          return r ? r.subarray(t, n) : new Uint8Array(e)
        }
        close() {
          this.buffer && (this.buffer = null)
        }
        throw(t) {
          return this.close(), { done: !0, value: t }
        }
        return(t) {
          return this.close(), { done: !0, value: t }
        }
      }
      class xn extends Dn {
        constructor(t, e) {
          super(),
            (this.position = 0),
            (this._handle = t),
            "number" == typeof e
              ? (this.size = e)
              : (this._pending = (async () => {
                  ;(this.size = (await t.stat()).size), delete this._pending
                })())
        }
        async readInt32(t) {
          const { buffer: e, byteOffset: r } = await this.readAt(t, 4)
          return new DataView(e, r).getInt32(0, !0)
        }
        async seek(t) {
          return (
            this._pending && (await this._pending),
            (this.position = Math.min(t, this.size)),
            t < this.size
          )
        }
        async read(t) {
          this._pending && (await this._pending)
          const { _handle: e, size: r, position: n } = this
          if (e && n < r) {
            "number" != typeof t && (t = 1 / 0)
            let i = n,
              s = 0,
              o = 0,
              a = Math.min(r, i + Math.min(r - i, t)),
              u = new Uint8Array(Math.max(0, (this.position = a) - i))
            for (; (i += o) < a && (s += o) < u.byteLength; )
              ({ bytesRead: o } = await e.read(u, s, u.byteLength - s, i))
            return u
          }
          return null
        }
        async readAt(t, e) {
          this._pending && (await this._pending)
          const { _handle: r, size: n } = this
          if (r && t + e < n) {
            const i = new Uint8Array(Math.min(n, t + e) - t)
            return (await r.read(i, 0, e, t)).buffer
          }
          return new Uint8Array(e)
        }
        async close() {
          const t = this._handle
          ;(this._handle = null), t && (await t.close())
        }
        async throw(t) {
          return await this.close(), { done: !0, value: t }
        }
        async return(t) {
          return await this.close(), { done: !0, value: t }
        }
      }
      const Mn = 65536
      function En(t) {
        return t < 0 && (t = 4294967295 + t + 1), `0x${t.toString(16)}`
      }
      const Nn = 8,
        Vn = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8]
      class Cn {
        constructor(t) {
          this.buffer = t
        }
        high() {
          return this.buffer[1]
        }
        low() {
          return this.buffer[0]
        }
        _times(t) {
          const e = new Uint32Array([
              this.buffer[1] >>> 16,
              65535 & this.buffer[1],
              this.buffer[0] >>> 16,
              65535 & this.buffer[0],
            ]),
            r = new Uint32Array([
              t.buffer[1] >>> 16,
              65535 & t.buffer[1],
              t.buffer[0] >>> 16,
              65535 & t.buffer[0],
            ])
          let n = e[3] * r[3]
          this.buffer[0] = 65535 & n
          let i = n >>> 16
          return (
            (i += n = e[2] * r[3]),
            (i += n = (e[3] * r[2]) >>> 0),
            (this.buffer[0] += i << 16),
            (this.buffer[1] = i >>> 0 < n ? Mn : 0),
            (this.buffer[1] += i >>> 16),
            (this.buffer[1] += e[1] * r[3] + e[2] * r[2] + e[3] * r[1]),
            (this.buffer[1] +=
              (e[0] * r[3] + e[1] * r[2] + e[2] * r[1] + e[3] * r[0]) << 16),
            this
          )
        }
        _plus(t) {
          const e = (this.buffer[0] + t.buffer[0]) >>> 0
          ;(this.buffer[1] += t.buffer[1]),
            e < this.buffer[0] >>> 0 && ++this.buffer[1],
            (this.buffer[0] = e)
        }
        lessThan(t) {
          return (
            this.buffer[1] < t.buffer[1] ||
            (this.buffer[1] === t.buffer[1] && this.buffer[0] < t.buffer[0])
          )
        }
        equals(t) {
          return (
            this.buffer[1] === t.buffer[1] && this.buffer[0] == t.buffer[0]
          )
        }
        greaterThan(t) {
          return t.lessThan(this)
        }
        hex() {
          return `${En(this.buffer[1])} ${En(this.buffer[0])}`
        }
      }
      class Rn extends Cn {
        times(t) {
          return this._times(t), this
        }
        plus(t) {
          return this._plus(t), this
        }
        static from(t, e = new Uint32Array(2)) {
          return Rn.fromString("string" == typeof t ? t : t.toString(), e)
        }
        static fromNumber(t, e = new Uint32Array(2)) {
          return Rn.fromString(t.toString(), e)
        }
        static fromString(t, e = new Uint32Array(2)) {
          const r = t.length
          let n = new Rn(e)
          for (let i = 0; i < r; ) {
            const e = Nn < r - i ? Nn : r - i,
              s = new Rn(new Uint32Array([parseInt(t.substr(i, e), 10), 0])),
              o = new Rn(new Uint32Array([Vn[e], 0]))
            n.times(o), n.plus(s), (i += e)
          }
          return n
        }
        static convertArray(t) {
          const e = new Uint32Array(2 * t.length)
          for (let r = -1, n = t.length; ++r < n; )
            Rn.from(
              t[r],
              new Uint32Array(e.buffer, e.byteOffset + 2 * r * 4, 2)
            )
          return e
        }
        static multiply(t, e) {
          return new Rn(new Uint32Array(t.buffer)).times(e)
        }
        static add(t, e) {
          return new Rn(new Uint32Array(t.buffer)).plus(e)
        }
      }
      class jn extends Cn {
        negate() {
          return (
            (this.buffer[0] = 1 + ~this.buffer[0]),
            (this.buffer[1] = ~this.buffer[1]),
            0 == this.buffer[0] && ++this.buffer[1],
            this
          )
        }
        times(t) {
          return this._times(t), this
        }
        plus(t) {
          return this._plus(t), this
        }
        lessThan(t) {
          const e = this.buffer[1] << 0,
            r = t.buffer[1] << 0
          return e < r || (e === r && this.buffer[0] < t.buffer[0])
        }
        static from(t, e = new Uint32Array(2)) {
          return jn.fromString("string" == typeof t ? t : t.toString(), e)
        }
        static fromNumber(t, e = new Uint32Array(2)) {
          return jn.fromString(t.toString(), e)
        }
        static fromString(t, e = new Uint32Array(2)) {
          const r = t.startsWith("-"),
            n = t.length
          let i = new jn(e)
          for (let s = r ? 1 : 0; s < n; ) {
            const e = Nn < n - s ? Nn : n - s,
              r = new jn(new Uint32Array([parseInt(t.substr(s, e), 10), 0])),
              o = new jn(new Uint32Array([Vn[e], 0]))
            i.times(o), i.plus(r), (s += e)
          }
          return r ? i.negate() : i
        }
        static convertArray(t) {
          const e = new Uint32Array(2 * t.length)
          for (let r = -1, n = t.length; ++r < n; )
            jn.from(
              t[r],
              new Uint32Array(e.buffer, e.byteOffset + 2 * r * 4, 2)
            )
          return e
        }
        static multiply(t, e) {
          return new jn(new Uint32Array(t.buffer)).times(e)
        }
        static add(t, e) {
          return new jn(new Uint32Array(t.buffer)).plus(e)
        }
      }
      class kn {
        constructor(t) {
          this.buffer = t
        }
        high() {
          return new jn(
            new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2)
          )
        }
        low() {
          return new jn(
            new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2)
          )
        }
        negate() {
          return (
            (this.buffer[0] = 1 + ~this.buffer[0]),
            (this.buffer[1] = ~this.buffer[1]),
            (this.buffer[2] = ~this.buffer[2]),
            (this.buffer[3] = ~this.buffer[3]),
            0 == this.buffer[0] && ++this.buffer[1],
            0 == this.buffer[1] && ++this.buffer[2],
            0 == this.buffer[2] && ++this.buffer[3],
            this
          )
        }
        times(t) {
          const e = new Rn(new Uint32Array([this.buffer[3], 0])),
            r = new Rn(new Uint32Array([this.buffer[2], 0])),
            n = new Rn(new Uint32Array([this.buffer[1], 0])),
            i = new Rn(new Uint32Array([this.buffer[0], 0])),
            s = new Rn(new Uint32Array([t.buffer[3], 0])),
            o = new Rn(new Uint32Array([t.buffer[2], 0])),
            a = new Rn(new Uint32Array([t.buffer[1], 0])),
            u = new Rn(new Uint32Array([t.buffer[0], 0]))
          let c = Rn.multiply(i, u)
          this.buffer[0] = c.low()
          let l = new Rn(new Uint32Array([c.high(), 0]))
          return (
            (c = Rn.multiply(n, u)),
            l.plus(c),
            (c = Rn.multiply(i, a)),
            l.plus(c),
            (this.buffer[1] = l.low()),
            (this.buffer[3] = l.lessThan(c) ? 1 : 0),
            (this.buffer[2] = l.high()),
            new Rn(
              new Uint32Array(
                this.buffer.buffer,
                this.buffer.byteOffset + 8,
                2
              )
            )
              .plus(Rn.multiply(r, u))
              .plus(Rn.multiply(n, a))
              .plus(Rn.multiply(i, o)),
            (this.buffer[3] += Rn.multiply(e, u)
              .plus(Rn.multiply(r, a))
              .plus(Rn.multiply(n, o))
              .plus(Rn.multiply(i, s))
              .low()),
            this
          )
        }
        plus(t) {
          let e = new Uint32Array(4)
          return (
            (e[3] = (this.buffer[3] + t.buffer[3]) >>> 0),
            (e[2] = (this.buffer[2] + t.buffer[2]) >>> 0),
            (e[1] = (this.buffer[1] + t.buffer[1]) >>> 0),
            (e[0] = (this.buffer[0] + t.buffer[0]) >>> 0),
            e[0] < this.buffer[0] >>> 0 && ++e[1],
            e[1] < this.buffer[1] >>> 0 && ++e[2],
            e[2] < this.buffer[2] >>> 0 && ++e[3],
            (this.buffer[3] = e[3]),
            (this.buffer[2] = e[2]),
            (this.buffer[1] = e[1]),
            (this.buffer[0] = e[0]),
            this
          )
        }
        hex() {
          return `${En(this.buffer[3])} ${En(this.buffer[2])} ${En(
            this.buffer[1]
          )} ${En(this.buffer[0])}`
        }
        static multiply(t, e) {
          return new kn(new Uint32Array(t.buffer)).times(e)
        }
        static add(t, e) {
          return new kn(new Uint32Array(t.buffer)).plus(e)
        }
        static from(t, e = new Uint32Array(4)) {
          return kn.fromString("string" == typeof t ? t : t.toString(), e)
        }
        static fromNumber(t, e = new Uint32Array(4)) {
          return kn.fromString(t.toString(), e)
        }
        static fromString(t, e = new Uint32Array(4)) {
          const r = t.startsWith("-"),
            n = t.length
          let i = new kn(e)
          for (let s = r ? 1 : 0; s < n; ) {
            const e = Nn < n - s ? Nn : n - s,
              r = new kn(
                new Uint32Array([parseInt(t.substr(s, e), 10), 0, 0, 0])
              ),
              o = new kn(new Uint32Array([Vn[e], 0, 0, 0]))
            i.times(o), i.plus(r), (s += e)
          }
          return r ? i.negate() : i
        }
        static convertArray(t) {
          const e = new Uint32Array(4 * t.length)
          for (let r = -1, n = t.length; ++r < n; )
            kn.from(t[r], new Uint32Array(e.buffer, e.byteOffset + 16 * r, 4))
          return e
        }
      }
      class zn extends N {
        constructor(t, e, r, n) {
          super(),
            (this.nodesIndex = -1),
            (this.buffersIndex = -1),
            (this.bytes = t),
            (this.nodes = e),
            (this.buffers = r),
            (this.dictionaries = n)
        }
        visit(t) {
          return super.visit(t instanceof Vr ? t.type : t)
        }
        visitNull(t, { length: e } = this.nextFieldNode()) {
          return Pt.Null(t, 0, e)
        }
        visitBool(t, { length: e, nullCount: r } = this.nextFieldNode()) {
          return Pt.Bool(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readData(t)
          )
        }
        visitInt(t, { length: e, nullCount: r } = this.nextFieldNode()) {
          return Pt.Int(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readData(t)
          )
        }
        visitFloat(t, { length: e, nullCount: r } = this.nextFieldNode()) {
          return Pt.Float(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readData(t)
          )
        }
        visitUtf8(t, { length: e, nullCount: r } = this.nextFieldNode()) {
          return Pt.Utf8(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readOffsets(t),
            this.readData(t)
          )
        }
        visitBinary(t, { length: e, nullCount: r } = this.nextFieldNode()) {
          return Pt.Binary(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readOffsets(t),
            this.readData(t)
          )
        }
        visitFixedSizeBinary(
          t,
          { length: e, nullCount: r } = this.nextFieldNode()
        ) {
          return Pt.FixedSizeBinary(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readData(t)
          )
        }
        visitDate(t, { length: e, nullCount: r } = this.nextFieldNode()) {
          return Pt.Date(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readData(t)
          )
        }
        visitTimestamp(t, { length: e, nullCount: r } = this.nextFieldNode()) {
          return Pt.Timestamp(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readData(t)
          )
        }
        visitTime(t, { length: e, nullCount: r } = this.nextFieldNode()) {
          return Pt.Time(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readData(t)
          )
        }
        visitDecimal(t, { length: e, nullCount: r } = this.nextFieldNode()) {
          return Pt.Decimal(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readData(t)
          )
        }
        visitList(t, { length: e, nullCount: r } = this.nextFieldNode()) {
          return Pt.List(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readOffsets(t),
            this.visit(t.children[0])
          )
        }
        visitStruct(t, { length: e, nullCount: r } = this.nextFieldNode()) {
          return Pt.Struct(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.visitMany(t.children)
          )
        }
        visitUnion(t) {
          return t.mode === I.Sparse
            ? this.visitSparseUnion(t)
            : this.visitDenseUnion(t)
        }
        visitDenseUnion(
          t,
          { length: e, nullCount: r } = this.nextFieldNode()
        ) {
          return Pt.Union(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readTypeIds(t),
            this.readOffsets(t),
            this.visitMany(t.children)
          )
        }
        visitSparseUnion(
          t,
          { length: e, nullCount: r } = this.nextFieldNode()
        ) {
          return Pt.Union(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readTypeIds(t),
            this.visitMany(t.children)
          )
        }
        visitDictionary(
          t,
          { length: e, nullCount: r } = this.nextFieldNode()
        ) {
          return Pt.Dictionary(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readData(t.indices),
            this.readDictionary(t)
          )
        }
        visitInterval(t, { length: e, nullCount: r } = this.nextFieldNode()) {
          return Pt.Interval(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readData(t)
          )
        }
        visitFixedSizeList(
          t,
          { length: e, nullCount: r } = this.nextFieldNode()
        ) {
          return Pt.FixedSizeList(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.visit(t.children[0])
          )
        }
        visitMap(t, { length: e, nullCount: r } = this.nextFieldNode()) {
          return Pt.Map(
            t,
            0,
            e,
            r,
            this.readNullBitmap(t, r),
            this.readOffsets(t),
            this.visit(t.children[0])
          )
        }
        nextFieldNode() {
          return this.nodes[++this.nodesIndex]
        }
        nextBufferRange() {
          return this.buffers[++this.buffersIndex]
        }
        readNullBitmap(t, e, r = this.nextBufferRange()) {
          return (e > 0 && this.readData(t, r)) || new Uint8Array(0)
        }
        readOffsets(t, e) {
          return this.readData(t, e)
        }
        readTypeIds(t, e) {
          return this.readData(t, e)
        }
        readData(t, { length: e, offset: r } = this.nextBufferRange()) {
          return this.bytes.subarray(r, r + e)
        }
        readDictionary(t) {
          return this.dictionaries.get(t.id)
        }
      }
      class Pn extends zn {
        constructor(t, e, r, n) {
          super(new Uint8Array(0), e, r, n), (this.sources = t)
        }
        readNullBitmap(t, e, { offset: r } = this.nextBufferRange()) {
          return e <= 0 ? new Uint8Array(0) : L(this.sources[r])
        }
        readOffsets(t, { offset: e } = this.nextBufferRange()) {
          return Object(kt.toArrayBufferView)(
            Uint8Array,
            Object(kt.toArrayBufferView)(Int32Array, this.sources[e])
          )
        }
        readTypeIds(t, { offset: e } = this.nextBufferRange()) {
          return Object(kt.toArrayBufferView)(
            Uint8Array,
            Object(kt.toArrayBufferView)(t.ArrayType, this.sources[e])
          )
        }
        readData(t, { offset: e } = this.nextBufferRange()) {
          const { sources: r } = this
          return J.isTimestamp(t)
            ? Object(kt.toArrayBufferView)(Uint8Array, jn.convertArray(r[e]))
            : (J.isInt(t) || J.isTime(t)) && 64 === t.bitWidth
            ? Object(kt.toArrayBufferView)(Uint8Array, jn.convertArray(r[e]))
            : J.isDate(t) && t.unit === m.MILLISECOND
            ? Object(kt.toArrayBufferView)(Uint8Array, jn.convertArray(r[e]))
            : J.isDecimal(t)
            ? Object(kt.toArrayBufferView)(Uint8Array, kn.convertArray(r[e]))
            : J.isBinary(t) || J.isFixedSizeBinary(t)
            ? (function(t) {
                const e = t.join(""),
                  r = new Uint8Array(e.length / 2)
                for (let n = 0; n < e.length; n += 2)
                  r[n >> 1] = parseInt(e.substr(n, 2), 16)
                return r
              })(r[e])
            : J.isBool(t)
            ? L(r[e])
            : J.isUtf8(t)
            ? Object(Xe.b)(r[e].join(""))
            : Object(kt.toArrayBufferView)(
                Uint8Array,
                Object(kt.toArrayBufferView)(t.ArrayType, r[e].map(t => +t))
              )
        }
      }
      var Yn = bn.a.Long,
        $n = c.apache.arrow.flatbuf.Null,
        Wn = c.apache.arrow.flatbuf.Int,
        Hn = c.apache.arrow.flatbuf.FloatingPoint,
        Kn = c.apache.arrow.flatbuf.Binary,
        Jn = c.apache.arrow.flatbuf.Bool,
        Gn = c.apache.arrow.flatbuf.Utf8,
        qn = c.apache.arrow.flatbuf.Decimal,
        Zn = c.apache.arrow.flatbuf.Date,
        Xn = c.apache.arrow.flatbuf.Time,
        Qn = c.apache.arrow.flatbuf.Timestamp,
        ti = c.apache.arrow.flatbuf.Interval,
        ei = c.apache.arrow.flatbuf.List,
        ri = c.apache.arrow.flatbuf.Struct_,
        ni = c.apache.arrow.flatbuf.Union,
        ii = c.apache.arrow.flatbuf.DictionaryEncoding,
        si = c.apache.arrow.flatbuf.FixedSizeBinary,
        oi = c.apache.arrow.flatbuf.FixedSizeList,
        ai = c.apache.arrow.flatbuf.Map
      const ui = new (class extends N {
        visit(t, e) {
          return null == t || null == e ? void 0 : super.visit(t, e)
        }
        visitNull(t, e) {
          return $n.startNull(e), $n.endNull(e)
        }
        visitInt(t, e) {
          return (
            Wn.startInt(e),
            Wn.addBitWidth(e, t.bitWidth),
            Wn.addIsSigned(e, t.isSigned),
            Wn.endInt(e)
          )
        }
        visitFloat(t, e) {
          return (
            Hn.startFloatingPoint(e),
            Hn.addPrecision(e, t.precision),
            Hn.endFloatingPoint(e)
          )
        }
        visitBinary(t, e) {
          return Kn.startBinary(e), Kn.endBinary(e)
        }
        visitBool(t, e) {
          return Jn.startBool(e), Jn.endBool(e)
        }
        visitUtf8(t, e) {
          return Gn.startUtf8(e), Gn.endUtf8(e)
        }
        visitDecimal(t, e) {
          return (
            qn.startDecimal(e),
            qn.addScale(e, t.scale),
            qn.addPrecision(e, t.precision),
            qn.endDecimal(e)
          )
        }
        visitDate(t, e) {
          return Zn.startDate(e), Zn.addUnit(e, t.unit), Zn.endDate(e)
        }
        visitTime(t, e) {
          return (
            Xn.startTime(e),
            Xn.addUnit(e, t.unit),
            Xn.addBitWidth(e, t.bitWidth),
            Xn.endTime(e)
          )
        }
        visitTimestamp(t, e) {
          const r = (t.timezone && e.createString(t.timezone)) || void 0
          return (
            Qn.startTimestamp(e),
            Qn.addUnit(e, t.unit),
            void 0 !== r && Qn.addTimezone(e, r),
            Qn.endTimestamp(e)
          )
        }
        visitInterval(t, e) {
          return ti.startInterval(e), ti.addUnit(e, t.unit), ti.endInterval(e)
        }
        visitList(t, e) {
          return ei.startList(e), ei.endList(e)
        }
        visitStruct(t, e) {
          return ri.startStruct_(e), ri.endStruct_(e)
        }
        visitUnion(t, e) {
          ni.startTypeIdsVector(e, t.typeIds.length)
          const r = ni.createTypeIdsVector(e, t.typeIds)
          return (
            ni.startUnion(e),
            ni.addMode(e, t.mode),
            ni.addTypeIds(e, r),
            ni.endUnion(e)
          )
        }
        visitDictionary(t, e) {
          const r = this.visit(t.indices, e)
          return (
            ii.startDictionaryEncoding(e),
            ii.addId(e, new Yn(t.id, 0)),
            ii.addIsOrdered(e, t.isOrdered),
            void 0 !== r && ii.addIndexType(e, r),
            ii.endDictionaryEncoding(e)
          )
        }
        visitFixedSizeBinary(t, e) {
          return (
            si.startFixedSizeBinary(e),
            si.addByteWidth(e, t.byteWidth),
            si.endFixedSizeBinary(e)
          )
        }
        visitFixedSizeList(t, e) {
          return (
            oi.startFixedSizeList(e),
            oi.addListSize(e, t.listSize),
            oi.endFixedSizeList(e)
          )
        }
        visitMap(t, e) {
          return (
            ai.startMap(e), ai.addKeysSorted(e, t.keysSorted), ai.endMap(e)
          )
        }
      })()
      function ci(t) {
        return new Ui(
          t.count,
          (function t(e) {
            return (e || []).reduce(
              (e, r) => [
                ...e,
                new xi(r.count, hi(r.VALIDITY)),
                ...t(r.children),
              ],
              []
            )
          })(t.columns),
          (function t(e, r = []) {
            for (let n = -1, i = (e || []).length; ++n < i; ) {
              const i = e[n]
              i.VALIDITY && r.push(new Fi(r.length, i.VALIDITY.length)),
                i.TYPE && r.push(new Fi(r.length, i.TYPE.length)),
                i.OFFSET && r.push(new Fi(r.length, i.OFFSET.length)),
                i.DATA && r.push(new Fi(r.length, i.DATA.length)),
                (r = t(i.children, r))
            }
            return r
          })(t.columns)
        )
      }
      function li(t, e) {
        return (t.children || []).filter(Boolean).map(t => Vr.fromJSON(t, e))
      }
      function hi(t) {
        return (t || []).reduce((t, e) => t + +(0 === e), 0)
      }
      function di(t) {
        return new Map(Object.entries(t || {}))
      }
      function fi(t) {
        return new q(t.isSigned, t.bitWidth)
      }
      function pi(t, e) {
        const r = t.type.name
        switch (r) {
          case "NONE":
          case "null":
            return new G()
          case "binary":
            return new ct()
          case "utf8":
            return new lt()
          case "bool":
            return new ht()
          case "list":
            return new Ut((e || [])[0])
          case "struct":
          case "struct_":
            return new Lt(e || [])
        }
        switch (r) {
          case "int": {
            const e = t.type
            return new q(e.isSigned, e.bitWidth)
          }
          case "floatingpoint": {
            const e = t.type
            return new st(v[e.precision])
          }
          case "decimal": {
            const e = t.type
            return new dt(e.scale, e.precision)
          }
          case "date": {
            const e = t.type
            return new ft(m[e.unit])
          }
          case "time": {
            const e = t.type
            return new bt(w[e.unit], e.bitWidth)
          }
          case "timestamp": {
            const e = t.type
            return new vt(w[e.unit], e.timezone)
          }
          case "interval": {
            const e = t.type
            return new Tt(A[e.unit])
          }
          case "union": {
            const r = t.type
            return new Ft(I[r.mode], r.typeIds || [], e || [])
          }
          case "fixedsizebinary": {
            const e = t.type
            return new Et(e.byteWidth)
          }
          case "fixedsizelist": {
            const r = t.type
            return new Nt(r.listSize, (e || [])[0])
          }
          case "map": {
            const r = t.type
            return new Vt((e || [])[0], r.keysSorted)
          }
        }
        throw Error(`Unrecognized type: "${r}"`)
      }
      var yi = bn.a.Long,
        bi = bn.a.Builder,
        gi = bn.a.ByteBuffer,
        _i = c.apache.arrow.flatbuf.Type,
        mi = c.apache.arrow.flatbuf.Field,
        wi = c.apache.arrow.flatbuf.Schema,
        vi = c.apache.arrow.flatbuf.Buffer,
        Ii = f.apache.arrow.flatbuf.Message,
        Ai = c.apache.arrow.flatbuf.KeyValue,
        Bi = f.apache.arrow.flatbuf.FieldNode,
        Si = c.apache.arrow.flatbuf.Endianness,
        Ti = f.apache.arrow.flatbuf.RecordBatch,
        Oi = f.apache.arrow.flatbuf.DictionaryBatch
      class Di {
        constructor(t, e, r, n) {
          ;(this._version = e),
            (this._headerType = r),
            (this.body = new Uint8Array(0)),
            n && (this._createHeader = () => n),
            (this._bodyLength = "number" == typeof t ? t : t.low)
        }
        static fromJSON(t, e) {
          const r = new Di(0, S.V4, e)
          return (
            (r._createHeader = (function(t, e) {
              return () => {
                switch (e) {
                  case B.Schema:
                    return Nr.fromJSON(t)
                  case B.RecordBatch:
                    return Ui.fromJSON(t)
                  case B.DictionaryBatch:
                    return Li.fromJSON(t)
                }
                throw Error(
                  `Unrecognized Message type: { name: ${B[e]}, type: ${e} }`
                )
              }
            })(t, e)),
            r
          )
        }
        static decode(t) {
          t = new gi(Object(kt.toUint8Array)(t))
          const e = Ii.getRootAsMessage(t),
            r = e.bodyLength(),
            n = e.version(),
            i = e.headerType(),
            s = new Di(r, n, i)
          return (
            (s._createHeader = (function(t, e) {
              return () => {
                switch (e) {
                  case B.Schema:
                    return Nr.decode(t.header(new wi()))
                  case B.RecordBatch:
                    return Ui.decode(t.header(new Ti()), t.version())
                  case B.DictionaryBatch:
                    return Li.decode(t.header(new Oi()), t.version())
                }
                throw Error(
                  `Unrecognized Message type: { name: ${B[e]}, type: ${e} }`
                )
              }
            })(e, i)),
            s
          )
        }
        static encode(t) {
          let e = new bi(),
            r = -1
          return (
            t.isSchema()
              ? (r = Nr.encode(e, t.header()))
              : t.isRecordBatch()
              ? (r = Ui.encode(e, t.header()))
              : t.isDictionaryBatch() && (r = Li.encode(e, t.header())),
            Ii.startMessage(e),
            Ii.addVersion(e, S.V4),
            Ii.addHeader(e, r),
            Ii.addHeaderType(e, t.headerType),
            Ii.addBodyLength(e, new yi(t.bodyLength, 0)),
            Ii.finishMessageBuffer(e, Ii.endMessage(e)),
            e.asUint8Array()
          )
        }
        static from(t, e = 0) {
          if (t instanceof Nr) return new Di(0, S.V4, B.Schema, t)
          if (t instanceof Ui) return new Di(e, S.V4, B.RecordBatch, t)
          if (t instanceof Li) return new Di(e, S.V4, B.DictionaryBatch, t)
          throw Error(`Unrecognized Message header: ${t}`)
        }
        get type() {
          return this.headerType
        }
        get version() {
          return this._version
        }
        get headerType() {
          return this._headerType
        }
        get bodyLength() {
          return this._bodyLength
        }
        header() {
          return this._createHeader()
        }
        isSchema() {
          return this.headerType === B.Schema
        }
        isRecordBatch() {
          return this.headerType === B.RecordBatch
        }
        isDictionaryBatch() {
          return this.headerType === B.DictionaryBatch
        }
      }
      class Ui {
        get nodes() {
          return this._nodes
        }
        get length() {
          return this._length
        }
        get buffers() {
          return this._buffers
        }
        constructor(t, e, r) {
          ;(this._nodes = e),
            (this._buffers = r),
            (this._length = "number" == typeof t ? t : t.low)
        }
      }
      class Li {
        get id() {
          return this._id
        }
        get data() {
          return this._data
        }
        get isDelta() {
          return this._isDelta
        }
        get length() {
          return this.data.length
        }
        get nodes() {
          return this.data.nodes
        }
        get buffers() {
          return this.data.buffers
        }
        constructor(t, e, r = !1) {
          ;(this._data = t),
            (this._isDelta = r),
            (this._id = "number" == typeof e ? e : e.low)
        }
      }
      class Fi {
        constructor(t, e) {
          ;(this.offset = "number" == typeof t ? t : t.low),
            (this.length = "number" == typeof e ? e : e.low)
        }
      }
      class xi {
        constructor(t, e) {
          ;(this.length = "number" == typeof t ? t : t.low),
            (this.nullCount = "number" == typeof e ? e : e.low)
        }
      }
      function Mi(t, e) {
        const r = []
        for (let n, i = -1, s = -1, o = t.childrenLength(); ++i < o; )
          (n = t.children(i)) && (r[++s] = Vr.decode(n, e))
        return r
      }
      function Ei(t) {
        const e = new Map()
        if (t)
          for (let r, n, i = -1, s = 0 | t.customMetadataLength(); ++i < s; )
            (r = t.customMetadata(i)) &&
              null != (n = r.key()) &&
              e.set(n, r.value())
        return e
      }
      function Ni(t) {
        return new q(t.isSigned(), t.bitWidth())
      }
      function Vi(t, e) {
        const r = t.typeType()
        switch (r) {
          case _i.NONE:
          case _i.Null:
            return new G()
          case _i.Binary:
            return new ct()
          case _i.Utf8:
            return new lt()
          case _i.Bool:
            return new ht()
          case _i.List:
            return new Ut((e || [])[0])
          case _i.Struct_:
            return new Lt(e || [])
        }
        switch (r) {
          case _i.Int: {
            const e = t.type(new c.apache.arrow.flatbuf.Int())
            return new q(e.isSigned(), e.bitWidth())
          }
          case _i.FloatingPoint: {
            const e = t.type(new c.apache.arrow.flatbuf.FloatingPoint())
            return new st(e.precision())
          }
          case _i.Decimal: {
            const e = t.type(new c.apache.arrow.flatbuf.Decimal())
            return new dt(e.scale(), e.precision())
          }
          case _i.Date: {
            const e = t.type(new c.apache.arrow.flatbuf.Date())
            return new ft(e.unit())
          }
          case _i.Time: {
            const e = t.type(new c.apache.arrow.flatbuf.Time())
            return new bt(e.unit(), e.bitWidth())
          }
          case _i.Timestamp: {
            const e = t.type(new c.apache.arrow.flatbuf.Timestamp())
            return new vt(e.unit(), e.timezone())
          }
          case _i.Interval: {
            const e = t.type(new c.apache.arrow.flatbuf.Interval())
            return new Tt(e.unit())
          }
          case _i.Union: {
            const r = t.type(new c.apache.arrow.flatbuf.Union())
            return new Ft(r.mode(), r.typeIdsArray() || [], e || [])
          }
          case _i.FixedSizeBinary: {
            const e = t.type(new c.apache.arrow.flatbuf.FixedSizeBinary())
            return new Et(e.byteWidth())
          }
          case _i.FixedSizeList: {
            const r = t.type(new c.apache.arrow.flatbuf.FixedSizeList())
            return new Nt(r.listSize(), (e || [])[0])
          }
          case _i.Map: {
            const r = t.type(new c.apache.arrow.flatbuf.Map())
            return new Vt((e || [])[0], r.keysSorted())
          }
        }
        throw Error(`Unrecognized type: "${_i[r]}" (${r})`)
      }
      ;(Vr.encode = function(t, e) {
        let r = -1,
          n = -1,
          i = -1,
          s = e.type,
          o = e.typeId
        J.isDictionary(s)
          ? ((o = s.dictionary.typeId),
            (i = ui.visit(s, t)),
            (n = ui.visit(s.dictionary, t)))
          : (n = ui.visit(s, t))
        const a = (s.children || []).map(e => Vr.encode(t, e)),
          u = mi.createChildrenVector(t, a),
          c =
            e.metadata && e.metadata.size > 0
              ? mi.createCustomMetadataVector(
                  t,
                  [...e.metadata].map(([e, r]) => {
                    const n = t.createString(`${e}`),
                      i = t.createString(`${r}`)
                    return (
                      Ai.startKeyValue(t),
                      Ai.addKey(t, n),
                      Ai.addValue(t, i),
                      Ai.endKeyValue(t)
                    )
                  })
                )
              : -1
        e.name && (r = t.createString(e.name))
        mi.startField(t),
          mi.addType(t, n),
          mi.addTypeType(t, o),
          mi.addChildren(t, u),
          mi.addNullable(t, !!e.nullable),
          -1 !== r && mi.addName(t, r)
        ;-1 !== i && mi.addDictionary(t, i)
        ;-1 !== c && mi.addCustomMetadata(t, c)
        return mi.endField(t)
      }),
        (Vr.decode = function(t, e) {
          let r, n, i, s, o, a
          e && (a = t.dictionary())
            ? e.has((r = a.id().low))
              ? ((s = (s = a.indexType()) ? Ni(s) : new Q()),
                (o = new Rt(e.get(r), s, r, a.isOrdered())),
                (n = new Vr(t.name(), o, t.nullable(), Ei(t))))
              : ((s = (s = a.indexType()) ? Ni(s) : new Q()),
                e.set(r, (i = Vi(t, Mi(t, e)))),
                (o = new Rt(i, s, r, a.isOrdered())),
                (n = new Vr(t.name(), o, t.nullable(), Ei(t))))
            : ((i = Vi(t, Mi(t, e))),
              (n = new Vr(t.name(), i, t.nullable(), Ei(t))))
          return n || null
        }),
        (Vr.fromJSON = function(t, e) {
          let r, n, i, s, o, a
          return (
            e && (s = t.dictionary)
              ? e.has((r = s.id))
                ? ((n = (n = s.indexType) ? fi(n) : new Q()),
                  (a = new Rt(e.get(r), n, r, s.isOrdered)),
                  (i = new Vr(t.name, a, t.nullable, di(t.customMetadata))))
                : ((n = (n = s.indexType) ? fi(n) : new Q()),
                  e.set(r, (o = pi(t, li(t, e)))),
                  (a = new Rt(o, n, r, s.isOrdered)),
                  (i = new Vr(t.name, a, t.nullable, di(t.customMetadata))))
              : ((o = pi(t, li(t, e))),
                (i = new Vr(t.name, o, t.nullable, di(t.customMetadata)))),
            i || null
          )
        }),
        (Nr.encode = function(t, e) {
          const r = e.fields.map(e => Vr.encode(t, e))
          wi.startFieldsVector(t, r.length)
          const n = wi.createFieldsVector(t, r),
            i =
              e.metadata && e.metadata.size > 0
                ? wi.createCustomMetadataVector(
                    t,
                    [...e.metadata].map(([e, r]) => {
                      const n = t.createString(`${e}`),
                        i = t.createString(`${r}`)
                      return (
                        Ai.startKeyValue(t),
                        Ai.addKey(t, n),
                        Ai.addValue(t, i),
                        Ai.endKeyValue(t)
                      )
                    })
                  )
                : -1
          wi.startSchema(t),
            wi.addFields(t, n),
            wi.addEndianness(t, Ci ? Si.Little : Si.Big),
            -1 !== i && wi.addCustomMetadata(t, i)
          return wi.endSchema(t)
        }),
        (Nr.decode = function(t, e = new Map()) {
          const r = (function(t, e) {
            const r = []
            for (let n, i = -1, s = -1, o = t.fieldsLength(); ++i < o; )
              (n = t.fields(i)) && (r[++s] = Vr.decode(n, e))
            return r
          })(t, e)
          return new Nr(r, Ei(t), e)
        }),
        (Nr.fromJSON = function(t, e = new Map()) {
          return new Nr(
            (function(t, e) {
              return (t.fields || [])
                .filter(Boolean)
                .map(t => Vr.fromJSON(t, e))
            })(t, e),
            di(t.customMetadata),
            e
          )
        }),
        (Ui.encode = function(t, e) {
          const r = e.nodes || [],
            n = e.buffers || []
          Ti.startNodesVector(t, r.length),
            r
              .slice()
              .reverse()
              .forEach(e => xi.encode(t, e))
          const i = t.endVector()
          Ti.startBuffersVector(t, n.length),
            n
              .slice()
              .reverse()
              .forEach(e => Fi.encode(t, e))
          const s = t.endVector()
          return (
            Ti.startRecordBatch(t),
            Ti.addLength(t, new yi(e.length, 0)),
            Ti.addNodes(t, i),
            Ti.addBuffers(t, s),
            Ti.endRecordBatch(t)
          )
        }),
        (Ui.decode = function(t, e = S.V4) {
          return new Ui(
            t.length(),
            (function(t) {
              const e = []
              for (let r, n = -1, i = -1, s = t.nodesLength(); ++n < s; )
                (r = t.nodes(n)) && (e[++i] = xi.decode(r))
              return e
            })(t),
            (function(t, e) {
              const r = []
              for (let n, i = -1, s = -1, o = t.buffersLength(); ++i < o; )
                (n = t.buffers(i)) &&
                  (e < S.V4 && (n.bb_pos += 8 * (i + 1)),
                  (r[++s] = Fi.decode(n)))
              return r
            })(t, e)
          )
        }),
        (Ui.fromJSON = ci),
        (Li.encode = function(t, e) {
          const r = Ui.encode(t, e.data)
          return (
            Oi.startDictionaryBatch(t),
            Oi.addId(t, new yi(e.id, 0)),
            Oi.addIsDelta(t, e.isDelta),
            Oi.addData(t, r),
            Oi.endDictionaryBatch(t)
          )
        }),
        (Li.decode = function(t, e = S.V4) {
          return new Li(Ui.decode(t.data(), e), t.id(), t.isDelta())
        }),
        (Li.fromJSON = function(t) {
          return new Li(ci(t.data), t.id, t.isDelta)
        }),
        (xi.encode = function(t, e) {
          return Bi.createFieldNode(
            t,
            new yi(e.length, 0),
            new yi(e.nullCount, 0)
          )
        }),
        (xi.decode = function(t) {
          return new xi(t.length(), t.nullCount())
        }),
        (Fi.encode = function(t, e) {
          return vi.createBuffer(t, new yi(e.offset, 0), new yi(e.length, 0))
        }),
        (Fi.decode = function(t) {
          return new Fi(t.offset(), t.length())
        })
      const Ci = (function() {
        const t = new ArrayBuffer(2)
        return (
          new DataView(t).setInt16(0, 256, !0), 256 === new Int16Array(t)[0]
        )
      })()
      var Ri = bn.a.ByteBuffer
      const ji = t =>
          `Expected ${B[t]} Message in stream, but was null or length 0.`,
        ki = t =>
          `Header pointer of flatbuffer-encoded ${B[t]} Message is null or length 0.`,
        zi = (t, e) =>
          `Expected to read ${t} metadata bytes, but only read ${e}.`,
        Pi = (t, e) =>
          `Expected to read ${t} bytes for message body, but only read ${e}.`
      class Yi {
        constructor(t) {
          this.source = t instanceof On ? t : new On(t)
        }
        [Symbol.iterator]() {
          return this
        }
        next() {
          let t
          return (t = this.readMetadataLength()).done
            ? Sn.c
            : -1 === t.value && (t = this.readMetadataLength()).done
            ? Sn.c
            : (t = this.readMetadata(t.value)).done
            ? Sn.c
            : t
        }
        throw(t) {
          return this.source.throw(t)
        }
        return(t) {
          return this.source.return(t)
        }
        readMessage(t) {
          let e
          if ((e = this.next()).done) return null
          if (null != t && e.value.headerType !== t) throw Error(ji(t))
          return e.value
        }
        readMessageBody(t) {
          if (t <= 0) return new Uint8Array(0)
          const e = Object(kt.toUint8Array)(this.source.read(t))
          if (e.byteLength < t) throw Error(Pi(t, e.byteLength))
          return e.byteOffset % 8 == 0 &&
            e.byteOffset + e.byteLength <= e.buffer.byteLength
            ? e
            : e.slice()
        }
        readSchema(t = !1) {
          const e = B.Schema,
            r = this.readMessage(e),
            n = r && r.header()
          if (t && !n) throw Error(ki(e))
          return n
        }
        readMetadataLength() {
          const t = this.source.read(Hi),
            e = t && new Ri(t),
            r = (e && e.readInt32(0)) || 0
          return { done: 0 === r, value: r }
        }
        readMetadata(t) {
          const e = this.source.read(t)
          if (!e) return Sn.c
          if (e.byteLength < t) throw Error(zi(t, e.byteLength))
          return { done: !1, value: Di.decode(e) }
        }
      }
      class $i {
        constructor(t, e) {
          this.source =
            t instanceof Dn ? t : Object(Wt.h)(t) ? new xn(t, e) : new Dn(t)
        }
        [Symbol.asyncIterator]() {
          return this
        }
        async next() {
          let t
          return (t = await this.readMetadataLength()).done
            ? Sn.c
            : -1 === t.value && (t = await this.readMetadataLength()).done
            ? Sn.c
            : (t = await this.readMetadata(t.value)).done
            ? Sn.c
            : t
        }
        async throw(t) {
          return await this.source.throw(t)
        }
        async return(t) {
          return await this.source.return(t)
        }
        async readMessage(t) {
          let e
          if ((e = await this.next()).done) return null
          if (null != t && e.value.headerType !== t) throw Error(ji(t))
          return e.value
        }
        async readMessageBody(t) {
          if (t <= 0) return new Uint8Array(0)
          const e = Object(kt.toUint8Array)(await this.source.read(t))
          if (e.byteLength < t) throw Error(Pi(t, e.byteLength))
          return e.byteOffset % 8 == 0 &&
            e.byteOffset + e.byteLength <= e.buffer.byteLength
            ? e
            : e.slice()
        }
        async readSchema(t = !1) {
          const e = B.Schema,
            r = await this.readMessage(e),
            n = r && r.header()
          if (t && !n) throw Error(ki(e))
          return n
        }
        async readMetadataLength() {
          const t = await this.source.read(Hi),
            e = t && new Ri(t),
            r = (e && e.readInt32(0)) || 0
          return { done: 0 === r, value: r }
        }
        async readMetadata(t) {
          const e = await this.source.read(t)
          if (!e) return Sn.c
          if (e.byteLength < t) throw Error(zi(t, e.byteLength))
          return { done: !1, value: Di.decode(e) }
        }
      }
      class Wi extends Yi {
        constructor(t) {
          super(new Uint8Array(0)),
            (this._schema = !1),
            (this._body = []),
            (this._batchIndex = 0),
            (this._dictionaryIndex = 0),
            (this._json = t instanceof Sn.a ? t : new Sn.a(t))
        }
        next() {
          const { _json: t } = this
          if (!this._schema) {
            return (
              (this._schema = !0),
              { done: !1, value: Di.fromJSON(t.schema, B.Schema) }
            )
          }
          if (this._dictionaryIndex < t.dictionaries.length) {
            const e = t.dictionaries[this._dictionaryIndex++]
            return (
              (this._body = e.data.columns),
              { done: !1, value: Di.fromJSON(e, B.DictionaryBatch) }
            )
          }
          if (this._batchIndex < t.batches.length) {
            const e = t.batches[this._batchIndex++]
            return (
              (this._body = e.columns),
              { done: !1, value: Di.fromJSON(e, B.RecordBatch) }
            )
          }
          return (this._body = []), Sn.c
        }
        readMessageBody(t) {
          return (function t(e) {
            return (e || []).reduce(
              (e, r) => [
                ...e,
                ...((r.VALIDITY && [r.VALIDITY]) || []),
                ...((r.TYPE && [r.TYPE]) || []),
                ...((r.OFFSET && [r.OFFSET]) || []),
                ...((r.DATA && [r.DATA]) || []),
                ...t(r.children),
              ],
              []
            )
          })(this._body)
        }
        readMessage(t) {
          let e
          if ((e = this.next()).done) return null
          if (null != t && e.value.headerType !== t) throw Error(ji(t))
          return e.value
        }
        readSchema() {
          const t = B.Schema,
            e = this.readMessage(t),
            r = e && e.header()
          if (!e || !r) throw Error(ki(t))
          return r
        }
      }
      const Hi = 4,
        Ki = new Uint8Array(6)
      for (let Wa = 0; Wa < 6; Wa += 1) Ki[Wa] = "ARROW1".charCodeAt(Wa)
      function Ji(t, e = 0) {
        for (let r = -1, n = Ki.length; ++r < n; )
          if (Ki[r] !== t[e + r]) return !1
        return !0
      }
      const Gi = Ki.length,
        qi = Gi + Hi,
        Zi = 2 * Gi + Hi
      class Xi extends N {
        constructor() {
          super(),
            (this._byteLength = 0),
            (this._nodes = []),
            (this._buffers = []),
            (this._bufferRegions = [])
        }
        static assemble(...t) {
          const e = new Xi(),
            r = Lr(na, t),
            [n = e] = e.visitMany(r)
          return n
        }
        visit(t) {
          if (!J.isDictionary(t.type)) {
            const { data: e, length: r, nullCount: n } = t
            if (r > 2147483647)
              throw new RangeError(
                "Cannot write arrays larger than 2^31 - 1 in length"
              )
            J.isNull(t.type) ||
              Qi.call(
                this,
                n <= 0 ? new Uint8Array(0) : U(e.offset, r, e.nullBitmap)
              ),
              this.nodes.push(new xi(r, n))
          }
          return super.visit(t)
        }
        visitNull(t) {
          return this
        }
        visitDictionary(t) {
          return this.visit(t.indices)
        }
        get nodes() {
          return this._nodes
        }
        get buffers() {
          return this._buffers
        }
        get byteLength() {
          return this._byteLength
        }
        get bufferRegions() {
          return this._bufferRegions
        }
      }
      function Qi(t) {
        const e = (t.byteLength + 7) & -8
        return (
          this.buffers.push(t),
          this.bufferRegions.push(new Fi(this._byteLength, e)),
          (this._byteLength += e),
          this
        )
      }
      function ts(t) {
        return Qi.call(this, t.values.subarray(0, t.length * t.stride))
      }
      function es(t) {
        const { length: e, values: r, valueOffsets: n } = t,
          i = n[0],
          s = n[e],
          o = Math.min(s - i, r.byteLength - i)
        return (
          Qi.call(this, Object(kt.rebaseValueOffsets)(-n[0], e, n)),
          Qi.call(this, r.subarray(i, i + o)),
          this
        )
      }
      function rs(t) {
        const { length: e, valueOffsets: r } = t
        return (
          r && Qi.call(this, Object(kt.rebaseValueOffsets)(r[0], e, r)),
          this.visit(t.getChildAt(0))
        )
      }
      function ns(t) {
        return this.visitMany(
          t.type.children.map((e, r) => t.getChildAt(r)).filter(Boolean)
        )[0]
      }
      ;(Xi.prototype.visitBool = function(t) {
        let e
        return t.nullCount >= t.length
          ? Qi.call(this, new Uint8Array(0))
          : (e = t.values) instanceof Uint8Array
          ? Qi.call(this, U(t.offset, t.length, e))
          : Qi.call(this, L(t))
      }),
        (Xi.prototype.visitInt = ts),
        (Xi.prototype.visitFloat = ts),
        (Xi.prototype.visitUtf8 = es),
        (Xi.prototype.visitBinary = es),
        (Xi.prototype.visitFixedSizeBinary = ts),
        (Xi.prototype.visitDate = ts),
        (Xi.prototype.visitTimestamp = ts),
        (Xi.prototype.visitTime = ts),
        (Xi.prototype.visitDecimal = ts),
        (Xi.prototype.visitList = rs),
        (Xi.prototype.visitStruct = ns),
        (Xi.prototype.visitUnion = function(t) {
          const { type: e, length: r, typeIds: n, valueOffsets: i } = t
          if ((Qi.call(this, n), e.mode === I.Sparse)) return ns.call(this, t)
          if (e.mode === I.Dense) {
            if (t.offset <= 0) return Qi.call(this, i), ns.call(this, t)
            {
              const s = n.reduce((t, e) => Math.max(t, e), n[0]),
                o = new Int32Array(s + 1),
                a = new Int32Array(s + 1).fill(-1),
                u = new Int32Array(r),
                c = Object(kt.rebaseValueOffsets)(-i[0], r, i)
              for (let t, e, i = -1; ++i < r; )
                -1 === (e = a[(t = n[i])]) && (e = a[t] = c[t]),
                  (u[i] = c[i] - e),
                  ++o[t]
              Qi.call(this, u)
              for (let n, i = -1, l = e.children.length; ++i < l; )
                if ((n = t.getChildAt(i))) {
                  const t = e.typeIds[i],
                    s = Math.min(r, o[t])
                  this.visit(n.slice(a[t], s))
                }
            }
          }
          return this
        }),
        (Xi.prototype.visitInterval = ts),
        (Xi.prototype.visitFixedSizeList = rs),
        (Xi.prototype.visitMap = rs)
      class is extends N {
        visit(t) {
          return null == t ? void 0 : super.visit(t)
        }
        visitNull({ typeId: t }) {
          return { name: _[t].toLowerCase() }
        }
        visitInt({ typeId: t, bitWidth: e, isSigned: r }) {
          return { name: _[t].toLowerCase(), bitWidth: e, isSigned: r }
        }
        visitFloat({ typeId: t, precision: e }) {
          return { name: _[t].toLowerCase(), precision: v[e] }
        }
        visitBinary({ typeId: t }) {
          return { name: _[t].toLowerCase() }
        }
        visitBool({ typeId: t }) {
          return { name: _[t].toLowerCase() }
        }
        visitUtf8({ typeId: t }) {
          return { name: _[t].toLowerCase() }
        }
        visitDecimal({ typeId: t, scale: e, precision: r }) {
          return { name: _[t].toLowerCase(), scale: e, precision: r }
        }
        visitDate({ typeId: t, unit: e }) {
          return { name: _[t].toLowerCase(), unit: m[e] }
        }
        visitTime({ typeId: t, unit: e, bitWidth: r }) {
          return { name: _[t].toLowerCase(), unit: w[e], bitWidth: r }
        }
        visitTimestamp({ typeId: t, timezone: e, unit: r }) {
          return { name: _[t].toLowerCase(), unit: w[r], timezone: e }
        }
        visitInterval({ typeId: t, unit: e }) {
          return { name: _[t].toLowerCase(), unit: A[e] }
        }
        visitList({ typeId: t }) {
          return { name: _[t].toLowerCase() }
        }
        visitStruct({ typeId: t }) {
          return { name: _[t].toLowerCase() }
        }
        visitUnion({ typeId: t, mode: e, typeIds: r }) {
          return { name: _[t].toLowerCase(), mode: I[e], typeIds: [...r] }
        }
        visitDictionary(t) {
          return this.visit(t.dictionary)
        }
        visitFixedSizeBinary({ typeId: t, byteWidth: e }) {
          return { name: _[t].toLowerCase(), byteWidth: e }
        }
        visitFixedSizeList({ typeId: t, listSize: e }) {
          return { name: _[t].toLowerCase(), listSize: e }
        }
        visitMap({ typeId: t, keysSorted: e }) {
          return { name: _[t].toLowerCase(), keysSorted: e }
        }
      }
      class ss extends N {
        static assemble(...t) {
          return new ss().visitMany(Fr(na, t))
        }
        visit(t) {
          const { data: e, name: r, length: n } = t,
            { offset: i, nullCount: s, nullBitmap: o } = e,
            a = J.isDictionary(t.type) ? t.type.indices : t.type,
            u = Object.assign([], e.buffers, { [g.VALIDITY]: void 0 })
          return {
            name: r,
            count: n,
            VALIDITY: J.isNull(a)
              ? void 0
              : s <= 0
              ? Array.from({ length: n }, () => 1)
              : [...F(o, i, n, null, O)],
            ...super.visit(y.new(e.clone(a, i, n, 0, u))),
          }
        }
        visitNull() {
          return {}
        }
        visitBool({ values: t, offset: e, length: r }) {
          return { DATA: [...F(t, e, r, null, T)] }
        }
        visitInt(t) {
          return {
            DATA: t.type.bitWidth < 64 ? [...t.values] : [...as(t.values, 2)],
          }
        }
        visitFloat(t) {
          return { DATA: [...t.values] }
        }
        visitUtf8(t) {
          return { DATA: [...t], OFFSET: [...t.valueOffsets] }
        }
        visitBinary(t) {
          return { DATA: [...os(t)], OFFSET: [...t.valueOffsets] }
        }
        visitFixedSizeBinary(t) {
          return { DATA: [...os(t)] }
        }
        visitDate(t) {
          return {
            DATA: t.type.unit === m.DAY ? [...t.values] : [...as(t.values, 2)],
          }
        }
        visitTimestamp(t) {
          return { DATA: [...as(t.values, 2)] }
        }
        visitTime(t) {
          return {
            DATA:
              t.type.unit < w.MICROSECOND
                ? [...t.values]
                : [...as(t.values, 2)],
          }
        }
        visitDecimal(t) {
          return { DATA: [...as(t.values, 4)] }
        }
        visitList(t) {
          return {
            OFFSET: [...t.valueOffsets],
            children: t.type.children.map((e, r) =>
              this.visit(new Ar(e, [t.getChildAt(r)]))
            ),
          }
        }
        visitStruct(t) {
          return {
            children: t.type.children.map((e, r) =>
              this.visit(new Ar(e, [t.getChildAt(r)]))
            ),
          }
        }
        visitUnion(t) {
          return {
            TYPE: [...t.typeIds],
            OFFSET: t.type.mode === I.Dense ? [...t.valueOffsets] : void 0,
            children: t.type.children.map((e, r) =>
              this.visit(new Ar(e, [t.getChildAt(r)]))
            ),
          }
        }
        visitInterval(t) {
          return { DATA: [...t.values] }
        }
        visitFixedSizeList(t) {
          return {
            children: t.type.children.map((e, r) =>
              this.visit(new Ar(e, [t.getChildAt(r)]))
            ),
          }
        }
        visitMap(t) {
          return {
            OFFSET: [...t.valueOffsets],
            children: t.type.children.map((e, r) =>
              this.visit(new Ar(e, [t.getChildAt(r)]))
            ),
          }
        }
      }
      function* os(t) {
        for (const e of t)
          yield e
            .reduce(
              (t, e) => `${t}${("0" + (255 & e).toString(16)).slice(-2)}`,
              ""
            )
            .toUpperCase()
      }
      function* as(t, e) {
        for (let r = -1, n = t.length / e; ++r < n; )
          yield `${De.new(t.subarray((r + 0) * e, (r + 1) * e), !1)}`
      }
      class us extends Sn.d {
        constructor(t) {
          super(),
            (this._position = 0),
            (this._started = !1),
            (this._sink = new Tn()),
            (this._schema = null),
            (this._dictionaryBlocks = []),
            (this._recordBatchBlocks = []),
            (this._dictionaryDeltaOffsets = new Map()),
            Object(Wt.k)(t) ||
              (t = { autoDestroy: !0, writeLegacyIpcFormat: !1 }),
            (this._autoDestroy =
              "boolean" != typeof t.autoDestroy || t.autoDestroy),
            (this._writeLegacyIpcFormat =
              "boolean" == typeof t.writeLegacyIpcFormat &&
              t.writeLegacyIpcFormat)
        }
        static throughNode(t) {
          throw Error('"throughNode" not available in this environment')
        }
        static throughDOM(t, e) {
          throw Error('"throughDOM" not available in this environment')
        }
        toString(t = !1) {
          return this._sink.toString(t)
        }
        toUint8Array(t = !1) {
          return this._sink.toUint8Array(t)
        }
        writeAll(t) {
          return Object(Wt.l)(t)
            ? t.then(t => this.writeAll(t))
            : Object(Wt.f)(t)
            ? fs(this, t)
            : ds(this, t)
        }
        get closed() {
          return this._sink.closed
        }
        [Symbol.asyncIterator]() {
          return this._sink[Symbol.asyncIterator]()
        }
        toDOMStream(t) {
          return this._sink.toDOMStream(t)
        }
        toNodeStream(t) {
          return this._sink.toNodeStream(t)
        }
        close() {
          return this.reset()._sink.close()
        }
        abort(t) {
          return this.reset()._sink.abort(t)
        }
        finish() {
          return (
            this._autoDestroy
              ? this.close()
              : this.reset(this._sink, this._schema),
            this
          )
        }
        reset(t = this._sink, e = null) {
          return (
            t === this._sink || t instanceof Tn
              ? (this._sink = t)
              : ((this._sink = new Tn()),
                t && Object(Wt.o)(t)
                  ? this.toDOMStream({ type: "bytes" }).pipeTo(t)
                  : t &&
                    Object(Wt.p)(t) &&
                    this.toNodeStream({ objectMode: !1 }).pipe(t)),
            this._started && this._schema && this._writeFooter(this._schema),
            (this._started = !1),
            (this._dictionaryBlocks = []),
            (this._recordBatchBlocks = []),
            (this._dictionaryDeltaOffsets = new Map()),
            (e && e.compareTo(this._schema)) ||
              (null === e
                ? ((this._position = 0), (this._schema = null))
                : ((this._started = !0),
                  (this._schema = e),
                  this._writeSchema(e))),
            this
          )
        }
        write(t) {
          let e = null
          if (!this._sink) throw Error("RecordBatchWriter is closed")
          if (null == t) return this.finish() && void 0
          if (t instanceof ra && !(e = t.schema))
            return this.finish() && void 0
          if (t instanceof na && !(e = t.schema))
            return this.finish() && void 0
          if (e && !e.compareTo(this._schema)) {
            if (this._started && this._autoDestroy) return this.close()
            this.reset(this._sink, e)
          }
          t instanceof na
            ? t instanceof ia || this._writeRecordBatch(t)
            : t instanceof ra
            ? this.writeAll(t.chunks)
            : Object(Wt.i)(t) && this.writeAll(t)
        }
        _writeMessage(t, e = 8) {
          const r = e - 1,
            n = Di.encode(t),
            i = n.byteLength,
            s = this._writeLegacyIpcFormat ? 4 : 8,
            o = (i + s + r) & ~r,
            a = o - i - s
          return (
            t.headerType === B.RecordBatch
              ? this._recordBatchBlocks.push(
                  new Bn(o, t.bodyLength, this._position)
                )
              : t.headerType === B.DictionaryBatch &&
                this._dictionaryBlocks.push(
                  new Bn(o, t.bodyLength, this._position)
                ),
            this._writeLegacyIpcFormat || this._write(Int32Array.of(-1)),
            this._write(Int32Array.of(o - s)),
            i > 0 && this._write(n),
            this._writePadding(a)
          )
        }
        _write(t) {
          if (this._started) {
            const e = Object(kt.toUint8Array)(t)
            e &&
              e.byteLength > 0 &&
              (this._sink.write(e), (this._position += e.byteLength))
          }
          return this
        }
        _writeSchema(t) {
          return this._writeMessage(Di.from(t))
        }
        _writeFooter(t) {
          return this._writeLegacyIpcFormat
            ? this._write(Int32Array.of(0))
            : this._write(Int32Array.of(-1, 0))
        }
        _writeMagic() {
          return this._write(Ki)
        }
        _writePadding(t) {
          return t > 0 ? this._write(new Uint8Array(t)) : this
        }
        _writeRecordBatch(t) {
          const {
              byteLength: e,
              nodes: r,
              bufferRegions: n,
              buffers: i,
            } = Xi.assemble(t),
            s = new Ui(t.length, r, n),
            o = Di.from(s, e)
          return this._writeDictionaries(t)
            ._writeMessage(o)
            ._writeBodyBuffers(i)
        }
        _writeDictionaryBatch(t, e, r = !1) {
          this._dictionaryDeltaOffsets.set(
            e,
            t.length + (this._dictionaryDeltaOffsets.get(e) || 0)
          )
          const {
              byteLength: n,
              nodes: i,
              bufferRegions: s,
              buffers: o,
            } = Xi.assemble(t),
            a = new Ui(t.length, i, s),
            u = new Li(a, e, r),
            c = Di.from(u, n)
          return this._writeMessage(c)._writeBodyBuffers(o)
        }
        _writeBodyBuffers(t) {
          let e, r, n
          for (let i = -1, s = t.length; ++i < s; )
            (e = t[i]) &&
              (r = e.byteLength) > 0 &&
              (this._write(e),
              (n = ((r + 7) & -8) - r) > 0 && this._writePadding(n))
          return this
        }
        _writeDictionaries(t) {
          for (let [e, r] of t.dictionaries) {
            let t = this._dictionaryDeltaOffsets.get(e) || 0
            if (0 === t || (r = r.slice(t)).length > 0) {
              const n = "chunks" in r ? r.chunks : [r]
              for (const r of n)
                this._writeDictionaryBatch(r, e, t > 0), (t += r.length)
            }
          }
          return this
        }
      }
      class cs extends us {
        static writeAll(t, e) {
          const r = new cs(e)
          return Object(Wt.l)(t)
            ? t.then(t => r.writeAll(t))
            : Object(Wt.f)(t)
            ? fs(r, t)
            : ds(r, t)
        }
      }
      class ls extends us {
        constructor() {
          super(), (this._autoDestroy = !0)
        }
        static writeAll(t) {
          const e = new ls()
          return Object(Wt.l)(t)
            ? t.then(t => e.writeAll(t))
            : Object(Wt.f)(t)
            ? fs(e, t)
            : ds(e, t)
        }
        _writeSchema(t) {
          return this._writeMagic()._writePadding(2)
        }
        _writeFooter(t) {
          const e = In.encode(
            new In(t, S.V4, this._recordBatchBlocks, this._dictionaryBlocks)
          )
          return super
            ._writeFooter(t)
            ._write(e)
            ._write(Int32Array.of(e.byteLength))
            ._writeMagic()
        }
      }
      class hs extends us {
        constructor() {
          super(),
            (this._autoDestroy = !0),
            (this._recordBatches = []),
            (this._dictionaries = [])
        }
        static writeAll(t) {
          return new hs().writeAll(t)
        }
        _writeMessage() {
          return this
        }
        _writeFooter(t) {
          return this
        }
        _writeSchema(t) {
          return this._write(
            `{\n  "schema": ${JSON.stringify(
              { fields: t.fields.map(ps) },
              null,
              2
            )}`
          )
        }
        _writeDictionaries(t) {
          return t.dictionaries.size > 0 && this._dictionaries.push(t), this
        }
        _writeDictionaryBatch(t, e, r = !1) {
          return (
            this._dictionaryDeltaOffsets.set(
              e,
              t.length + (this._dictionaryDeltaOffsets.get(e) || 0)
            ),
            this._write(
              0 === this._dictionaryBlocks.length ? "    " : ",\n    "
            ),
            this._write(
              `${(function(t, e, r = !1) {
                const n = new Vr(`${e}`, t.type, t.nullCount > 0),
                  i = ss.assemble(new Ar(n, [t]))
                return JSON.stringify(
                  { id: e, isDelta: r, data: { count: t.length, columns: i } },
                  null,
                  2
                )
              })(t, e, r)}`
            ),
            this._dictionaryBlocks.push(new Bn(0, 0, 0)),
            this
          )
        }
        _writeRecordBatch(t) {
          return this._writeDictionaries(t), this._recordBatches.push(t), this
        }
        close() {
          if (this._dictionaries.length > 0) {
            this._write(',\n  "dictionaries": [\n')
            for (const t of this._dictionaries) super._writeDictionaries(t)
            this._write("\n  ]")
          }
          if (this._recordBatches.length > 0) {
            for (let e = -1, r = this._recordBatches.length; ++e < r; )
              this._write(0 === e ? ',\n  "batches": [\n    ' : ",\n    "),
                this._write(
                  `${((t = this._recordBatches[e]),
                  JSON.stringify(
                    { count: t.length, columns: ss.assemble(t) },
                    null,
                    2
                  ))}`
                ),
                this._recordBatchBlocks.push(new Bn(0, 0, 0))
            this._write("\n  ]")
          }
          var t
          return (
            this._schema && this._write("\n}"),
            (this._dictionaries = []),
            (this._recordBatches = []),
            super.close()
          )
        }
      }
      function ds(t, e) {
        let r = e
        e instanceof ra && ((r = e.chunks), t.reset(void 0, e.schema))
        for (const n of r) t.write(n)
        return t.finish()
      }
      async function fs(t, e) {
        for await (const r of e) t.write(r)
        return t.finish()
      }
      function ps({ name: t, type: e, nullable: r }) {
        const n = new is()
        return {
          name: t,
          nullable: r,
          type: n.visit(e),
          children: (e.children || []).map(ps),
          dictionary: J.isDictionary(e)
            ? {
                id: e.id,
                isOrdered: e.isOrdered,
                indexType: n.visit(e.indices),
              }
            : void 0,
        }
      }
      const ys = new Uint8Array(0),
        bs = t => [ys, ys, new Uint8Array(t), ys]
      function gs(t, e) {
        return (function(t, e) {
          const r = [...t.fields],
            n = [],
            i = { numBatches: e.reduce((t, e) => Math.max(t, e.length), 0) }
          let s,
            o = 0,
            a = 0,
            u = -1,
            c = e.length,
            l = []
          for (; i.numBatches-- > 0; ) {
            for (a = 1 / 0, u = -1; ++u < c; )
              (l[u] = s = e[u].shift()), (a = Math.min(a, s ? s.length : a))
            isFinite(a) &&
              ((l = _s(r, a, l, e, i)), a > 0 && (n[o++] = [a, l.slice()]))
          }
          return [(t = new Nr(r, t.metadata)), n.map(e => new na(t, ...e))]
        })(
          t,
          e.map(t => (t instanceof wr ? t.chunks.map(t => t.data) : [t.data]))
        )
      }
      function _s(t, e, r, n, i) {
        let s,
          o,
          a = 0,
          u = -1,
          c = n.length
        const l = ((e + 63) & -64) >> 3
        for (; ++u < c; )
          (s = r[u]) && (a = s.length) >= e
            ? a === e
              ? (r[u] = s)
              : ((r[u] = s.slice(0, e)),
                (s = s.slice(e, a - e)),
                (i.numBatches = Math.max(i.numBatches, n[u].unshift(s))))
            : ((o = t[u]).nullable || (t[u] = o.clone({ nullable: !0 })),
              (r[u] = s
                ? s._changeLengthAndBackfillNullBitmap(e)
                : Pt.new(o.type, 0, e, e, bs(l))))
        return r
      }
      class ms extends y {
        constructor(t, e) {
          super(),
            (this._children = e),
            (this.numChildren = t.childData.length),
            this._bindDataAccessors((this.data = t))
        }
        get type() {
          return this.data.type
        }
        get typeId() {
          return this.data.typeId
        }
        get length() {
          return this.data.length
        }
        get offset() {
          return this.data.offset
        }
        get stride() {
          return this.data.stride
        }
        get nullCount() {
          return this.data.nullCount
        }
        get byteLength() {
          return this.data.byteLength
        }
        get VectorName() {
          return `${b[this.typeId]}Vector`
        }
        get ArrayType() {
          return this.type.ArrayType
        }
        get values() {
          return this.data.values
        }
        get typeIds() {
          return this.data.typeIds
        }
        get nullBitmap() {
          return this.data.nullBitmap
        }
        get valueOffsets() {
          return this.data.valueOffsets
        }
        get [Symbol.toStringTag]() {
          return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`
        }
        clone(t, e = this._children) {
          return y.new(t, e)
        }
        concat(...t) {
          return wr.concat(this, ...t)
        }
        slice(t, e) {
          return pr(this, t, e, this._sliceInternal)
        }
        isValid(t) {
          if (this.nullCount > 0) {
            const e = this.offset + t
            return 0 !== (this.nullBitmap[e >> 3] & (1 << e % 8))
          }
          return !0
        }
        getChildAt(t) {
          return t < 0 || t >= this.numChildren
            ? null
            : (this._children || (this._children = []))[t] ||
                (this._children[t] = y.new(this.data.childData[t]))
        }
        toJSON() {
          return [...this]
        }
        _sliceInternal(t, e, r) {
          return t.clone(t.data.slice(e, r - e), null)
        }
        _bindDataAccessors(t) {}
      }
      ms.prototype[Symbol.isConcatSpreadable] = !0
      class ws extends ms {
        asUtf8() {
          return y.new(this.data.clone(new lt()))
        }
      }
      class vs extends ms {
        static from(t) {
          return ea(() => new ht(), t)
        }
      }
      class Is extends ms {
        static from(...t) {
          return 2 === t.length
            ? ea(() => (t[1] === m.DAY ? new pt() : new yt()), t[0])
            : ea(() => new yt(), t[0])
        }
      }
      class As extends Is {}
      class Bs extends Is {}
      class Ss extends ms {}
      class Ts extends ms {
        constructor(t) {
          super(t), (this.indices = y.new(t.clone(this.type.indices)))
        }
        static from(...t) {
          if (3 === t.length) {
            const [e, r, n] = t,
              i = new Rt(e.type, r, null, null)
            return y.new(Pt.Dictionary(i, 0, n.length, 0, null, n, e))
          }
          return ea(() => t[0].type, t[0])
        }
        get dictionary() {
          return this.data.dictionary
        }
        reverseLookup(t) {
          return this.dictionary.indexOf(t)
        }
        getKey(t) {
          return this.indices.get(t)
        }
        getValue(t) {
          return this.dictionary.get(t)
        }
        setKey(t, e) {
          return this.indices.set(t, e)
        }
        setValue(t, e) {
          return this.dictionary.set(t, e)
        }
      }
      Ts.prototype.indices = null
      class Os extends ms {}
      class Ds extends ms {}
      class Us extends ms {
        static from(t) {
          let e = Ns(this)
          if (t instanceof ArrayBuffer || ArrayBuffer.isView(t)) {
            let r = Es(t.constructor) || e
            if ((null === e && (e = r), e && e === r)) {
              let r = new e(),
                n = t.byteLength / r.ArrayType.BYTES_PER_ELEMENT
              if (!Ms(e, t.constructor))
                return y.new(Pt.Float(r, 0, n, 0, null, t))
            }
          }
          if (e) return ea(() => new e(), t)
          if (t instanceof DataView || t instanceof ArrayBuffer)
            throw new TypeError(
              `Cannot infer float type from instance of ${t.constructor.name}`
            )
          throw new TypeError("Unrecognized FloatVector input")
        }
      }
      class Ls extends Us {
        toFloat32Array() {
          return new Float32Array(this)
        }
        toFloat64Array() {
          return new Float64Array(this)
        }
      }
      class Fs extends Us {}
      class xs extends Us {}
      const Ms = (t, e) => t === ot && e !== Uint16Array,
        Es = t => {
          switch (t) {
            case Uint16Array:
              return ot
            case Float32Array:
              return at
            case Float64Array:
              return ut
            default:
              return null
          }
        },
        Ns = t => {
          switch (t) {
            case Ls:
              return ot
            case Fs:
              return at
            case xs:
              return ut
            default:
              return null
          }
        }
      class Vs extends ms {}
      class Cs extends Vs {}
      class Rs extends Vs {}
      class js extends ms {
        static from(...t) {
          let [e, r = !1] = t,
            n = qs(this, r)
          if (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) {
            let t = Gs(e.constructor, r) || n
            if ((null === n && (n = t), n && n === t)) {
              let t = new n(),
                r = e.byteLength / t.ArrayType.BYTES_PER_ELEMENT
              return (
                Js(n, e.constructor) && (r *= 0.5),
                y.new(Pt.Int(t, 0, r, 0, null, e))
              )
            }
          }
          if (n) return ea(() => new n(), e)
          if (e instanceof DataView || e instanceof ArrayBuffer)
            throw new TypeError(
              `Cannot infer integer type from instance of ${e.constructor.name}`
            )
          throw new TypeError("Unrecognized IntVector input")
        }
      }
      class ks extends js {}
      class zs extends js {}
      class Ps extends js {}
      class Ys extends js {
        toBigInt64Array() {
          return Object(kt.toBigInt64Array)(this.values)
        }
        get values64() {
          return this._values64 || (this._values64 = this.toBigInt64Array())
        }
      }
      class $s extends js {}
      class Ws extends js {}
      class Hs extends js {}
      class Ks extends js {
        toBigUint64Array() {
          return Object(kt.toBigUint64Array)(this.values)
        }
        get values64() {
          return this._values64 || (this._values64 = this.toBigUint64Array())
        }
      }
      const Js = (t, e) =>
          !((t !== tt && t !== it) || (e !== Int32Array && e !== Uint32Array)),
        Gs = (t, e) => {
          switch (t) {
            case Int8Array:
              return Z
            case Int16Array:
              return X
            case Int32Array:
              return e ? tt : Q
            case Wt.b:
              return tt
            case Uint8Array:
              return et
            case Uint16Array:
              return rt
            case Uint32Array:
              return e ? it : nt
            case Wt.d:
              return it
            default:
              return null
          }
        },
        qs = (t, e) => {
          switch (t) {
            case ks:
              return Z
            case zs:
              return X
            case Ps:
              return e ? tt : Q
            case Ys:
              return tt
            case $s:
              return et
            case Ws:
              return rt
            case Hs:
              return e ? it : nt
            case Ks:
              return it
            default:
              return null
          }
        }
      class Zs extends ms {}
      class Xs extends ms {
        asList() {
          const t = this.type.children[0]
          return y.new(this.data.clone(new Ut(t)))
        }
        bind(t) {
          const e = this.getChildAt(0),
            { [t]: r, [t + 1]: n } = this.valueOffsets
          return new ur(e.slice(r, n))
        }
      }
      class Qs extends ms {}
      const to = Symbol.for("rowIndex")
      class eo extends ms {
        bind(t) {
          const e = this._row || (this._row = new cr(this)),
            r = Object.create(e)
          return (r[to] = t), r
        }
      }
      class ro extends ms {}
      class no extends ro {}
      class io extends ro {}
      class so extends ro {}
      class oo extends ro {}
      class ao extends ms {}
      class uo extends ao {}
      class co extends ao {}
      class lo extends ao {}
      class ho extends ao {}
      class fo extends ms {
        get typeIdToChildIndex() {
          return this.data.type.typeIdToChildIndex
        }
      }
      class po extends fo {
        get valueOffsets() {
          return this.data.valueOffsets
        }
      }
      class yo extends fo {}
      class bo extends ms {
        static from(t) {
          return ea(() => new lt(), t)
        }
        asBinary() {
          return y.new(this.data.clone(new ct()))
        }
      }
      function go(t) {
        return function() {
          return t(this)
        }
      }
      function _o(t) {
        return function(e, r) {
          return t(this, e, r)
        }
      }
      class mo extends N {}
      const wo = (t, e) => 4294967296 * t[e + 1] + (t[e] >>> 0),
        vo = t => new Date(t),
        Io = (t, e, r) => {
          const { [r]: n, [r + 1]: i } = e
          return null != n && null != i ? t.subarray(n, i) : null
        },
        Ao = ({ values: t }, e) =>
          ((t, e) => vo(((t, e) => 864e5 * t[e])(t, e)))(t, e),
        Bo = ({ values: t }, e) => ((t, e) => vo(wo(t, e)))(t, 2 * e),
        So = ({ stride: t, values: e }, r) => e[t * r],
        To = ({ stride: t, values: e }, r) => fe(e[t * r]),
        Oo = ({ stride: t, values: e, type: r }, n) =>
          De.new(e.subarray(t * n, t * (n + 1)), r.isSigned),
        Do = ({ values: t }, e) => 1e3 * wo(t, 2 * e),
        Uo = ({ values: t }, e) => wo(t, 2 * e),
        Lo = ({ values: t }, e) =>
          ((t, e) => (t[e + 1] / 1e3) * 4294967296 + (t[e] >>> 0) / 1e3)(
            t,
            2 * e
          ),
        Fo = ({ values: t }, e) =>
          ((t, e) => (t[e + 1] / 1e6) * 4294967296 + (t[e] >>> 0) / 1e6)(
            t,
            2 * e
          ),
        xo = ({ values: t, stride: e }, r) => t[e * r],
        Mo = ({ values: t, stride: e }, r) => t[e * r],
        Eo = ({ values: t }, e) => De.signed(t.subarray(2 * e, 2 * (e + 1))),
        No = ({ values: t }, e) => De.signed(t.subarray(2 * e, 2 * (e + 1))),
        Vo = (t, e) => {
          const r = t.typeIdToChildIndex[t.typeIds[e]],
            n = t.getChildAt(r)
          return n ? n.get(t.valueOffsets[e]) : null
        },
        Co = (t, e) => {
          const r = t.typeIdToChildIndex[t.typeIds[e]],
            n = t.getChildAt(r)
          return n ? n.get(e) : null
        },
        Ro = ({ values: t }, e) => t.subarray(2 * e, 2 * (e + 1)),
        jo = ({ values: t }, e) => {
          const r = t[e],
            n = new Int32Array(2)
          return (n[0] = (r / 12) | 0), (n[1] = r % 12 | 0), n
        }
      ;(mo.prototype.visitNull = (t, e) => null),
        (mo.prototype.visitBool = ({ offset: t, values: e }, r) => {
          const n = t + r
          return 0 != (e[n >> 3] & (1 << n % 8))
        }),
        (mo.prototype.visitInt = (t, e) =>
          t.type.bitWidth < 64 ? So(t, e) : Oo(t, e)),
        (mo.prototype.visitInt8 = So),
        (mo.prototype.visitInt16 = So),
        (mo.prototype.visitInt32 = So),
        (mo.prototype.visitInt64 = Oo),
        (mo.prototype.visitUint8 = So),
        (mo.prototype.visitUint16 = So),
        (mo.prototype.visitUint32 = So),
        (mo.prototype.visitUint64 = Oo),
        (mo.prototype.visitFloat = (t, e) =>
          t.type.precision !== v.HALF ? So(t, e) : To(t, e)),
        (mo.prototype.visitFloat16 = To),
        (mo.prototype.visitFloat32 = So),
        (mo.prototype.visitFloat64 = So),
        (mo.prototype.visitUtf8 = ({ values: t, valueOffsets: e }, r) => {
          const n = Io(t, e, r)
          return null !== n ? Object(Xe.a)(n) : null
        }),
        (mo.prototype.visitBinary = ({ values: t, valueOffsets: e }, r) =>
          Io(t, e, r)),
        (mo.prototype.visitFixedSizeBinary = ({ stride: t, values: e }, r) =>
          e.subarray(t * r, t * (r + 1))),
        (mo.prototype.visitDate = (t, e) =>
          t.type.unit === m.DAY ? Ao(t, e) : Bo(t, e)),
        (mo.prototype.visitDateDay = Ao),
        (mo.prototype.visitDateMillisecond = Bo),
        (mo.prototype.visitTimestamp = (t, e) => {
          switch (t.type.unit) {
            case w.SECOND:
              return Do(t, e)
            case w.MILLISECOND:
              return Uo(t, e)
            case w.MICROSECOND:
              return Lo(t, e)
            case w.NANOSECOND:
              return Fo(t, e)
          }
        }),
        (mo.prototype.visitTimestampSecond = Do),
        (mo.prototype.visitTimestampMillisecond = Uo),
        (mo.prototype.visitTimestampMicrosecond = Lo),
        (mo.prototype.visitTimestampNanosecond = Fo),
        (mo.prototype.visitTime = (t, e) => {
          switch (t.type.unit) {
            case w.SECOND:
              return xo(t, e)
            case w.MILLISECOND:
              return Mo(t, e)
            case w.MICROSECOND:
              return Eo(t, e)
            case w.NANOSECOND:
              return No(t, e)
          }
        }),
        (mo.prototype.visitTimeSecond = xo),
        (mo.prototype.visitTimeMillisecond = Mo),
        (mo.prototype.visitTimeMicrosecond = Eo),
        (mo.prototype.visitTimeNanosecond = No),
        (mo.prototype.visitDecimal = ({ values: t }, e) =>
          De.decimal(t.subarray(4 * e, 4 * (e + 1)))),
        (mo.prototype.visitList = (t, e) => {
          const r = t.getChildAt(0),
            { valueOffsets: n, stride: i } = t
          return r.slice(n[e * i], n[e * i + 1])
        }),
        (mo.prototype.visitStruct = (t, e) => t.bind(e)),
        (mo.prototype.visitUnion = (t, e) =>
          t.type.mode === I.Dense ? Vo(t, e) : Co(t, e)),
        (mo.prototype.visitDenseUnion = Vo),
        (mo.prototype.visitSparseUnion = Co),
        (mo.prototype.visitDictionary = (t, e) => t.getValue(t.getKey(e))),
        (mo.prototype.visitInterval = (t, e) =>
          t.type.unit === A.DAY_TIME ? Ro(t, e) : jo(t, e)),
        (mo.prototype.visitIntervalDayTime = Ro),
        (mo.prototype.visitIntervalYearMonth = jo),
        (mo.prototype.visitFixedSizeList = (t, e) => {
          const r = t.getChildAt(0),
            { stride: n } = t
          return r.slice(e * n, (e + 1) * n)
        }),
        (mo.prototype.visitMap = (t, e) => t.bind(e))
      const ko = new mo()
      class zo extends N {}
      function Po(t, e, r) {
        if (void 0 === e) return -1
        if (null === e)
          return (function(t, e) {
            const { nullBitmap: r } = t
            if (!r || t.nullCount <= 0) return -1
            let n = 0
            for (const i of F(r, t.data.offset + (e || 0), t.length, r, T)) {
              if (!i) return n
              ++n
            }
            return -1
          })(t, r)
        const n = gr(e)
        for (let i = (r || 0) - 1, s = t.length; ++i < s; )
          if (n(t.get(i))) return i
        return -1
      }
      function Yo(t, e, r) {
        const n = gr(e)
        for (let i = (r || 0) - 1, s = t.length; ++i < s; )
          if (n(t.get(i))) return i
        return -1
      }
      ;(zo.prototype.visitNull = function(t, e) {
        return null === e && t.length > 0 ? 0 : -1
      }),
        (zo.prototype.visitBool = Po),
        (zo.prototype.visitInt = Po),
        (zo.prototype.visitInt8 = Po),
        (zo.prototype.visitInt16 = Po),
        (zo.prototype.visitInt32 = Po),
        (zo.prototype.visitInt64 = Po),
        (zo.prototype.visitUint8 = Po),
        (zo.prototype.visitUint16 = Po),
        (zo.prototype.visitUint32 = Po),
        (zo.prototype.visitUint64 = Po),
        (zo.prototype.visitFloat = Po),
        (zo.prototype.visitFloat16 = Po),
        (zo.prototype.visitFloat32 = Po),
        (zo.prototype.visitFloat64 = Po),
        (zo.prototype.visitUtf8 = Po),
        (zo.prototype.visitBinary = Po),
        (zo.prototype.visitFixedSizeBinary = Po),
        (zo.prototype.visitDate = Po),
        (zo.prototype.visitDateDay = Po),
        (zo.prototype.visitDateMillisecond = Po),
        (zo.prototype.visitTimestamp = Po),
        (zo.prototype.visitTimestampSecond = Po),
        (zo.prototype.visitTimestampMillisecond = Po),
        (zo.prototype.visitTimestampMicrosecond = Po),
        (zo.prototype.visitTimestampNanosecond = Po),
        (zo.prototype.visitTime = Po),
        (zo.prototype.visitTimeSecond = Po),
        (zo.prototype.visitTimeMillisecond = Po),
        (zo.prototype.visitTimeMicrosecond = Po),
        (zo.prototype.visitTimeNanosecond = Po),
        (zo.prototype.visitDecimal = Po),
        (zo.prototype.visitList = Po),
        (zo.prototype.visitStruct = Po),
        (zo.prototype.visitUnion = Po),
        (zo.prototype.visitDenseUnion = Yo),
        (zo.prototype.visitSparseUnion = Yo),
        (zo.prototype.visitDictionary = Po),
        (zo.prototype.visitInterval = Po),
        (zo.prototype.visitIntervalDayTime = Po),
        (zo.prototype.visitIntervalYearMonth = Po),
        (zo.prototype.visitFixedSizeList = Po),
        (zo.prototype.visitMap = Po)
      const $o = new zo()
      class Wo extends N {}
      function Ho(t) {
        if (t.nullCount > 0)
          return (function(t) {
            const e = ko.getVisitFn(t)
            return F(t.nullBitmap, t.offset, t.length, t, (t, r, n, i) =>
              0 != (n & (1 << i)) ? e(t, r) : null
            )
          })(t)
        const { type: e, typeId: r, length: n } = t
        return 1 === t.stride &&
          (r === b.Timestamp ||
            (r === b.Int && 64 !== e.bitWidth) ||
            (r === b.Time && 64 !== e.bitWidth) ||
            (r === b.Float && e.precision > 0))
          ? t.values.subarray(0, n)[Symbol.iterator]()
          : (function*(e) {
              for (let r = -1; ++r < n; ) yield e(t, r)
            })(ko.getVisitFn(t))
      }
      ;(Wo.prototype.visitNull = Ho),
        (Wo.prototype.visitBool = Ho),
        (Wo.prototype.visitInt = Ho),
        (Wo.prototype.visitInt8 = Ho),
        (Wo.prototype.visitInt16 = Ho),
        (Wo.prototype.visitInt32 = Ho),
        (Wo.prototype.visitInt64 = Ho),
        (Wo.prototype.visitUint8 = Ho),
        (Wo.prototype.visitUint16 = Ho),
        (Wo.prototype.visitUint32 = Ho),
        (Wo.prototype.visitUint64 = Ho),
        (Wo.prototype.visitFloat = Ho),
        (Wo.prototype.visitFloat16 = Ho),
        (Wo.prototype.visitFloat32 = Ho),
        (Wo.prototype.visitFloat64 = Ho),
        (Wo.prototype.visitUtf8 = Ho),
        (Wo.prototype.visitBinary = Ho),
        (Wo.prototype.visitFixedSizeBinary = Ho),
        (Wo.prototype.visitDate = Ho),
        (Wo.prototype.visitDateDay = Ho),
        (Wo.prototype.visitDateMillisecond = Ho),
        (Wo.prototype.visitTimestamp = Ho),
        (Wo.prototype.visitTimestampSecond = Ho),
        (Wo.prototype.visitTimestampMillisecond = Ho),
        (Wo.prototype.visitTimestampMicrosecond = Ho),
        (Wo.prototype.visitTimestampNanosecond = Ho),
        (Wo.prototype.visitTime = Ho),
        (Wo.prototype.visitTimeSecond = Ho),
        (Wo.prototype.visitTimeMillisecond = Ho),
        (Wo.prototype.visitTimeMicrosecond = Ho),
        (Wo.prototype.visitTimeNanosecond = Ho),
        (Wo.prototype.visitDecimal = Ho),
        (Wo.prototype.visitList = Ho),
        (Wo.prototype.visitStruct = Ho),
        (Wo.prototype.visitUnion = Ho),
        (Wo.prototype.visitDenseUnion = Ho),
        (Wo.prototype.visitSparseUnion = Ho),
        (Wo.prototype.visitDictionary = Ho),
        (Wo.prototype.visitInterval = Ho),
        (Wo.prototype.visitIntervalDayTime = Ho),
        (Wo.prototype.visitIntervalYearMonth = Ho),
        (Wo.prototype.visitFixedSizeList = Ho),
        (Wo.prototype.visitMap = Ho)
      const Ko = new Wo()
      class Jo extends N {}
      function Go(t) {
        const { type: e, length: r, stride: n } = t
        switch (e.typeId) {
          case b.Int:
          case b.Float:
          case b.Decimal:
          case b.Time:
          case b.Timestamp:
            return t.values.subarray(0, r * n)
        }
        return [...Ko.visit(t)]
      }
      ;(Jo.prototype.visitNull = Go),
        (Jo.prototype.visitBool = Go),
        (Jo.prototype.visitInt = Go),
        (Jo.prototype.visitInt8 = Go),
        (Jo.prototype.visitInt16 = Go),
        (Jo.prototype.visitInt32 = Go),
        (Jo.prototype.visitInt64 = Go),
        (Jo.prototype.visitUint8 = Go),
        (Jo.prototype.visitUint16 = Go),
        (Jo.prototype.visitUint32 = Go),
        (Jo.prototype.visitUint64 = Go),
        (Jo.prototype.visitFloat = Go),
        (Jo.prototype.visitFloat16 = Go),
        (Jo.prototype.visitFloat32 = Go),
        (Jo.prototype.visitFloat64 = Go),
        (Jo.prototype.visitUtf8 = Go),
        (Jo.prototype.visitBinary = Go),
        (Jo.prototype.visitFixedSizeBinary = Go),
        (Jo.prototype.visitDate = Go),
        (Jo.prototype.visitDateDay = Go),
        (Jo.prototype.visitDateMillisecond = Go),
        (Jo.prototype.visitTimestamp = Go),
        (Jo.prototype.visitTimestampSecond = Go),
        (Jo.prototype.visitTimestampMillisecond = Go),
        (Jo.prototype.visitTimestampMicrosecond = Go),
        (Jo.prototype.visitTimestampNanosecond = Go),
        (Jo.prototype.visitTime = Go),
        (Jo.prototype.visitTimeSecond = Go),
        (Jo.prototype.visitTimeMillisecond = Go),
        (Jo.prototype.visitTimeMicrosecond = Go),
        (Jo.prototype.visitTimeNanosecond = Go),
        (Jo.prototype.visitDecimal = Go),
        (Jo.prototype.visitList = Go),
        (Jo.prototype.visitStruct = Go),
        (Jo.prototype.visitUnion = Go),
        (Jo.prototype.visitDenseUnion = Go),
        (Jo.prototype.visitSparseUnion = Go),
        (Jo.prototype.visitDictionary = Go),
        (Jo.prototype.visitInterval = Go),
        (Jo.prototype.visitIntervalDayTime = Go),
        (Jo.prototype.visitIntervalYearMonth = Go),
        (Jo.prototype.visitFixedSizeList = Go),
        (Jo.prototype.visitMap = Go)
      const qo = new Jo(),
        Zo = (t, e) => t + e,
        Xo = t => `Cannot compute the byte width of variable-width column ${t}`
      const Qo = new (class extends N {
        visitNull(t) {
          return 0
        }
        visitInt(t) {
          return t.bitWidth / 8
        }
        visitFloat(t) {
          return t.ArrayType.BYTES_PER_ELEMENT
        }
        visitBinary(t) {
          throw Error(Xo(t))
        }
        visitUtf8(t) {
          throw Error(Xo(t))
        }
        visitBool(t) {
          return 1 / 8
        }
        visitDecimal(t) {
          return 16
        }
        visitDate(t) {
          return 4 * (t.unit + 1)
        }
        visitTime(t) {
          return t.bitWidth / 8
        }
        visitTimestamp(t) {
          return t.unit === w.SECOND ? 4 : 8
        }
        visitInterval(t) {
          return 4 * (t.unit + 1)
        }
        visitList(t) {
          throw Error(Xo(t))
        }
        visitStruct(t) {
          return this.visitFields(t.children).reduce(Zo, 0)
        }
        visitUnion(t) {
          return this.visitFields(t.children).reduce(Zo, 0)
        }
        visitFixedSizeBinary(t) {
          return t.byteWidth
        }
        visitFixedSizeList(t) {
          return t.listSize * this.visitFields(t.children).reduce(Zo, 0)
        }
        visitMap(t) {
          return this.visitFields(t.children).reduce(Zo, 0)
        }
        visitDictionary(t) {
          return this.visit(t.indices)
        }
        visitFields(t) {
          return (t || []).map(t => this.visit(t.type))
        }
        visitSchema(t) {
          return this.visitFields(t.fields).reduce(Zo, 0)
        }
      })()
      const ta = new (class extends N {
        visitNull() {
          return Qs
        }
        visitBool() {
          return vs
        }
        visitInt() {
          return js
        }
        visitInt8() {
          return ks
        }
        visitInt16() {
          return zs
        }
        visitInt32() {
          return Ps
        }
        visitInt64() {
          return Ys
        }
        visitUint8() {
          return $s
        }
        visitUint16() {
          return Ws
        }
        visitUint32() {
          return Hs
        }
        visitUint64() {
          return Ks
        }
        visitFloat() {
          return Us
        }
        visitFloat16() {
          return Ls
        }
        visitFloat32() {
          return Fs
        }
        visitFloat64() {
          return xs
        }
        visitUtf8() {
          return bo
        }
        visitBinary() {
          return ws
        }
        visitFixedSizeBinary() {
          return Os
        }
        visitDate() {
          return Is
        }
        visitDateDay() {
          return As
        }
        visitDateMillisecond() {
          return Bs
        }
        visitTimestamp() {
          return ro
        }
        visitTimestampSecond() {
          return no
        }
        visitTimestampMillisecond() {
          return io
        }
        visitTimestampMicrosecond() {
          return so
        }
        visitTimestampNanosecond() {
          return oo
        }
        visitTime() {
          return ao
        }
        visitTimeSecond() {
          return uo
        }
        visitTimeMillisecond() {
          return co
        }
        visitTimeMicrosecond() {
          return lo
        }
        visitTimeNanosecond() {
          return ho
        }
        visitDecimal() {
          return Ss
        }
        visitList() {
          return Zs
        }
        visitStruct() {
          return eo
        }
        visitUnion() {
          return fo
        }
        visitDenseUnion() {
          return po
        }
        visitSparseUnion() {
          return yo
        }
        visitDictionary() {
          return Ts
        }
        visitInterval() {
          return Vs
        }
        visitIntervalDayTime() {
          return Cs
        }
        visitIntervalYearMonth() {
          return Rs
        }
        visitFixedSizeList() {
          return Ds
        }
        visitMap() {
          return Xs
        }
      })()
      function ea(t, e) {
        if (Object(Wt.i)(e))
          return y.from({ nullValues: [null, void 0], type: t(), values: e })
        if (Object(Wt.f)(e))
          return y.from({ nullValues: [null, void 0], type: t(), values: e })
        const {
          values: r = [],
          type: n = t(),
          nullValues: i = [null, void 0],
        } = { ...e }
        return Object(Wt.i)(r), y.from({ nullValues: i, ...e, type: n })
      }
      ;(y.new = function(t, ...e) {
        return new (ta.getVisitFn(t)())(t, ...e)
      }),
        (y.from = function(t) {
          const { values: e = [], ...r } = { nullValues: [null, void 0], ...t }
          if (Object(Wt.i)(e)) {
            const t = [...te.throughIterable(r)(e)]
            return 1 === t.length ? t[0] : wr.concat(t)
          }
          return (async t => {
            const n = te.throughAsyncIterable(r)
            for await (const r of n(e)) t.push(r)
            return 1 === t.length ? t[0] : wr.concat(t)
          })([])
        }),
        (ms.prototype.get = function(t) {
          return ko.visit(this, t)
        }),
        (ms.prototype.set = function(t, e) {
          return fn.visit(this, t, e)
        }),
        (ms.prototype.indexOf = function(t, e) {
          return $o.visit(this, t, e)
        }),
        (ms.prototype.toArray = function() {
          return qo.visit(this)
        }),
        (ms.prototype.getByteWidth = function() {
          return Qo.visit(this.type)
        }),
        (ms.prototype[Symbol.iterator] = function() {
          return Ko.visit(this)
        }),
        (ms.prototype._bindDataAccessors = function() {
          const t = this.nullBitmap
          t &&
            t.byteLength > 0 &&
            ((this.get =
              ((e = this.get),
              function(t) {
                return this.isValid(t) ? e.call(this, t) : null
              })),
            (this.set = (function(t) {
              return function(e, r) {
                D(this.nullBitmap, this.offset + e, !(null == r)) &&
                  t.call(this, e, r)
              }
            })(this.set)))
          var e
        }),
        Object.keys(b)
          .map(t => b[t])
          .filter(t => "number" == typeof t)
          .filter(t => t !== b.NONE)
          .forEach(t => {
            const e = ta.visit(t)
            ;(e.prototype.get = (function(t) {
              return function(e) {
                return t(this, e)
              }
            })(ko.getVisitFn(t))),
              (e.prototype.set = _o(fn.getVisitFn(t))),
              (e.prototype.indexOf = _o($o.getVisitFn(t))),
              (e.prototype.toArray = go(qo.getVisitFn(t))),
              (e.prototype.getByteWidth = (function(t) {
                return function() {
                  return t(this.type)
                }
              })(Qo.getVisitFn(t))),
              (e.prototype[Symbol.iterator] = go(Ko.getVisitFn(t)))
          })
      class ra extends wr {
        constructor(...t) {
          let e = null
          t[0] instanceof Nr && (e = t.shift())
          let r = Tr(na, t)
          if (!e && !(e = r[0] && r[0].schema))
            throw new TypeError(
              "Table must be initialized with a Schema or at least one RecordBatch"
            )
          r[0] || (r[0] = new ia(e)),
            super(new Lt(e.fields), r),
            (this._schema = e),
            (this._chunks = r)
        }
        static empty(t = new Nr([])) {
          return new ra(t, [])
        }
        static from(t) {
          if (!t) return ra.empty()
          if ("object" == typeof t) {
            let e = Object(Wt.i)(t.values)
              ? (function(t) {
                  const { type: e } = t
                  if (e instanceof Lt) return ra.fromStruct(eo.from(t))
                  return null
                })(t)
              : Object(Wt.f)(t.values)
              ? (function(t) {
                  const { type: e } = t
                  if (e instanceof Lt)
                    return eo.from(t).then(t => ra.fromStruct(t))
                  return null
                })(t)
              : null
            if (null !== e) return e
          }
          let e = oa.from(t)
          return Object(Wt.l)(e)
            ? (async () => await ra.from(await e))()
            : e.isSync() && (e = e.open())
            ? e.schema
              ? new ra(e.schema, [...e])
              : ra.empty()
            : (async t => {
                const e = await t,
                  r = e.schema,
                  n = []
                if (r) {
                  for await (let t of e) n.push(t)
                  return new ra(r, n)
                }
                return ra.empty()
              })(e.open())
        }
        static async fromAsync(t) {
          return await ra.from(t)
        }
        static fromStruct(t) {
          return ra.new(t.data.childData, t.type.children)
        }
        static new(...t) {
          return new ra(
            ...((e = Or(t)), gs(new Nr(e.map(({ field: t }) => t)), e))
          )
          var e
        }
        get schema() {
          return this._schema
        }
        get length() {
          return this._length
        }
        get chunks() {
          return this._chunks
        }
        get numCols() {
          return this._numChildren
        }
        clone(t = this._chunks) {
          return new ra(this._schema, t)
        }
        getColumn(t) {
          return this.getColumnAt(this.getColumnIndex(t))
        }
        getColumnAt(t) {
          return this.getChildAt(t)
        }
        getColumnIndex(t) {
          return this._schema.fields.findIndex(e => e.name === t)
        }
        getChildAt(t) {
          if (t < 0 || t >= this.numChildren) return null
          let e, r
          const n = this._schema.fields,
            i = this._children || (this._children = [])
          if ((r = i[t])) return r
          if ((e = n[t])) {
            const r = this._chunks
              .map(e => e.getChildAt(t))
              .filter(t => null != t)
            if (r.length > 0) return (i[t] = new Ar(e, r))
          }
          return null
        }
        serialize(t = "binary", e = !0) {
          return (e ? cs : ls).writeAll(this).toUint8Array(!0)
        }
        count() {
          return this._length
        }
        select(...t) {
          const e = this._schema.fields.reduce(
            (t, e, r) => t.set(e.name, r),
            new Map()
          )
          return this.selectAt(...t.map(t => e.get(t)).filter(t => t > -1))
        }
        selectAt(...t) {
          const e = this._schema.selectAt(...t)
          return new ra(
            e,
            this._chunks.map(
              ({ length: r, data: { childData: n } }) =>
                new na(e, r, t.map(t => n[t]).filter(Boolean))
            )
          )
        }
        assign(t) {
          const e = this._schema.fields,
            [r, n] = t.schema.fields.reduce(
              (t, r, n) => {
                const [i, s] = t,
                  o = e.findIndex(t => t.name === r.name)
                return ~o ? (s[o] = n) : i.push(n), t
              },
              [[], []]
            ),
            i = this._schema.assign(t.schema),
            s = [
              ...e.map((e, r, i, s = n[r]) =>
                void 0 === s ? this.getColumnAt(r) : t.getColumnAt(s)
              ),
              ...r.map(e => t.getColumnAt(e)),
            ].filter(Boolean)
          return new ra(...gs(i, s))
        }
      }
      class na extends eo {
        constructor(...t) {
          let e,
            r,
            n = t[0]
          if (t[1] instanceof Pt) [, e, r] = t
          else {
            const r = n.fields,
              [, i, s] = t
            e = Pt.Struct(new Lt(r), 0, i, 0, null, s)
          }
          super(e, r), (this._schema = n)
        }
        static from(t) {
          return Object(Wt.i)(t.values), ra.from(t)
        }
        static new(...t) {
          const [e, r] = Dr(t),
            n = r.filter(t => t instanceof y)
          return new na(
            ...(function(
              t,
              e,
              r = e.reduce((t, e) => Math.max(t, e.length), 0)
            ) {
              let n,
                i,
                s = -1,
                o = e.length
              const a = [...t.fields],
                u = [],
                c = ((r + 63) & -64) >> 3
              for (; ++s < o; )
                (n = e[s]) && n.length === r
                  ? (u[s] = n)
                  : ((i = a[s]).nullable ||
                      (a[s] = a[s].clone({ nullable: !0 })),
                    (u[s] = n
                      ? n._changeLengthAndBackfillNullBitmap(r)
                      : Pt.new(i.type, 0, r, r, bs(c))))
              return [new Nr(a), r, u]
            })(new Nr(e), n.map(t => t.data))
          )
        }
        clone(t, e = this._children) {
          return new na(this._schema, t, e)
        }
        concat(...t) {
          const e = this._schema,
            r = wr.flatten(this, ...t)
          return new ra(e, r.map(({ data: t }) => new na(e, t)))
        }
        get schema() {
          return this._schema
        }
        get numCols() {
          return this._schema.fields.length
        }
        get dictionaries() {
          return this._dictionaries || (this._dictionaries = sa.collect(this))
        }
        select(...t) {
          const e = this._schema.fields.reduce(
            (t, e, r) => t.set(e.name, r),
            new Map()
          )
          return this.selectAt(...t.map(t => e.get(t)).filter(t => t > -1))
        }
        selectAt(...t) {
          const e = this._schema.selectAt(...t),
            r = t.map(t => this.data.childData[t]).filter(Boolean)
          return new na(e, this.length, r)
        }
      }
      class ia extends na {
        constructor(t) {
          super(t, 0, t.fields.map(t => Pt.new(t.type, 0, 0, 0)))
        }
      }
      class sa extends N {
        constructor() {
          super(...arguments), (this.dictionaries = new Map())
        }
        static collect(t) {
          return new sa().visit(t.data, new Lt(t.schema.fields)).dictionaries
        }
        visit(t, e) {
          return J.isDictionary(e)
            ? this.visitDictionary(t, e)
            : (t.childData.forEach((t, r) =>
                this.visit(t, e.children[r].type)
              ),
              this)
        }
        visitDictionary(t, e) {
          const r = t.dictionary
          return r && r.length > 0 && this.dictionaries.set(e.id, r), this
        }
      }
      class oa extends Sn.d {
        constructor(t) {
          super(), (this._impl = t)
        }
        get closed() {
          return this._impl.closed
        }
        get schema() {
          return this._impl.schema
        }
        get autoDestroy() {
          return this._impl.autoDestroy
        }
        get dictionaries() {
          return this._impl.dictionaries
        }
        get numDictionaries() {
          return this._impl.numDictionaries
        }
        get numRecordBatches() {
          return this._impl.numRecordBatches
        }
        get footer() {
          return this._impl.isFile() ? this._impl.footer : null
        }
        isSync() {
          return this._impl.isSync()
        }
        isAsync() {
          return this._impl.isAsync()
        }
        isFile() {
          return this._impl.isFile()
        }
        isStream() {
          return this._impl.isStream()
        }
        next() {
          return this._impl.next()
        }
        throw(t) {
          return this._impl.throw(t)
        }
        return(t) {
          return this._impl.return(t)
        }
        cancel() {
          return this._impl.cancel()
        }
        reset(t) {
          return (
            this._impl.reset(t),
            (this._DOMStream = void 0),
            (this._nodeStream = void 0),
            this
          )
        }
        open(t) {
          const e = this._impl.open(t)
          return Object(Wt.l)(e) ? e.then(() => this) : this
        }
        readRecordBatch(t) {
          return this._impl.isFile() ? this._impl.readRecordBatch(t) : null
        }
        [Symbol.iterator]() {
          return this._impl[Symbol.iterator]()
        }
        [Symbol.asyncIterator]() {
          return this._impl[Symbol.asyncIterator]()
        }
        toDOMStream() {
          return p.a.toDOMStream(
            this.isSync()
              ? { [Symbol.iterator]: () => this }
              : { [Symbol.asyncIterator]: () => this }
          )
        }
        toNodeStream() {
          return p.a.toNodeStream(
            this.isSync()
              ? { [Symbol.iterator]: () => this }
              : { [Symbol.asyncIterator]: () => this },
            { objectMode: !0 }
          )
        }
        static throughNode(t) {
          throw Error('"throughNode" not available in this environment')
        }
        static throughDOM(t, e) {
          throw Error('"throughDOM" not available in this environment')
        }
        static from(t) {
          return t instanceof oa
            ? t
            : Object(Wt.e)(t)
            ? (function(t) {
                return new aa(new ba(t))
              })(t)
            : Object(Wt.h)(t)
            ? (async function(t) {
                const { size: e } = await t.stat(),
                  r = new xn(t, e)
                if (e >= Zi && Ji(await r.readAt(0, (Gi + 7) & -8)))
                  return new la(new ya(r))
                return new ua(new fa(r))
              })(t)
            : Object(Wt.l)(t)
            ? (async () => await oa.from(await t))()
            : Object(Wt.g)(t) ||
              Object(Wt.m)(t) ||
              Object(Wt.n)(t) ||
              Object(Wt.f)(t)
            ? (async function(t) {
                const e = await t.peek((Gi + 7) & -8)
                return e && e.byteLength >= 4
                  ? Ji(e)
                    ? new ca(new pa(await t.read()))
                    : new ua(new fa(t))
                  : new ua(new fa((async function*() {})()))
              })(new Dn(t))
            : (function(t) {
                const e = t.peek((Gi + 7) & -8)
                return e && e.byteLength >= 4
                  ? Ji(e)
                    ? new ca(new pa(t.read()))
                    : new aa(new da(t))
                  : new aa(new da((function*() {})()))
              })(new On(t))
        }
        static readAll(t) {
          return t instanceof oa
            ? t.isSync()
              ? _a(t)
              : ma(t)
            : Object(Wt.e)(t) ||
              ArrayBuffer.isView(t) ||
              Object(Wt.i)(t) ||
              Object(Wt.j)(t)
            ? _a(t)
            : ma(t)
        }
      }
      class aa extends oa {
        constructor(t) {
          super(t), (this._impl = t)
        }
        [Symbol.iterator]() {
          return this._impl[Symbol.iterator]()
        }
        async *[Symbol.asyncIterator]() {
          yield* this[Symbol.iterator]()
        }
      }
      class ua extends oa {
        constructor(t) {
          super(t), (this._impl = t)
        }
        [Symbol.iterator]() {
          throw Error("AsyncRecordBatchStreamReader is not Iterable")
        }
        [Symbol.asyncIterator]() {
          return this._impl[Symbol.asyncIterator]()
        }
      }
      class ca extends aa {
        constructor(t) {
          super(t), (this._impl = t)
        }
      }
      class la extends ua {
        constructor(t) {
          super(t), (this._impl = t)
        }
      }
      class ha {
        constructor(t = new Map()) {
          ;(this.closed = !1),
            (this.autoDestroy = !0),
            (this._dictionaryIndex = 0),
            (this._recordBatchIndex = 0),
            (this.dictionaries = t)
        }
        get numDictionaries() {
          return this._dictionaryIndex
        }
        get numRecordBatches() {
          return this._recordBatchIndex
        }
        isSync() {
          return !1
        }
        isAsync() {
          return !1
        }
        isFile() {
          return !1
        }
        isStream() {
          return !1
        }
        reset(t) {
          return (
            (this._dictionaryIndex = 0),
            (this._recordBatchIndex = 0),
            (this.schema = t),
            (this.dictionaries = new Map()),
            this
          )
        }
        _loadRecordBatch(t, e) {
          return new na(
            this.schema,
            t.length,
            this._loadVectors(t, e, this.schema.fields)
          )
        }
        _loadDictionaryBatch(t, e) {
          const { id: r, isDelta: n, data: i } = t,
            { dictionaries: s, schema: o } = this,
            a = s.get(r)
          if (n || !a) {
            const t = o.dictionaries.get(r)
            return a && n
              ? a.concat(y.new(this._loadVectors(i, e, [t])[0]))
              : y.new(this._loadVectors(i, e, [t])[0])
          }
          return a
        }
        _loadVectors(t, e, r) {
          return new zn(e, t.nodes, t.buffers, this.dictionaries).visitMany(r)
        }
      }
      class da extends ha {
        constructor(t, e) {
          super(e),
            (this._reader = Object(Wt.e)(t)
              ? new Wi((this._handle = t))
              : new Yi((this._handle = t)))
        }
        isSync() {
          return !0
        }
        isStream() {
          return !0
        }
        [Symbol.iterator]() {
          return this
        }
        cancel() {
          !this.closed &&
            (this.closed = !0) &&
            (this.reset()._reader.return(),
            (this._reader = null),
            (this.dictionaries = null))
        }
        open(t) {
          return (
            this.closed ||
              ((this.autoDestroy = ga(this, t)),
              this.schema ||
                (this.schema = this._reader.readSchema()) ||
                this.cancel()),
            this
          )
        }
        throw(t) {
          return !this.closed && this.autoDestroy && (this.closed = !0)
            ? this.reset()._reader.throw(t)
            : Sn.c
        }
        return(t) {
          return !this.closed && this.autoDestroy && (this.closed = !0)
            ? this.reset()._reader.return(t)
            : Sn.c
        }
        next() {
          if (this.closed) return Sn.c
          let t,
            { _reader: e } = this
          for (; (t = this._readNextMessageAndValidate()); )
            if (t.isSchema()) this.reset(t.header())
            else {
              if (t.isRecordBatch()) {
                this._recordBatchIndex++
                const r = t.header(),
                  n = e.readMessageBody(t.bodyLength)
                return { done: !1, value: this._loadRecordBatch(r, n) }
              }
              if (t.isDictionaryBatch()) {
                this._dictionaryIndex++
                const r = t.header(),
                  n = e.readMessageBody(t.bodyLength),
                  i = this._loadDictionaryBatch(r, n)
                this.dictionaries.set(r.id, i)
              }
            }
          return this.schema && 0 === this._recordBatchIndex
            ? (this._recordBatchIndex++,
              { done: !1, value: new ia(this.schema) })
            : this.return()
        }
        _readNextMessageAndValidate(t) {
          return this._reader.readMessage(t)
        }
      }
      class fa extends ha {
        constructor(t, e) {
          super(e), (this._reader = new $i((this._handle = t)))
        }
        isAsync() {
          return !0
        }
        isStream() {
          return !0
        }
        [Symbol.asyncIterator]() {
          return this
        }
        async cancel() {
          !this.closed &&
            (this.closed = !0) &&
            (await this.reset()._reader.return(),
            (this._reader = null),
            (this.dictionaries = null))
        }
        async open(t) {
          return (
            this.closed ||
              ((this.autoDestroy = ga(this, t)),
              this.schema ||
                (this.schema = await this._reader.readSchema()) ||
                (await this.cancel())),
            this
          )
        }
        async throw(t) {
          return !this.closed && this.autoDestroy && (this.closed = !0)
            ? await this.reset()._reader.throw(t)
            : Sn.c
        }
        async return(t) {
          return !this.closed && this.autoDestroy && (this.closed = !0)
            ? await this.reset()._reader.return(t)
            : Sn.c
        }
        async next() {
          if (this.closed) return Sn.c
          let t,
            { _reader: e } = this
          for (; (t = await this._readNextMessageAndValidate()); )
            if (t.isSchema()) await this.reset(t.header())
            else {
              if (t.isRecordBatch()) {
                this._recordBatchIndex++
                const r = t.header(),
                  n = await e.readMessageBody(t.bodyLength)
                return { done: !1, value: this._loadRecordBatch(r, n) }
              }
              if (t.isDictionaryBatch()) {
                this._dictionaryIndex++
                const r = t.header(),
                  n = await e.readMessageBody(t.bodyLength),
                  i = this._loadDictionaryBatch(r, n)
                this.dictionaries.set(r.id, i)
              }
            }
          return this.schema && 0 === this._recordBatchIndex
            ? (this._recordBatchIndex++,
              { done: !1, value: new ia(this.schema) })
            : await this.return()
        }
        async _readNextMessageAndValidate(t) {
          return await this._reader.readMessage(t)
        }
      }
      class pa extends da {
        constructor(t, e) {
          super(t instanceof Fn ? t : new Fn(t), e)
        }
        get footer() {
          return this._footer
        }
        get numDictionaries() {
          return this._footer ? this._footer.numDictionaries : 0
        }
        get numRecordBatches() {
          return this._footer ? this._footer.numRecordBatches : 0
        }
        isSync() {
          return !0
        }
        isFile() {
          return !0
        }
        open(t) {
          if (!this.closed && !this._footer) {
            this.schema = (this._footer = this._readFooter()).schema
            for (const t of this._footer.dictionaryBatches())
              t && this._readDictionaryBatch(this._dictionaryIndex++)
          }
          return super.open(t)
        }
        readRecordBatch(t) {
          if (this.closed) return null
          this._footer || this.open()
          const e = this._footer && this._footer.getRecordBatch(t)
          if (e && this._handle.seek(e.offset)) {
            const t = this._reader.readMessage(B.RecordBatch)
            if (t && t.isRecordBatch()) {
              const e = t.header(),
                r = this._reader.readMessageBody(t.bodyLength)
              return this._loadRecordBatch(e, r)
            }
          }
          return null
        }
        _readDictionaryBatch(t) {
          const e = this._footer && this._footer.getDictionaryBatch(t)
          if (e && this._handle.seek(e.offset)) {
            const t = this._reader.readMessage(B.DictionaryBatch)
            if (t && t.isDictionaryBatch()) {
              const e = t.header(),
                r = this._reader.readMessageBody(t.bodyLength),
                n = this._loadDictionaryBatch(e, r)
              this.dictionaries.set(e.id, n)
            }
          }
        }
        _readFooter() {
          const { _handle: t } = this,
            e = t.size - qi,
            r = t.readInt32(e),
            n = t.readAt(e - r, r)
          return In.decode(n)
        }
        _readNextMessageAndValidate(t) {
          if (
            (this._footer || this.open(),
            this._footer && this._recordBatchIndex < this.numRecordBatches)
          ) {
            const e =
              this._footer &&
              this._footer.getRecordBatch(this._recordBatchIndex)
            if (e && this._handle.seek(e.offset))
              return this._reader.readMessage(t)
          }
          return null
        }
      }
      class ya extends fa {
        constructor(t, ...e) {
          const r = "number" != typeof e[0] ? e.shift() : void 0,
            n = e[0] instanceof Map ? e.shift() : void 0
          super(t instanceof xn ? t : new xn(t, r), n)
        }
        get footer() {
          return this._footer
        }
        get numDictionaries() {
          return this._footer ? this._footer.numDictionaries : 0
        }
        get numRecordBatches() {
          return this._footer ? this._footer.numRecordBatches : 0
        }
        isFile() {
          return !0
        }
        isAsync() {
          return !0
        }
        async open(t) {
          if (!this.closed && !this._footer) {
            this.schema = (this._footer = await this._readFooter()).schema
            for (const t of this._footer.dictionaryBatches())
              t && (await this._readDictionaryBatch(this._dictionaryIndex++))
          }
          return await super.open(t)
        }
        async readRecordBatch(t) {
          if (this.closed) return null
          this._footer || (await this.open())
          const e = this._footer && this._footer.getRecordBatch(t)
          if (e && (await this._handle.seek(e.offset))) {
            const t = await this._reader.readMessage(B.RecordBatch)
            if (t && t.isRecordBatch()) {
              const e = t.header(),
                r = await this._reader.readMessageBody(t.bodyLength)
              return this._loadRecordBatch(e, r)
            }
          }
          return null
        }
        async _readDictionaryBatch(t) {
          const e = this._footer && this._footer.getDictionaryBatch(t)
          if (e && (await this._handle.seek(e.offset))) {
            const t = await this._reader.readMessage(B.DictionaryBatch)
            if (t && t.isDictionaryBatch()) {
              const e = t.header(),
                r = await this._reader.readMessageBody(t.bodyLength),
                n = this._loadDictionaryBatch(e, r)
              this.dictionaries.set(e.id, n)
            }
          }
        }
        async _readFooter() {
          const { _handle: t } = this
          t._pending && (await t._pending)
          const e = t.size - qi,
            r = await t.readInt32(e),
            n = await t.readAt(e - r, r)
          return In.decode(n)
        }
        async _readNextMessageAndValidate(t) {
          if (
            (this._footer || (await this.open()),
            this._footer && this._recordBatchIndex < this.numRecordBatches)
          ) {
            const e = this._footer.getRecordBatch(this._recordBatchIndex)
            if (e && (await this._handle.seek(e.offset)))
              return await this._reader.readMessage(t)
          }
          return null
        }
      }
      class ba extends da {
        constructor(t, e) {
          super(t, e)
        }
        _loadVectors(t, e, r) {
          return new Pn(e, t.nodes, t.buffers, this.dictionaries).visitMany(r)
        }
      }
      function ga(t, e) {
        return e && "boolean" == typeof e.autoDestroy
          ? e.autoDestroy
          : t.autoDestroy
      }
      function* _a(t) {
        const e = oa.from(t)
        try {
          if (!e.open({ autoDestroy: !1 }).closed)
            do {
              yield e
            } while (!e.reset().open().closed)
        } finally {
          e.cancel()
        }
      }
      async function* ma(t) {
        const e = await oa.from(t)
        try {
          if (!(await e.open({ autoDestroy: !1 })).closed)
            do {
              yield e
            } while (!(await e.reset().open()).closed)
        } finally {
          await e.cancel()
        }
      }
      class wa {
        constructor(t) {
          ;(this._numChunks = 0),
            (this._finished = !1),
            (this._bufferedSize = 0)
          const {
            readableStrategy: e,
            writableStrategy: r,
            queueingStrategy: n = "count",
            ...i
          } = t
          ;(this._controller = null),
            (this._builder = te.new(i)),
            (this._getSize = "bytes" !== n ? va : Ia)
          const { highWaterMark: s = "bytes" === n ? 16384 : 1e3 } = { ...e },
            { highWaterMark: o = "bytes" === n ? 16384 : 1e3 } = { ...r }
          ;(this.readable = new ReadableStream(
            {
              cancel: () => {
                this._builder.clear()
              },
              pull: t => {
                this._maybeFlush(this._builder, (this._controller = t))
              },
              start: t => {
                this._maybeFlush(this._builder, (this._controller = t))
              },
            },
            { highWaterMark: s, size: "bytes" !== n ? va : Ia }
          )),
            (this.writable = new WritableStream(
              {
                abort: () => {
                  this._builder.clear()
                },
                write: () => {
                  this._maybeFlush(this._builder, this._controller)
                },
                close: () => {
                  this._maybeFlush(this._builder.finish(), this._controller)
                },
              },
              {
                highWaterMark: o,
                size: t => this._writeValueAndReturnChunkSize(t),
              }
            ))
        }
        _writeValueAndReturnChunkSize(t) {
          const e = this._bufferedSize
          return (
            (this._bufferedSize = this._getSize(this._builder.append(t))),
            this._bufferedSize - e
          )
        }
        _maybeFlush(t, e) {
          null !== e &&
            (this._bufferedSize >= e.desiredSize &&
              ++this._numChunks &&
              this._enqueue(e, t.toVector()),
            t.finished &&
              ((t.length > 0 || 0 === this._numChunks) &&
                ++this._numChunks &&
                this._enqueue(e, t.toVector()),
              !this._finished &&
                (this._finished = !0) &&
                this._enqueue(e, null)))
        }
        _enqueue(t, e) {
          ;(this._bufferedSize = 0),
            (this._controller = null),
            null === e ? t.close() : t.enqueue(e)
        }
      }
      const va = t => t.length,
        Ia = t => t.byteLength
      class Aa {
        eq(t) {
          return t instanceof Aa || (t = new Ba(t)), new Fa(this, t)
        }
        le(t) {
          return t instanceof Aa || (t = new Ba(t)), new xa(this, t)
        }
        ge(t) {
          return t instanceof Aa || (t = new Ba(t)), new Ma(this, t)
        }
        lt(t) {
          return new Ea(this.ge(t))
        }
        gt(t) {
          return new Ea(this.le(t))
        }
        ne(t) {
          return new Ea(this.eq(t))
        }
      }
      class Ba extends Aa {
        constructor(t) {
          super(), (this.v = t)
        }
      }
      class Sa extends Aa {
        constructor(t) {
          super(), (this.name = t)
        }
        bind(t) {
          if (!this.colidx) {
            this.colidx = -1
            const e = t.schema.fields
            for (let t = -1; ++t < e.length; )
              if (e[t].name === this.name) {
                this.colidx = t
                break
              }
            if (this.colidx < 0)
              throw Error(`Failed to bind Col "${this.name}"`)
          }
          const e = (this.vector = t.getChildAt(this.colidx))
          return t => e.get(t)
        }
      }
      class Ta {
        and(...t) {
          return new Ua(this, ...t)
        }
        or(...t) {
          return new La(this, ...t)
        }
        not() {
          return new Ea(this)
        }
      }
      class Oa extends Ta {
        constructor(t, e) {
          super(), (this.left = t), (this.right = e)
        }
        bind(t) {
          return this.left instanceof Ba
            ? this.right instanceof Ba
              ? this._bindLitLit(t, this.left, this.right)
              : this._bindLitCol(t, this.left, this.right)
            : this.right instanceof Ba
            ? this._bindColLit(t, this.left, this.right)
            : this._bindColCol(t, this.left, this.right)
        }
      }
      class Da extends Ta {
        constructor(...t) {
          super(), (this.children = t)
        }
      }
      Da.prototype.children = Object.freeze([])
      class Ua extends Da {
        constructor(...t) {
          ;(t = t.reduce(
            (t, e) => t.concat(e instanceof Ua ? e.children : e),
            []
          )),
            super(...t)
        }
        bind(t) {
          const e = this.children.map(e => e.bind(t))
          return (t, r) => e.every(e => e(t, r))
        }
      }
      class La extends Da {
        constructor(...t) {
          ;(t = t.reduce(
            (t, e) => t.concat(e instanceof La ? e.children : e),
            []
          )),
            super(...t)
        }
        bind(t) {
          const e = this.children.map(e => e.bind(t))
          return (t, r) => e.some(e => e(t, r))
        }
      }
      class Fa extends Oa {
        _bindLitLit(t, e, r) {
          const n = e.v == r.v
          return () => n
        }
        _bindColCol(t, e, r) {
          const n = e.bind(t),
            i = r.bind(t)
          return (t, e) => n(t, e) == i(t, e)
        }
        _bindColLit(t, e, r) {
          const n = e.bind(t)
          if (e.vector instanceof Ts) {
            let t
            const n = e.vector
            return (
              n.dictionary !== this.lastDictionary
                ? ((t = n.reverseLookup(r.v)),
                  (this.lastDictionary = n.dictionary),
                  (this.lastKey = t))
                : (t = this.lastKey),
              -1 === t ? () => !1 : e => n.getKey(e) === t
            )
          }
          return (t, e) => n(t, e) == r.v
        }
        _bindLitCol(t, e, r) {
          return this._bindColLit(t, r, e)
        }
      }
      class xa extends Oa {
        _bindLitLit(t, e, r) {
          const n = e.v <= r.v
          return () => n
        }
        _bindColCol(t, e, r) {
          const n = e.bind(t),
            i = r.bind(t)
          return (t, e) => n(t, e) <= i(t, e)
        }
        _bindColLit(t, e, r) {
          const n = e.bind(t)
          return (t, e) => n(t, e) <= r.v
        }
        _bindLitCol(t, e, r) {
          const n = r.bind(t)
          return (t, r) => e.v <= n(t, r)
        }
      }
      class Ma extends Oa {
        _bindLitLit(t, e, r) {
          const n = e.v >= r.v
          return () => n
        }
        _bindColCol(t, e, r) {
          const n = e.bind(t),
            i = r.bind(t)
          return (t, e) => n(t, e) >= i(t, e)
        }
        _bindColLit(t, e, r) {
          const n = e.bind(t)
          return (t, e) => n(t, e) >= r.v
        }
        _bindLitCol(t, e, r) {
          const n = r.bind(t)
          return (t, r) => e.v >= n(t, r)
        }
      }
      class Ea extends Ta {
        constructor(t) {
          super(), (this.child = t)
        }
        bind(t) {
          const e = this.child.bind(t)
          return (t, r) => !e(t, r)
        }
      }
      class Na extends Ta {
        constructor(t, e) {
          super(), (this.next = t), (this.bind_ = e)
        }
        bind(t) {
          return this.bind_(t), this.next
        }
      }
      function Va(t) {
        return new Ba(t)
      }
      function Ca(t) {
        return new Sa(t)
      }
      function Ra(...t) {
        return new Ua(...t)
      }
      function ja(...t) {
        return new La(...t)
      }
      function ka(t, e) {
        return new Na(t, e)
      }
      ;(ra.prototype.countBy = function(t) {
        return new za(this.chunks).countBy(t)
      }),
        (ra.prototype.scan = function(t, e) {
          return new za(this.chunks).scan(t, e)
        }),
        (ra.prototype.scanReverse = function(t, e) {
          return new za(this.chunks).scanReverse(t, e)
        }),
        (ra.prototype.filter = function(t) {
          return new za(this.chunks).filter(t)
        })
      class za extends ra {
        filter(t) {
          return new Ya(this.chunks, t)
        }
        scan(t, e) {
          const r = this.chunks,
            n = r.length
          for (let i = -1; ++i < n; ) {
            const n = r[i]
            e && e(n)
            for (let e = -1, r = n.length; ++e < r; ) t(e, n)
          }
        }
        scanReverse(t, e) {
          const r = this.chunks
          for (let n = r.length; --n >= 0; ) {
            const i = r[n]
            e && e(i)
            for (let e = i.length; --e >= 0; ) t(e, i)
          }
        }
        countBy(t) {
          const e = this.chunks,
            r = e.length,
            n = "string" == typeof t ? new Sa(t) : t
          n.bind(e[r - 1])
          const i = n.vector
          if (!J.isDictionary(i.type))
            throw Error(
              "countBy currently only supports dictionary-encoded columns"
            )
          const s = Math.ceil(Math.log(i.length) / Math.log(256)),
            o = new (4 == s ? Uint32Array : s >= 2 ? Uint16Array : Uint8Array)(
              i.dictionary.length
            )
          for (let a = -1; ++a < r; ) {
            const t = e[a]
            n.bind(t)
            const r = n.vector.indices
            for (let e = -1, n = t.length; ++e < n; ) {
              let t = r.get(e)
              null !== t && o[t]++
            }
          }
          return new Pa(i.dictionary, js.from(o))
        }
      }
      class Pa extends ra {
        constructor(t, e) {
          const r = new Nr([
            new Vr("values", t.type),
            new Vr("counts", e.type),
          ])
          super(new na(r, e.length, [t, e]))
        }
        toJSON() {
          const t = this.getColumnAt(0),
            e = this.getColumnAt(1),
            r = {}
          for (let n = -1; ++n < this.length; ) r[t.get(n)] = e.get(n)
          return r
        }
      }
      class Ya extends za {
        constructor(t, e) {
          super(t), (this._predicate = e)
        }
        scan(t, e) {
          const r = this._chunks,
            n = r.length
          for (let i = -1; ++i < n; ) {
            const n = r[i],
              s = this._predicate.bind(n)
            let o = !1
            for (let r = -1, i = n.length; ++r < i; )
              s(r, n) && (e && !o && (e(n), (o = !0)), t(r, n))
          }
        }
        scanReverse(t, e) {
          const r = this._chunks
          for (let n = r.length; --n >= 0; ) {
            const i = r[n],
              s = this._predicate.bind(i)
            let o = !1
            for (let r = i.length; --r >= 0; )
              s(r, i) && (e && !o && (e(i), (o = !0)), t(r, i))
          }
        }
        count() {
          let t = 0
          const e = this._chunks,
            r = e.length
          for (let n = -1; ++n < r; ) {
            const r = e[n],
              i = this._predicate.bind(r)
            for (let e = -1, n = r.length; ++e < n; ) i(e, r) && ++t
          }
          return t
        }
        *[Symbol.iterator]() {
          const t = this._chunks,
            e = t.length
          for (let r = -1; ++r < e; ) {
            const e = t[r],
              n = this._predicate.bind(e)
            for (let t = -1, r = e.length; ++t < r; )
              n(t, e) && (yield e.get(t))
          }
        }
        filter(t) {
          return new Ya(this._chunks, this._predicate.and(t))
        }
        countBy(t) {
          const e = this._chunks,
            r = e.length,
            n = "string" == typeof t ? new Sa(t) : t
          n.bind(e[r - 1])
          const i = n.vector
          if (!J.isDictionary(i.type))
            throw Error(
              "countBy currently only supports dictionary-encoded columns"
            )
          const s = Math.ceil(Math.log(i.length) / Math.log(256)),
            o = new (4 == s ? Uint32Array : s >= 2 ? Uint16Array : Uint8Array)(
              i.dictionary.length
            )
          for (let a = -1; ++a < r; ) {
            const t = e[a],
              r = this._predicate.bind(t)
            n.bind(t)
            const i = n.vector.indices
            for (let e = -1, n = t.length; ++e < n; ) {
              let n = i.get(e)
              null !== n && r(e, t) && o[n]++
            }
          }
          return new Pa(i.dictionary, js.from(o))
        }
      }
      const $a = { ...s, ...a, ...n, ...i, ...kt, ...o }
      r.d(e, "ArrowType", function() {
        return _
      }),
        r.d(e, "DateUnit", function() {
          return m
        }),
        r.d(e, "IntervalUnit", function() {
          return A
        }),
        r.d(e, "MessageHeader", function() {
          return B
        }),
        r.d(e, "MetadataVersion", function() {
          return S
        }),
        r.d(e, "Precision", function() {
          return v
        }),
        r.d(e, "TimeUnit", function() {
          return w
        }),
        r.d(e, "Type", function() {
          return b
        }),
        r.d(e, "UnionMode", function() {
          return I
        }),
        r.d(e, "BufferType", function() {
          return g
        }),
        r.d(e, "Data", function() {
          return Pt
        }),
        r.d(e, "DataType", function() {
          return J
        }),
        r.d(e, "Null", function() {
          return G
        }),
        r.d(e, "Bool", function() {
          return ht
        }),
        r.d(e, "Int", function() {
          return q
        }),
        r.d(e, "Int8", function() {
          return Z
        }),
        r.d(e, "Int16", function() {
          return X
        }),
        r.d(e, "Int32", function() {
          return Q
        }),
        r.d(e, "Int64", function() {
          return tt
        }),
        r.d(e, "Uint8", function() {
          return et
        }),
        r.d(e, "Uint16", function() {
          return rt
        }),
        r.d(e, "Uint32", function() {
          return nt
        }),
        r.d(e, "Uint64", function() {
          return it
        }),
        r.d(e, "Float", function() {
          return st
        }),
        r.d(e, "Float16", function() {
          return ot
        }),
        r.d(e, "Float32", function() {
          return at
        }),
        r.d(e, "Float64", function() {
          return ut
        }),
        r.d(e, "Utf8", function() {
          return lt
        }),
        r.d(e, "Binary", function() {
          return ct
        }),
        r.d(e, "FixedSizeBinary", function() {
          return Et
        }),
        r.d(e, "Date_", function() {
          return ft
        }),
        r.d(e, "DateDay", function() {
          return pt
        }),
        r.d(e, "DateMillisecond", function() {
          return yt
        }),
        r.d(e, "Timestamp", function() {
          return vt
        }),
        r.d(e, "TimestampSecond", function() {
          return It
        }),
        r.d(e, "TimestampMillisecond", function() {
          return At
        }),
        r.d(e, "TimestampMicrosecond", function() {
          return Bt
        }),
        r.d(e, "TimestampNanosecond", function() {
          return St
        }),
        r.d(e, "Time", function() {
          return bt
        }),
        r.d(e, "TimeSecond", function() {
          return gt
        }),
        r.d(e, "TimeMillisecond", function() {
          return _t
        }),
        r.d(e, "TimeMicrosecond", function() {
          return mt
        }),
        r.d(e, "TimeNanosecond", function() {
          return wt
        }),
        r.d(e, "Decimal", function() {
          return dt
        }),
        r.d(e, "List", function() {
          return Ut
        }),
        r.d(e, "Struct", function() {
          return Lt
        }),
        r.d(e, "Union", function() {
          return Ft
        }),
        r.d(e, "DenseUnion", function() {
          return xt
        }),
        r.d(e, "SparseUnion", function() {
          return Mt
        }),
        r.d(e, "Dictionary", function() {
          return Rt
        }),
        r.d(e, "Interval", function() {
          return Tt
        }),
        r.d(e, "IntervalDayTime", function() {
          return Ot
        }),
        r.d(e, "IntervalYearMonth", function() {
          return Dt
        }),
        r.d(e, "FixedSizeList", function() {
          return Nt
        }),
        r.d(e, "Map_", function() {
          return Vt
        }),
        r.d(e, "Table", function() {
          return ra
        }),
        r.d(e, "Column", function() {
          return Ar
        }),
        r.d(e, "Schema", function() {
          return Nr
        }),
        r.d(e, "Field", function() {
          return Vr
        }),
        r.d(e, "Visitor", function() {
          return N
        }),
        r.d(e, "Vector", function() {
          return y
        }),
        r.d(e, "BaseVector", function() {
          return ms
        }),
        r.d(e, "BinaryVector", function() {
          return ws
        }),
        r.d(e, "BoolVector", function() {
          return vs
        }),
        r.d(e, "Chunked", function() {
          return wr
        }),
        r.d(e, "DateVector", function() {
          return Is
        }),
        r.d(e, "DateDayVector", function() {
          return As
        }),
        r.d(e, "DateMillisecondVector", function() {
          return Bs
        }),
        r.d(e, "DecimalVector", function() {
          return Ss
        }),
        r.d(e, "DictionaryVector", function() {
          return Ts
        }),
        r.d(e, "FixedSizeBinaryVector", function() {
          return Os
        }),
        r.d(e, "FixedSizeListVector", function() {
          return Ds
        }),
        r.d(e, "FloatVector", function() {
          return Us
        }),
        r.d(e, "Float16Vector", function() {
          return Ls
        }),
        r.d(e, "Float32Vector", function() {
          return Fs
        }),
        r.d(e, "Float64Vector", function() {
          return xs
        }),
        r.d(e, "IntervalVector", function() {
          return Vs
        }),
        r.d(e, "IntervalDayTimeVector", function() {
          return Cs
        }),
        r.d(e, "IntervalYearMonthVector", function() {
          return Rs
        }),
        r.d(e, "IntVector", function() {
          return js
        }),
        r.d(e, "Int8Vector", function() {
          return ks
        }),
        r.d(e, "Int16Vector", function() {
          return zs
        }),
        r.d(e, "Int32Vector", function() {
          return Ps
        }),
        r.d(e, "Int64Vector", function() {
          return Ys
        }),
        r.d(e, "Uint8Vector", function() {
          return $s
        }),
        r.d(e, "Uint16Vector", function() {
          return Ws
        }),
        r.d(e, "Uint32Vector", function() {
          return Hs
        }),
        r.d(e, "Uint64Vector", function() {
          return Ks
        }),
        r.d(e, "ListVector", function() {
          return Zs
        }),
        r.d(e, "MapVector", function() {
          return Xs
        }),
        r.d(e, "NullVector", function() {
          return Qs
        }),
        r.d(e, "StructVector", function() {
          return eo
        }),
        r.d(e, "TimestampVector", function() {
          return ro
        }),
        r.d(e, "TimestampSecondVector", function() {
          return no
        }),
        r.d(e, "TimestampMillisecondVector", function() {
          return io
        }),
        r.d(e, "TimestampMicrosecondVector", function() {
          return so
        }),
        r.d(e, "TimestampNanosecondVector", function() {
          return oo
        }),
        r.d(e, "TimeVector", function() {
          return ao
        }),
        r.d(e, "TimeSecondVector", function() {
          return uo
        }),
        r.d(e, "TimeMillisecondVector", function() {
          return co
        }),
        r.d(e, "TimeMicrosecondVector", function() {
          return lo
        }),
        r.d(e, "TimeNanosecondVector", function() {
          return ho
        }),
        r.d(e, "UnionVector", function() {
          return fo
        }),
        r.d(e, "DenseUnionVector", function() {
          return po
        }),
        r.d(e, "SparseUnionVector", function() {
          return yo
        }),
        r.d(e, "Utf8Vector", function() {
          return bo
        }),
        r.d(e, "ByteStream", function() {
          return On
        }),
        r.d(e, "AsyncByteStream", function() {
          return Dn
        }),
        r.d(e, "AsyncByteQueue", function() {
          return Tn
        }),
        r.d(e, "RecordBatchReader", function() {
          return oa
        }),
        r.d(e, "RecordBatchFileReader", function() {
          return ca
        }),
        r.d(e, "RecordBatchStreamReader", function() {
          return aa
        }),
        r.d(e, "AsyncRecordBatchFileReader", function() {
          return la
        }),
        r.d(e, "AsyncRecordBatchStreamReader", function() {
          return ua
        }),
        r.d(e, "RecordBatchWriter", function() {
          return us
        }),
        r.d(e, "RecordBatchFileWriter", function() {
          return ls
        }),
        r.d(e, "RecordBatchStreamWriter", function() {
          return cs
        }),
        r.d(e, "RecordBatchJSONWriter", function() {
          return hs
        }),
        r.d(e, "MessageReader", function() {
          return Yi
        }),
        r.d(e, "AsyncMessageReader", function() {
          return $i
        }),
        r.d(e, "JSONMessageReader", function() {
          return Wi
        }),
        r.d(e, "Message", function() {
          return Di
        }),
        r.d(e, "RecordBatch", function() {
          return na
        }),
        r.d(e, "DataFrame", function() {
          return za
        }),
        r.d(e, "FilteredDataFrame", function() {
          return Ya
        }),
        r.d(e, "CountByResult", function() {
          return Pa
        }),
        r.d(e, "predicate", function() {
          return u
        }),
        r.d(e, "util", function() {
          return $a
        }),
        r.d(e, "Builder", function() {
          return te
        }),
        r.d(e, "BinaryBuilder", function() {
          return Qe
        }),
        r.d(e, "BoolBuilder", function() {
          return ne
        }),
        r.d(e, "DateBuilder", function() {
          return se
        }),
        r.d(e, "DateDayBuilder", function() {
          return oe
        }),
        r.d(e, "DateMillisecondBuilder", function() {
          return ae
        }),
        r.d(e, "DecimalBuilder", function() {
          return ue
        }),
        r.d(e, "DictionaryBuilder", function() {
          return ce
        }),
        r.d(e, "FixedSizeBinaryBuilder", function() {
          return le
        }),
        r.d(e, "FixedSizeListBuilder", function() {
          return kr
        }),
        r.d(e, "FloatBuilder", function() {
          return ye
        }),
        r.d(e, "Float16Builder", function() {
          return be
        }),
        r.d(e, "Float32Builder", function() {
          return ge
        }),
        r.d(e, "Float64Builder", function() {
          return _e
        }),
        r.d(e, "IntervalBuilder", function() {
          return Ge
        }),
        r.d(e, "IntervalDayTimeBuilder", function() {
          return qe
        }),
        r.d(e, "IntervalYearMonthBuilder", function() {
          return Ze
        }),
        r.d(e, "IntBuilder", function() {
          return Ue
        }),
        r.d(e, "Int8Builder", function() {
          return Le
        }),
        r.d(e, "Int16Builder", function() {
          return Fe
        }),
        r.d(e, "Int32Builder", function() {
          return xe
        }),
        r.d(e, "Int64Builder", function() {
          return Me
        }),
        r.d(e, "Uint8Builder", function() {
          return Ee
        }),
        r.d(e, "Uint16Builder", function() {
          return Ne
        }),
        r.d(e, "Uint32Builder", function() {
          return Ve
        }),
        r.d(e, "Uint64Builder", function() {
          return Ce
        }),
        r.d(e, "ListBuilder", function() {
          return jr
        }),
        r.d(e, "MapBuilder", function() {
          return zr
        }),
        r.d(e, "NullBuilder", function() {
          return ie
        }),
        r.d(e, "StructBuilder", function() {
          return Pr
        }),
        r.d(e, "TimestampBuilder", function() {
          return $e
        }),
        r.d(e, "TimestampSecondBuilder", function() {
          return We
        }),
        r.d(e, "TimestampMillisecondBuilder", function() {
          return He
        }),
        r.d(e, "TimestampMicrosecondBuilder", function() {
          return Ke
        }),
        r.d(e, "TimestampNanosecondBuilder", function() {
          return Je
        }),
        r.d(e, "TimeBuilder", function() {
          return je
        }),
        r.d(e, "TimeSecondBuilder", function() {
          return ke
        }),
        r.d(e, "TimeMillisecondBuilder", function() {
          return ze
        }),
        r.d(e, "TimeMicrosecondBuilder", function() {
          return Pe
        }),
        r.d(e, "TimeNanosecondBuilder", function() {
          return Ye
        }),
        r.d(e, "UnionBuilder", function() {
          return Yr
        }),
        r.d(e, "DenseUnionBuilder", function() {
          return Wr
        }),
        r.d(e, "SparseUnionBuilder", function() {
          return $r
        }),
        r.d(e, "Utf8Builder", function() {
          return tr
        }),
        (p.a.toDOMStream = function(t, e) {
          if (Object(Wt.f)(t))
            return (function(t, e) {
              let r = null
              const n = (e && "bytes" === e.type) || !1,
                i = (e && e.highWaterMark) || 2 ** 24
              return new ReadableStream(
                {
                  ...e,
                  async start(e) {
                    await s(e, r || (r = t[Symbol.asyncIterator]()))
                  },
                  async pull(t) {
                    r ? await s(t, r) : t.close()
                  },
                  async cancel() {
                    r && r.return && (await r.return()), (r = null)
                  },
                },
                { highWaterMark: n ? i : void 0, ...e }
              )
              async function s(t, e) {
                let r,
                  i = null,
                  s = t.desiredSize || null
                for (; !(i = await e.next(n ? s : null)).done; )
                  if (
                    (ArrayBuffer.isView(i.value) &&
                      (r = Object(kt.toUint8Array)(i.value)) &&
                      (null != s && n && (s = s - r.byteLength + 1),
                      (i.value = r)),
                    t.enqueue(i.value),
                    null != s && --s <= 0)
                  )
                    return
                t.close()
              }
            })(t, e)
          if (Object(Wt.i)(t))
            return (function(t, e) {
              let r = null
              const n = (e && "bytes" === e.type) || !1,
                i = (e && e.highWaterMark) || 2 ** 24
              return new ReadableStream(
                {
                  ...e,
                  start(e) {
                    s(e, r || (r = t[Symbol.iterator]()))
                  },
                  pull(t) {
                    r ? s(t, r) : t.close()
                  },
                  cancel() {
                    r && r.return && r.return(), (r = null)
                  },
                },
                { highWaterMark: n ? i : void 0, ...e }
              )
              function s(t, e) {
                let r,
                  i = null,
                  s = t.desiredSize || null
                for (; !(i = e.next(n ? s : null)).done; )
                  if (
                    (ArrayBuffer.isView(i.value) &&
                      (r = Object(kt.toUint8Array)(i.value)) &&
                      (null != s && n && (s = s - r.byteLength + 1),
                      (i.value = r)),
                    t.enqueue(i.value),
                    null != s && --s <= 0)
                  )
                    return
                t.close()
              }
            })(t, e)
          throw Error(
            "toDOMStream() must be called with an Iterable or AsyncIterable"
          )
        }),
        (te.throughDOM = function(t) {
          return new wa(t)
        }),
        (oa.throughDOM = function(t, e) {
          const r = new Tn()
          let n = null
          const i = new ReadableStream({
            async cancel() {
              await r.close()
            },
            async start(t) {
              await s(
                t,
                n ||
                  (n = await (async function() {
                    return await (await oa.from(r)).open(e)
                  })())
              )
            },
            async pull(t) {
              n ? await s(t, n) : t.close()
            },
          })
          return {
            writable: new WritableStream(r, { highWaterMark: 16384, ...t }),
            readable: i,
          }
          async function s(t, e) {
            let r = t.desiredSize,
              n = null
            for (; !(n = await e.next()).done; )
              if ((t.enqueue(n.value), null != r && --r <= 0)) return
            t.close()
          }
        }),
        (us.throughDOM = function(t, e) {
          const r = new this(t),
            n = new Dn(r),
            i = new ReadableStream(
              {
                type: "bytes",
                async cancel() {
                  await n.cancel()
                },
                async pull(t) {
                  await s(t)
                },
                async start(t) {
                  await s(t)
                },
              },
              { highWaterMark: 16384, ...e }
            )
          return { writable: new WritableStream(r, t), readable: i }
          async function s(t) {
            let e = null,
              r = t.desiredSize
            for (; (e = await n.read(r || null)); )
              if ((t.enqueue(e), null != r && (r -= e.byteLength) <= 0)) return
            t.close()
          }
        })
    },
  ])
})
//# sourceMappingURL=Arrow.esnext.min.js.map
